{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"build/","title":"Build","text":""},{"location":"build/#get-started","title":"Get Started","text":"<p>Whether you\u2019re developing front-end applications using Wormhole's application-layer tools or building smart contract integrations on top of Wormhole\u2019s messaging protocols, learn how Wormhole can help you achieve seamless, multichain interoperability.</p> <ul> <li> <p> Start Building</p> <p>Get equipped with everything you need to start developing with Wormhole, including an overview of supported networks and a list of demo projects.</p> <p> Get started</p> </li> <li> <p> Build Frontend Applications</p> <p>Learn how tools like Queries, Wormhole Connect, and the Wormhole SDK come together to build applications with seamless interoperability.</p> <p> Build applications</p> </li> <li> <p> Build Contract Integrations</p> <p>Begin your journey by creating smart contracts that harness the power of Wormhole's advanced messaging protocols.</p> <p> Build contract integrations</p> </li> <li> <p> Add Chain Integrations</p> <p>Learn how to add cross-chain support to your chain by connecting it to Wormhole's secure communication network.</p> <p> Add chain integrations</p> </li> <li> <p> Toolkit</p> <p>Discover essential developer tools for managing and sending cross-chain transfers, including the Wormholescan explorer, Wormhole CLI, Wormhole SDKs, and more.</p> <p> Discover tools</p> </li> <li> <p> Reference</p> <p>Find essential reference information for development, including canonical contract addresses, Wormhole chain IDs, and consistency levels for Guardians.</p> <p> Explore reference</p> </li> </ul>"},{"location":"build/applications/","title":"Build Frontend Applications","text":""},{"location":"build/applications/#get-started","title":"Get Started","text":"<p>Wormhole offers multiple tools to make your user-facing application integrations easier. Whether you are looking for a type-safe friendly SDK, a React widget to enable user-friendly UI development, or on-demand API access to Guardian attestations, you'll find it here.</p> <ul> <li> <p> Wormhole TypeScript SDK</p> <p>The Wormhole TypeScript SDK exposes constants, contract interfaces, basic types, VAA payload definitions, EVM-specific utilities, and the EVM Token Bridge protocol client, combining convenience with the peace of mind of TypeScript type safety out of the box.</p> <p> Get started with the SDK</p> </li> </ul> <ul> <li> <p> Wormhole Queries</p> <p>Wormhole Queries offers on-demand access to Guardian-attested on-chain data via a simple REST endpoint. Wormhole Guardians, who run full nodes for various connected chains, facilitate this cross-chain query service. This method is faster and more cost-effective, eliminating the need for gas payments and transaction finality wait times.</p> <p> Get started with Queries</p> </li> </ul> <ul> <li> <p> Wormhole Connect</p> <p>Wormhole Connect is a React widget that lets developers offer an easy-to-use interface to facilitate cross-chain asset transfers via Wormhole directly in a web application. Offering both code and no-code styling options, Wormhole Connect is highly customizable to meet the needs of your application.</p> <p> Get started with Connect</p> </li> </ul>"},{"location":"build/applications/wormhole-sdk/","title":"Wormhole TypeScript SDK","text":""},{"location":"build/applications/wormhole-sdk/#introduction","title":"Introduction","text":"<p>The Wormhole TypeScript SDK is useful for interacting with the chains Wormhole supports and the protocols built on top of Wormhole. This package bundles together functions, definitions, and constants that streamline the process of connecting chains and completing transfers using Wormhole. The SDK also offers targeted sub-packages for Wormhole-connected platforms, which allow you to add multichain support without creating outsized dependencies.</p> <p>This section covers all you need to know about the functionality and ease of development offered through the Wormhole TypeScript SDK. Take a tour of the package to discover how it helps make integration easier. Learn more about how the SDK abstracts away complexities around concepts like platforms, contexts, and signers. Finally, you'll find guidance on usage, along with code examples, to show you how to use the tools of the SDK.</p> <ul> <li> <p> Installation</p> <p>Find installation instructions for both the meta package and installing specific, individual packages</p> <p> Install the SDK</p> </li> <li> <p> Concepts</p> <p>Understand key concepts and how the SDK abstracts them away. Learn more about platforms, chain context, addresses, and signers</p> <p> Explore concepts</p> </li> <li> <p> Usage</p> <p>Guidance on using the SDK to add seamless interchain messaging to your application, including code examples</p> <p> Use the SDK</p> </li> <li> <p> TSdoc for SDK</p> <p>Review the TSdoc for the Wormhole TypeScript SDK for a detailed look at availabel methods, classes, interfaces, and definitions</p> <p> View the TSdoc on GitHub</p> </li> </ul> <p>Warning</p> <p>This package is a work in progress. The interface may change, and there are likely bugs. Please report any issues you find.</p>"},{"location":"build/applications/wormhole-sdk/#installation","title":"Installation","text":""},{"location":"build/applications/wormhole-sdk/#basic","title":"Basic","text":"<p>To install the meta package using npm, run the following command in the root directory of your project:</p> <pre><code>npm install @wormhole-foundation/sdk\n</code></pre> <p>This package combines all the individual packages to make setup easier while allowing for tree shaking.  </p>"},{"location":"build/applications/wormhole-sdk/#advanced","title":"Advanced","text":"<p>Alternatively, you can install a specific set of published packages individually:</p> <code>sdk-base</code> - exposes constants <pre><code>npm install @wormhole-foundation/sdk-base\n</code></pre> <code>sdk-definitions</code> - exposes contract interfaces, basic types, and VAA payload definitions <pre><code>npm install @wormhole-foundation/sdk-definitions\n</code></pre> <code>sdk-evm</code> - exposes EVM-specific utilities <pre><code>npm install @wormhole-foundation/sdk-evm\n</code></pre> <code>sdk-evm-tokenbridge</code> - exposes the EVM Token Bridge protocol client <pre><code>npm install @wormhole-foundation/sdk-evm-tokenbridge\n</code></pre>"},{"location":"build/applications/wormhole-sdk/#usage","title":"Usage","text":"<p>Getting your integration started is simple. First, import Wormhole:</p> <pre><code>import { wormhole } from '@wormhole-foundation/sdk';\n</code></pre> <p>Then, import each of the ecosystem platforms that you wish to support:</p> <pre><code>import algorand from '@wormhole-foundation/sdk/algorand';\nimport aptos from '@wormhole-foundation/sdk/aptos';\nimport cosmwasm from '@wormhole-foundation/sdk/cosmwasm';\nimport evm from '@wormhole-foundation/sdk/evm';\nimport solana from '@wormhole-foundation/sdk/solana';\nimport sui from '@wormhole-foundation/sdk/sui';\n</code></pre> <p>To make the platform modules available for use, pass them to the Wormhole constructor:</p> <pre><code>  const wh = await wormhole('Testnet', [\n    evm,\n    solana,\n    aptos,\n    algorand,\n    cosmwasm,\n    sui,\n  ]);\n</code></pre> <p>With a configured Wormhole object, you can do things like parse addresses for the provided platforms, get a <code>ChainContext</code> object, or fetch VAAs.</p> <pre><code>  const ctx = wh.getChain('Solana');\n</code></pre> <p>You can retrieve a VAA as follows. In this example, a timeout of <code>60,000</code> milliseconds is used. The amount of time required for the VAA to become available will vary by network.</p> <pre><code>  const vaa = await wh.getVaa(\n    // Wormhole Message ID\n    whm!,\n    // Protocol:Payload name to use for decoding the VAA payload\n    'TokenBridge:Transfer',\n    // Timeout in milliseconds, depending on the chain and network, the VAA may take some time to be available\n    60_000\n  );\n</code></pre> View the complete script <pre><code>import { wormhole } from '@wormhole-foundation/sdk';\n\nimport { Wormhole, amount, signSendWait } from '@wormhole-foundation/sdk';\nimport algorand from '@wormhole-foundation/sdk/algorand';\nimport aptos from '@wormhole-foundation/sdk/aptos';\nimport cosmwasm from '@wormhole-foundation/sdk/cosmwasm';\nimport evm from '@wormhole-foundation/sdk/evm';\nimport solana from '@wormhole-foundation/sdk/solana';\nimport sui from '@wormhole-foundation/sdk/sui';\nimport { getSigner } from './helpers/index.js';\n\n(async function () {\n  const wh = await wormhole('Testnet', [\n    evm,\n    solana,\n    aptos,\n    algorand,\n    cosmwasm,\n    sui,\n  ]);\n\n  const ctx = wh.getChain('Solana');\n\n  const rcv = wh.getChain('Algorand');\n\n  const sender = await getSigner(ctx);\n  const receiver = await getSigner(rcv);\n\n  // Get a Token Bridge contract client on the source\n  const sndTb = await ctx.getTokenBridge();\n\n  // Send the native token of the source chain\n  const tokenId = Wormhole.tokenId(ctx.chain, 'native');\n\n  // Bigint amount using `amount` module\n  const amt = amount.units(amount.parse('0.1', ctx.config.nativeTokenDecimals));\n\n  // Create a transaction stream for transfers\n  const transfer = sndTb.transfer(\n    sender.address.address,\n    receiver.address,\n    tokenId.address,\n    amt\n  );\n\n  // Sign and send the transaction\n  const txids = await signSendWait(ctx, transfer, sender.signer);\n  console.log('Sent: ', txids);\n\n  // Get the Wormhole message ID from the transaction\n  const [whm] = await ctx.parseTransaction(txids[txids.length - 1]!.txid);\n  console.log('Wormhole Messages: ', whm);\n\n  const vaa = await wh.getVaa(\n    // Wormhole Message ID\n    whm!,\n    // Protocol:Payload name to use for decoding the VAA payload\n    'TokenBridge:Transfer',\n    // Timeout in milliseconds, depending on the chain and network, the VAA may take some time to be available\n    60_000\n  );\n\n  // Now get the token bridge on the redeem side\n  const rcvTb = await rcv.getTokenBridge();\n\n  // Create a transaction stream for redeeming\n  const redeem = rcvTb.redeem(receiver.address.address, vaa!);\n\n  // Sign and send the transaction\n  const rcvTxids = await signSendWait(rcv, redeem, receiver.signer);\n  console.log('Sent: ', rcvTxids);\n\n  // Now check if the transfer is completed according to\n  // the destination token bridge\n  const finished = await rcvTb.isTransferCompleted(vaa!);\n  console.log('Transfer completed: ', finished);\n})();\n</code></pre> <p>Optionally, you can override the default configuration with a partial <code>WormholeConfig</code> object to specify particular fields, such as a different RPC endpoint.</p> <pre><code>const wh = await wormhole('Testnet', [solana], {\n  chains: {\n    Solana: {\n      contracts: {\n        coreBridge: '11111111111111111111111111111',\n      },\n      rpc: 'https://api.devnet.solana.com',\n    },\n  },\n});\n</code></pre> View the complete script <pre><code>import { wormhole } from '@wormhole-foundation/sdk';\nimport solana from '@wormhole-foundation/sdk/solana';\n(async function () {\n  const wh = await wormhole('Testnet', [solana], {\n    chains: {\n      Solana: {\n        contracts: {\n          coreBridge: '11111111111111111111111111111',\n        },\n        rpc: 'https://api.devnet.solana.com',\n      },\n    },\n  });\n  console.log(wh.config.chains.Solana);\n})();\n</code></pre>"},{"location":"build/applications/wormhole-sdk/#concepts","title":"Concepts","text":"<p>Understanding several higher-level Wormhole concepts and how the SDK abstracts them away will help you use the tools most effectively. The following sections will introduce and discuss the concepts of platforms, chain contexts, addresses, signers, and protocols, how they are used in the Wormhole context, and how the SDK helps ease development in each conceptual area.</p>"},{"location":"build/applications/wormhole-sdk/#platforms","title":"Platforms","text":"<p>While every chain has unique attributes, chains from the same platform typically have standard functionalities they share. The SDK includes <code>Platform</code> modules, which create a standardized interface for interacting with the chains of a supported platform. The contents of a module vary by platform but can include:</p> <ul> <li>Protocols, such as Wormhole core, preconfigured to suit the selected platform</li> <li>Definitions and configurations for types, signers, addresses, and chains </li> <li>Helpers configured for dealing with unsigned transactions on the selected platform</li> </ul> <p>These modules also import and expose essential functions and define types or constants from the chain's native ecosystem to reduce the dependencies needed to interact with a chain using Wormhole. Rather than installing the entire native package for each desired platform, you can install a targeted package of standardized functions and definitions essential to connecting with Wormhole, keeping project dependencies as slim as possible.</p> <p>Wormhole currently supports the following platforms:</p> <ul> <li>EVM</li> <li>Solana</li> <li>Cosmos</li> <li>Sui</li> <li>Aptos</li> <li>Algorand</li> </ul> <p>See the Platforms folder of the TypeScript SDK for an up-to-date list of the platforms supported by the Wormhole TypeScript SDK.</p>"},{"location":"build/applications/wormhole-sdk/#chain-context","title":"Chain Context","text":"<p>The <code>definitions</code> package of the SDK includes the <code>ChainContext</code> class, which creates an interface for working with connected chains in a standardized way. This class contains the network, chain, and platform configurations for connected chains and cached RPC and protocol clients. The <code>ChainContext</code> class also exposes chain-specific methods and utilities. Much of the functionality comes from the <code>Platform</code> methods but some specific chains may have overridden methods via the context. This is also where the <code>Network</code>, <code>Chain</code>, and <code>Platform</code> type parameters which are used throughout the package are defined.</p> <pre><code>const srcChain = wh.getChain(senderAddress.chain);\nconst dstChain = wh.getChain(receiverAddress.chain);\n\nconst tb = await srcChain.getTokenBridge(); // =&gt; TokenBridge&lt;'Evm'&gt;\nsrcChain.getRpcClient(); // =&gt; RpcClient&lt;'Evm'&gt;\n</code></pre>"},{"location":"build/applications/wormhole-sdk/#addresses","title":"Addresses","text":"<p>The SDK uses the <code>UniversalAddress</code> class to implement the <code>Address</code> interface, which all address types must implement. Addresses from various networks are parsed into their byte representation and modified as needed to ensure they are exactly 32 bytes long. Each platform also has an address type that understands the native address formats, referred to as <code>NativeAddress.</code> These abstractions allow you to work with addresses consistently regardless of the underlying chain.</p> <pre><code>// It's possible to convert a string address to its Native address\nconst ethAddr: NativeAddress&lt;'Evm'&gt; = toNative('Ethereum', '0xbeef...');\n\n// A common type in the SDK is the `ChainAddress` which provides\n// the additional context of the `Chain` this address is relevant for\nconst senderAddress: ChainAddress = Wormhole.chainAddress(\n  'Ethereum',\n  '0xbeef...'\n);\nconst receiverAddress: ChainAddress = Wormhole.chainAddress(\n  'Solana',\n  'Sol1111...'\n);\n\n// Convert the ChainAddress back to its canonical string address format\nconst strAddress = Wormhole.canonicalAddress(senderAddress); // =&gt; '0xbeef...'\n\n// Or if the ethAddr above is for an emitter and you need the UniversalAddress\nconst emitterAddr = ethAddr.toUniversalAddress().toString();\n</code></pre>"},{"location":"build/applications/wormhole-sdk/#tokens","title":"Tokens","text":"<p>Similar to the <code>ChainAddress</code> type, the <code>TokenId</code> type provides the chain and address of a given token. The following snippet introduces <code>TokenId</code>, a way to uniquely identify any token, whether it's a standard token or a blockchain's native currency (like ETH for Ethereum).</p> <p>Wormhole uses their contract address to create a <code>TokenId</code> for standard tokens. For native currencies, Wormhole uses the keyword <code>native</code> instead of an address. This makes it easy to work with any type of token consistently.</p> <p>Finally, the snippet demonstrates how to convert a <code>TokenId</code> back into a regular address format when needed.</p> <pre><code>const sourceToken: TokenId = Wormhole.tokenId('Ethereum', '0xbeef...');\n\nconst gasToken: TokenId = Wormhole.tokenId('Ethereum', 'native');\n\nconst strAddress = Wormhole.canonicalAddress(senderAddress); // =&gt; '0xbeef...'\n</code></pre>"},{"location":"build/applications/wormhole-sdk/#signers","title":"Signers","text":"<p>Certain methods of signing transactions require a <code>Signer</code> interface in the SDK. Depending on the specific requirements, this interface can be fulfilled by either a <code>SignOnlySigner</code> or a <code>SignAndSendSigner</code>. A signer can be created by wrapping an offline or web wallet.</p> <p>A <code>SignOnlySigner</code> is used when the signer isn't connected to the network or prefers not to broadcast transactions themselves. It accepts an array of unsigned transactions and returns an array of signed and serialized transactions. Before signing, the transactions may be inspected or altered. It's important to note that the serialization process is chain-specific. Refer to the testing signers (e.g., EVM or Solana) for an example of how to implement a signer for a specific chain or platform.</p> <p>Conversely, a <code>SignAndSendSigner</code> is appropriate when the signer is connected to the network and intends to broadcast the transactions. This type of signer also accepts an array of unsigned transactions but returns an array of transaction IDs corresponding to the order of the unsigned transactions.</p> <pre><code>export type Signer = SignOnlySigner | SignAndSendSigner;\n\nexport interface SignOnlySigner {\n  chain(): ChainName;\n  address(): string;\n  // Accept an array of unsigned transactions and return\n  // an array of signed and serialized transactions.\n  // The transactions may be inspected or altered before\n  // signing.\n  sign(tx: UnsignedTransaction[]): Promise&lt;SignedTx[]&gt;;\n}\n\nexport interface SignAndSendSigner {\n  chain(): ChainName;\n  address(): string;\n  // Accept an array of unsigned transactions and return\n  // an array of transaction ids in the same order as the\n  // unsignedTransactions array.\n  signAndSend(tx: UnsignedTransaction[]): Promise&lt;TxHash[]&gt;;\n}\n</code></pre>"},{"location":"build/applications/wormhole-sdk/#protocols","title":"Protocols","text":"<p>While Wormhole is a Generic Message Passing (GMP) protocol, several protocols have been built to provide specific functionality. If available, each protocol will have a platform-specific implementation. These implementations provide methods to generate transactions or read state from the contract on-chain.</p>"},{"location":"build/applications/wormhole-sdk/#wormhole-core","title":"Wormhole Core","text":"<p>The core protocol underlies all Wormhole activity. This protocol is responsible for emitting the message containing the information necessary to perform bridging, including the emitter address, the sequence number for the message, and the payload of the message itself.</p> <p>The following example demonstrates sending and verifying a message using the Wormhole Core protocol on Solana.</p> <p>First, initialize a Wormhole instance for the TestNet environment, specifically for the Solana chain. Then, obtain a signer and its associated address, which will be used to sign transactions.</p> <p>Next, get a reference to the core messaging bridge, which is the main interface for interacting with Wormhole's cross-chain messaging capabilities. The code then prepares a message for publication. This message includes:</p> <ul> <li>The sender's address</li> <li>The message payload (in this case, the encoded string <code>lol</code>)</li> <li>A nonce (set to <code>0</code> here, but can be any user-defined value to uniquely identify the message)</li> <li>A consistency level (set to <code>0</code>, which determines the finality requirements for the message)</li> </ul> <p>After preparing the message, the next steps are to generate, sign, and send the transaction or transactions required to publish the message on the Solana blockchain. Once the transaction is confirmed, the Wormhole message ID is extracted from the transaction logs. This ID is crucial for tracking the message across chains.</p> <p>The code then waits for the Wormhole network to process and sign the message, turning it into a Verified Action Approval (VAA). This VAA is retrieved in a <code>Uint8Array</code> format, with a timeout of 60 seconds.</p> <p>Lastly, the code will demonstrate how to verify the message on the receiving end. A verification transaction is prepared using the original sender's address and the VAA, and finally, this transaction is signed and sent.</p> View the complete script <pre><code>import { encoding, signSendWait, wormhole } from '@wormhole-foundation/sdk';\nimport { getSigner } from './helpers/index.js';\nimport solana from '@wormhole-foundation/sdk/solana';\nimport evm from '@wormhole-foundation/sdk/evm';\n\n(async function () {\n  const wh = await wormhole('Testnet', [solana, evm]);\n\n  const chain = wh.getChain('Avalanche');\n  const { signer, address } = await getSigner(chain);\n\n  // Get a reference to the core messaging bridge\n  const coreBridge = await chain.getWormholeCore();\n\n  // Generate transactions, sign and send them\n  const publishTxs = coreBridge.publishMessage(\n    // Address of sender (emitter in VAA)\n    address.address,\n    // Message to send (payload in VAA)\n    encoding.bytes.encode('lol'),\n    // Nonce (user defined, no requirement for a specific value, useful to provide a unique identifier for the message)\n    0,\n    // ConsistencyLevel (ie finality of the message, see wormhole docs for more)\n    0\n  );\n  // Send the transaction(s) to publish the message\n  const txids = await signSendWait(chain, publishTxs, signer);\n\n  // Take the last txid in case multiple were sent\n  // The last one should be the one containing the relevant\n  // event or log info\n  const txid = txids[txids.length - 1];\n\n  // Grab the wormhole message id from the transaction logs or storage\n  const [whm] = await chain.parseTransaction(txid!.txid);\n\n  // Wait for the vaa to be signed and available with a timeout\n  const vaa = await wh.getVaa(whm!, 'Uint8Array', 60_000);\n  console.log(vaa);\n\n  // Note: calling verifyMessage manually is typically not a useful thing to do\n  // As the VAA is typically submitted to the counterpart contract for\n  // A given protocol and the counterpart contract will verify the VAA\n  // This is simply for demo purposes\n  const verifyTxs = coreBridge.verifyMessage(address.address, vaa!);\n  console.log(await signSendWait(chain, verifyTxs, signer));\n})();\n</code></pre> <p>The payload contains the information necessary to perform whatever action is required based on the protocol that uses it.</p>"},{"location":"build/applications/wormhole-sdk/#token-bridge","title":"Token Bridge","text":"<p>The most familiar protocol built on Wormhole is the Token Bridge. Every chain has a <code>TokenBridge</code> protocol client that provides a consistent interface for interacting with the Token Bridge, which includes methods to generate the transactions required to transfer tokens and methods to generate and redeem attestations. <code>WormholeTransfer</code> abstractions are the recommended way to interact with these protocols, but it is possible to use them directly.</p> <pre><code>import { signSendWait } from '@wormhole-foundation/sdk';\n\nconst tb = await srcChain.getTokenBridge(); \n\nconst token = '0xdeadbeef...';\nconst txGenerator = tb.createAttestation(token); \nconst txids = await signSendWait(srcChain, txGenerator, src.signer);\n</code></pre> <p>Supported protocols are defined in the definitions module.</p>"},{"location":"build/applications/wormhole-sdk/#transfers","title":"Transfers","text":"<p>While using the <code>ChainContext</code> and <code>Protocol</code> clients directly is possible, the SDK provides some helpful abstractions for transferring tokens.</p> <p>The <code>WormholeTransfer</code> interface provides a convenient abstraction to encapsulate the steps involved in a cross-chain transfer.</p>"},{"location":"build/applications/wormhole-sdk/#token-transfers","title":"Token Transfers","text":"<p>Performing a token transfer is trivial for any source and destination chains. You can create a new <code>Wormhole</code> object to make objects like <code>TokenTransfer</code>, <code>CircleTransfer</code>, and <code>GatewayTransfer</code>, to transfer tokens between chains.</p> <p>The following example demonstrates the process of initiating and completing a token transfer. It starts by creating a <code>TokenTransfer</code> object, which tracks the transfer's state throughout its lifecycle. The code then obtains a quote for the transfer, ensuring the amount is sufficient to cover fees and any requested native gas.</p> <p>The transfer process is divided into three main steps:</p> <ol> <li>Initiating the transfer on the source chain</li> <li>Waiting for the transfer to be attested (if not automatic)</li> <li>Completing the transfer on the destination chain</li> </ol> <p>For automatic transfers, the process ends after initiation. The code waits for the transfer to be attested for manual transfers and then completes it on the destination chain.</p> <pre><code>  // Create a TokenTransfer object to track the state of the transfer over time\n  const xfer = await wh.tokenTransfer(\n    route.token,\n    route.amount,\n    route.source.address,\n    route.destination.address,\n    route.delivery?.automatic ?? false,\n    route.payload,\n    route.delivery?.nativeGas\n  );\n\n  const quote = await TokenTransfer.quoteTransfer(\n    wh,\n    route.source.chain,\n    route.destination.chain,\n    xfer.transfer\n  );\n  console.log(quote);\n\n  if (xfer.transfer.automatic &amp;&amp; quote.destinationToken.amount &lt; 0)\n    throw 'The amount requested is too low to cover the fee and any native gas requested.';\n\n  // 1) Submit the transactions to the source chain, passing a signer to sign any txns\n  console.log('Starting transfer');\n  const srcTxids = await xfer.initiateTransfer(route.source.signer);\n  console.log(`Started transfer: `, srcTxids);\n\n  // If automatic, we're done\n  if (route.delivery?.automatic) return xfer;\n\n  // 2) Wait for the VAA to be signed and ready (not required for auto transfer)\n  console.log('Getting Attestation');\n  const attestIds = await xfer.fetchAttestation(60_000);\n  console.log(`Got Attestation: `, attestIds);\n\n  // 3) Redeem the VAA on the dest chain\n  console.log('Completing Transfer');\n  const destTxids = await xfer.completeTransfer(route.destination.signer);\n  console.log(`Completed Transfer: `, destTxids);\n</code></pre> View the complete script <pre><code>import {\n  Chain,\n  Network,\n  TokenId,\n  TokenTransfer,\n  Wormhole,\n  amount,\n  isTokenId,\n  wormhole,\n} from '@wormhole-foundation/sdk';\n\nimport evm from '@wormhole-foundation/sdk/evm';\nimport solana from '@wormhole-foundation/sdk/solana';\nimport { SignerStuff, getSigner, waitLog } from './helpers/index.js';\n\n(async function () {\n  // Init Wormhole object, passing config for which network\n  // to use (e.g. Mainnet/Testnet) and what Platforms to support\n  const wh = await wormhole('Testnet', [evm, solana]);\n\n  // Grab chain Contexts -- these hold a reference to a cached rpc client\n  const sendChain = wh.getChain('Avalanche');\n  const rcvChain = wh.getChain('Solana');\n\n  // Shortcut to allow transferring native gas token\n  const token = Wormhole.tokenId(sendChain.chain, 'native');\n\n  // A TokenId is just a `{chain, address}` pair and an alias for ChainAddress\n  // The `address` field must be a parsed address.\n  // You can get a TokenId (or ChainAddress) prepared for you\n  // by calling the static `chainAddress` method on the Wormhole class.\n  // e.g.\n  // wAvax on Solana\n  // const token = Wormhole.tokenId(\"Solana\", \"3Ftc5hTz9sG4huk79onufGiebJNDMZNL8HYgdMJ9E7JR\");\n  // wSol on Avax\n  // const token = Wormhole.tokenId(\"Avalanche\", \"0xb10563644a6AB8948ee6d7f5b0a1fb15AaEa1E03\");\n\n  // Normalized given token decimals later but can just pass bigints as base units\n  // Note: The Token bridge will dedust past 8 decimals\n  // This means any amount specified past that point will be returned\n  // To the caller\n  const amt = '0.05';\n\n  // With automatic set to true, perform an automatic transfer. This will invoke a relayer\n  // Contract intermediary that knows to pick up the transfers\n  // With automatic set to false, perform a manual transfer from source to destination\n  // Of the token\n  // On the destination side, a wrapped version of the token will be minted\n  // To the address specified in the transfer VAA\n  const automatic = false;\n\n  // The Wormhole relayer has the ability to deliver some native gas funds to the destination account\n  // The amount specified for native gas will be swapped for the native gas token according\n  // To the swap rate provided by the contract, denominated in native gas tokens\n  const nativeGas = automatic ? '0.01' : undefined;\n\n  // Get signer from local key but anything that implements\n  // Signer interface (e.g. wrapper around web wallet) should work\n  const source = await getSigner(sendChain);\n  const destination = await getSigner(rcvChain);\n\n  // Used to normalize the amount to account for the tokens decimals\n  const decimals = isTokenId(token)\n    ? Number(await wh.getDecimals(token.chain, token.address))\n    : sendChain.config.nativeTokenDecimals;\n\n  // Set this to true if you want to perform a round trip transfer\n  const roundTrip: boolean = false;\n\n  // Set this to the transfer txid of the initiating transaction to recover a token transfer\n  // And attempt to fetch details about its progress.\n  let recoverTxid = undefined;\n\n  // Finally create and perform the transfer given the parameters set above\n  const xfer = !recoverTxid\n    ? // Perform the token transfer\n      await tokenTransfer(\n        wh,\n        {\n          token,\n          amount: amount.units(amount.parse(amt, decimals)),\n          source,\n          destination,\n          delivery: {\n            automatic,\n            nativeGas: nativeGas\n              ? amount.units(amount.parse(nativeGas, decimals))\n              : undefined,\n          },\n        },\n        roundTrip\n      )\n    : // Recover the transfer from the originating txid\n      await TokenTransfer.from(wh, {\n        chain: source.chain.chain,\n        txid: recoverTxid,\n      });\n\n  const receipt = await waitLog(wh, xfer);\n\n  // Log out the results\n  console.log(receipt);\n})();\n\nasync function tokenTransfer&lt;N extends Network&gt;(\n  wh: Wormhole&lt;N&gt;,\n  route: {\n    token: TokenId;\n    amount: bigint;\n    source: SignerStuff&lt;N, Chain&gt;;\n    destination: SignerStuff&lt;N, Chain&gt;;\n    delivery?: {\n      automatic: boolean;\n      nativeGas?: bigint;\n    };\n    payload?: Uint8Array;\n  },\n  roundTrip?: boolean\n): Promise&lt;TokenTransfer&lt;N&gt;&gt; {\n  // Create a TokenTransfer object to track the state of the transfer over time\n  const xfer = await wh.tokenTransfer(\n    route.token,\n    route.amount,\n    route.source.address,\n    route.destination.address,\n    route.delivery?.automatic ?? false,\n    route.payload,\n    route.delivery?.nativeGas\n  );\n\n  const quote = await TokenTransfer.quoteTransfer(\n    wh,\n    route.source.chain,\n    route.destination.chain,\n    xfer.transfer\n  );\n  console.log(quote);\n\n  if (xfer.transfer.automatic &amp;&amp; quote.destinationToken.amount &lt; 0)\n    throw 'The amount requested is too low to cover the fee and any native gas requested.';\n\n  // 1) Submit the transactions to the source chain, passing a signer to sign any txns\n  console.log('Starting transfer');\n  const srcTxids = await xfer.initiateTransfer(route.source.signer);\n  console.log(`Started transfer: `, srcTxids);\n\n  // If automatic, we're done\n  if (route.delivery?.automatic) return xfer;\n\n  // 2) Wait for the VAA to be signed and ready (not required for auto transfer)\n  console.log('Getting Attestation');\n  const attestIds = await xfer.fetchAttestation(60_000);\n  console.log(`Got Attestation: `, attestIds);\n\n  // 3) Redeem the VAA on the dest chain\n  console.log('Completing Transfer');\n  const destTxids = await xfer.completeTransfer(route.destination.signer);\n  console.log(`Completed Transfer: `, destTxids);\n\n  // If no need to send back, dip\n  if (!roundTrip) return xfer;\n\n  const { destinationToken: token } = quote;\n  return await tokenTransfer(wh, {\n    ...route,\n    token: token.token,\n    amount: token.amount,\n    source: route.destination,\n    destination: route.source,\n  });\n}\n</code></pre> <p>Internally, this uses the TokenBridge protocol client to transfer tokens. Like other Protocols, the <code>TokenBridge</code> protocol provides a consistent set of methods across all chains to generate a set of transactions for that specific chain.</p>"},{"location":"build/applications/wormhole-sdk/#native-usdc-transfers","title":"Native USDC Transfers","text":"<p>You can also transfer native USDC using Circle's CCTP. Please note that if the transfer is set to <code>Automatic</code> mode, a fee for performing the relay will be included in the quote. This fee is deducted from the total amount requested to be sent. For example, if the user wishes to receive <code>1.0</code> on the destination, the amount sent should be adjusted to <code>1.0</code> plus the relay fee. The same principle applies to native gas drop offs.</p> <p>In the following example, the <code>wh.circleTransfer</code> function is called with several parameters to set up the transfer. It takes the amount to be transferred (in the token's base units), the sender's chain and address, and the receiver's chain and address. The function also allows specifying whether the transfer should be automatic, meaning it will be completed without further user intervention.</p> <p>An optional payload can be included with the transfer, though it's set to undefined in this case . Finally, if the transfer is automatic, you can request that native gas (the blockchain's native currency used for transaction fees) be sent to the receiver along with the transferred tokens.</p> <p>When waiting for the <code>VAA</code>, a timeout of <code>60,000</code> milliseconds is used. The amount of time required for the VAA to become available will vary by network.</p> <pre><code>  const xfer = await wh.circleTransfer(\n    // Amount as bigint (base units)\n    req.amount,\n    // Sender chain/address\n    src.address,\n    // Receiver chain/address\n    dst.address,\n    // Automatic delivery boolean\n    req.automatic,\n    // Payload to be sent with the transfer\n    undefined,\n    // If automatic, native gas can be requested to be sent to the receiver\n    req.nativeGas\n  );\n\n  // Note, if the transfer is requested to be Automatic, a fee for performing the relay\n  // will be present in the quote. The fee comes out of the amount requested to be sent.\n  // If the user wants to receive 1.0 on the destination, the amount to send should be 1.0 + fee.\n  // The same applies for native gas dropoff\n  const quote = await CircleTransfer.quoteTransfer(\n    src.chain,\n    dst.chain,\n    xfer.transfer\n  );\n  console.log('Quote', quote);\n\n  console.log('Starting Transfer');\n  const srcTxids = await xfer.initiateTransfer(src.signer);\n  console.log(`Started Transfer: `, srcTxids);\n\n  if (req.automatic) {\n    const relayStatus = await waitForRelay(srcTxids[srcTxids.length - 1]!);\n    console.log(`Finished relay: `, relayStatus);\n    return;\n  }\n\n  console.log('Waiting for Attestation');\n  const attestIds = await xfer.fetchAttestation(60_000);\n  console.log(`Got Attestation: `, attestIds);\n\n  console.log('Completing Transfer');\n  const dstTxids = await xfer.completeTransfer(dst.signer);\n  console.log(`Completed Transfer: `, dstTxids);\n}\n</code></pre> View the complete script <pre><code>import {\n  Chain,\n  CircleTransfer,\n  Network,\n  Signer,\n  TransactionId,\n  TransferState,\n  Wormhole,\n  amount,\n  wormhole,\n} from '@wormhole-foundation/sdk';\nimport evm from '@wormhole-foundation/sdk/evm';\nimport solana from '@wormhole-foundation/sdk/solana';\nimport { SignerStuff, getSigner, waitForRelay } from './helpers/index.js';\n\n/*\nNotes:\nOnly a subset of chains are supported by Circle for CCTP, see core/base/src/constants/circle.ts for currently supported chains\n\nAutoRelayer takes a 0.1 USDC fee when transferring to any chain beside Goerli, which is 1 USDC\n*/\n//\n\n(async function () {\n  // Init the Wormhole object, passing in the config for which network\n  // to use (e.g. Mainnet/Testnet) and what Platforms to support\n  const wh = await wormhole('Testnet', [evm, solana]);\n\n  // Grab chain Contexts\n  const sendChain = wh.getChain('Avalanche');\n  const rcvChain = wh.getChain('Solana');\n\n  // Get signer from local key but anything that implements\n  // Signer interface (e.g. wrapper around web wallet) should work\n  const source = await getSigner(sendChain);\n  const destination = await getSigner(rcvChain);\n\n  // 6 decimals for USDC (except for BSC, so check decimals before using this)\n  const amt = amount.units(amount.parse('0.2', 6));\n\n  // Choose whether or not to have the attestation delivered for you\n  const automatic = false;\n\n  // If the transfer is requested to be automatic, you can also request that\n  // during redemption, the receiver gets some amount of native gas transferred to them\n  // so that they may pay for subsequent transactions\n  // The amount specified here is denominated in the token being transferred (USDC here)\n  const nativeGas = automatic ? amount.units(amount.parse('0.0', 6)) : 0n;\n\n  await cctpTransfer(wh, source, destination, {\n    amount: amt,\n    automatic,\n    nativeGas,\n  });\n\n})();\n\nasync function cctpTransfer&lt;N extends Network&gt;(\n  wh: Wormhole&lt;N&gt;,\n  src: SignerStuff&lt;N, any&gt;,\n  dst: SignerStuff&lt;N, any&gt;,\n  req: {\n    amount: bigint;\n    automatic: boolean;\n    nativeGas?: bigint;\n  }\n) {\n\n  const xfer = await wh.circleTransfer(\n    // Amount as bigint (base units)\n    req.amount,\n    // Sender chain/address\n    src.address,\n    // Receiver chain/address\n    dst.address,\n    // Automatic delivery boolean\n    req.automatic,\n    // Payload to be sent with the transfer\n    undefined,\n    // If automatic, native gas can be requested to be sent to the receiver\n    req.nativeGas\n  );\n\n  // Note, if the transfer is requested to be Automatic, a fee for performing the relay\n  // will be present in the quote. The fee comes out of the amount requested to be sent.\n  // If the user wants to receive 1.0 on the destination, the amount to send should be 1.0 + fee.\n  // The same applies for native gas dropoff\n  const quote = await CircleTransfer.quoteTransfer(\n    src.chain,\n    dst.chain,\n    xfer.transfer\n  );\n  console.log('Quote', quote);\n\n  console.log('Starting Transfer');\n  const srcTxids = await xfer.initiateTransfer(src.signer);\n  console.log(`Started Transfer: `, srcTxids);\n\n  if (req.automatic) {\n    const relayStatus = await waitForRelay(srcTxids[srcTxids.length - 1]!);\n    console.log(`Finished relay: `, relayStatus);\n    return;\n  }\n\n  console.log('Waiting for Attestation');\n  const attestIds = await xfer.fetchAttestation(60_000);\n  console.log(`Got Attestation: `, attestIds);\n\n  console.log('Completing Transfer');\n  const dstTxids = await xfer.completeTransfer(dst.signer);\n  console.log(`Completed Transfer: `, dstTxids);\n}\n\nexport async function completeTransfer(\n  wh: Wormhole&lt;Network&gt;,\n  txid: TransactionId,\n  signer: Signer\n): Promise&lt;void&gt; {\n\n  const xfer = await CircleTransfer.from(wh, txid);\n\n  const attestIds = await xfer.fetchAttestation(60 * 60 * 1000);\n  console.log('Got attestation: ', attestIds);\n\n  const dstTxIds = await xfer.completeTransfer(signer);\n  console.log('Completed transfer: ', dstTxIds);\n}\n</code></pre>"},{"location":"build/applications/wormhole-sdk/#gateway-transfers","title":"Gateway Transfers","text":"<p>Gateway transfers are passed through the Wormhole Gateway to or from Cosmos chains. A transfer into Cosmos from outside Cosmos will be automatically delivered to the destination via IBC from the Gateway chain. A transfer within Cosmos will use IBC to transfer from the origin to the Gateway chain and then out from the Gateway to the destination chain.</p> <pre><code>  console.log(\n    `Beginning transfer within cosmos from ${\n      src.chain.chain\n    }:${src.address.address.toString()} to ${\n      dst.chain.chain\n    }:${dst.address.address.toString()}`\n  );\n\n  const xfer = await GatewayTransfer.from(wh, {\n    token: token,\n    amount: amount,\n    from: src.address,\n    to: dst.address,\n  } as GatewayTransferDetails);\n  console.log('Created GatewayTransfer: ', xfer.transfer);\n\n  const srcTxIds = await xfer.initiateTransfer(src.signer);\n  console.log('Started transfer on source chain', srcTxIds);\n\n  const attests = await xfer.fetchAttestation(60_000);\n  console.log('Got attests: ', attests);\n</code></pre> <p>A transfer leaving Cosmos will produce a VAA from the Gateway that must be manually redeemed on the destination chain.</p> <pre><code>  console.log(\n    `Beginning transfer out of cosmos from ${\n      src.chain.chain\n    }:${src.address.address.toString()} to ${\n      dst.chain.chain\n    }:${dst.address.address.toString()}`\n  );\n\n  const xfer = await GatewayTransfer.from(wh, {\n    token: token,\n    amount: amount,\n    from: src.address,\n    to: dst.address,\n  } as GatewayTransferDetails);\n  console.log('Created GatewayTransfer: ', xfer.transfer);\n  const srcTxIds = await xfer.initiateTransfer(src.signer);\n  console.log('Started transfer on source chain', srcTxIds);\n\n  const attests = await xfer.fetchAttestation(600_000);\n  console.log('Got attests', attests);\n\n  // Since we're leaving cosmos, this is required to complete the transfer\n  const dstTxIds = await xfer.completeTransfer(dst.signer);\n  console.log('Completed transfer on destination chain', dstTxIds);\n</code></pre> View the complete script <pre><code>import {\n  Chain,\n  GatewayTransfer,\n  GatewayTransferDetails,\n  Network,\n  TokenId,\n  Wormhole,\n  amount,\n  wormhole,\n} from '@wormhole-foundation/sdk';\n\n// Import the platform specific packages\n\nimport cosmwasm from '@wormhole-foundation/sdk/cosmwasm';\nimport evm from '@wormhole-foundation/sdk/evm';\nimport solana from '@wormhole-foundation/sdk/solana';\nimport { SignerStuff, getSigner } from './helpers/index.js';\n\n// We're going to transfer into, around, and out of the Cosmos ecosystem\n// First on Avalanche, transparently through gateway and over IBC to Cosmoshub\n// Then over IBC, transparently through gateway and over IBC to Osmosis\n// Finally out of Osmosis, transparently through gateway, out to Avalanche\n\n// eg:\n//  Avalanche[avax] =&gt; {Gateway -&gt;}Osmosis[gateway/wrapped avax]\n//  Osmosis[gateway/wrapped avax] -&gt; {Gateway -&gt;} Cosmoshub[gateway/wrapped avax]\n//  Cosmoshub[gateway/wrapped avax] -&gt; {Gateway} =&gt; Avalanch[avax]\n\n// Key:\n//   =&gt; : Regular contract call\n//   -&gt; : IBC Transfer\n//   {*}: Transparently handled by Gateway\n\n(async function () {\n  // Init Wormhole object, passing config for which network\n  // to use (e.g. Mainnet/Testnet) and what Platforms to support\n  const wh = await wormhole('Mainnet', [evm, solana, cosmwasm]);\n  // Pick up where you left off by updating the txids as you go\n  let fakeIt = false;\n\n  // Grab chain Contexts for each leg of our journey\n  const external = wh.getChain('Solana');\n  const cosmos1 = wh.getChain('Dymension');\n  const cosmos2 = wh.getChain('Injective');\n\n  // Get signer from local key but anything that implements\n  // Signer interface (e.g. wrapper around web wallet) should work\n  const leg1 = await getSigner(external);\n  const leg2 = await getSigner(cosmos1);\n  const leg3 = await getSigner(cosmos2);\n\n  // We'll use the native token on the source chain\n  const token: TokenId = Wormhole.tokenId(external.chain, 'native');\n  const amt = amount.units(\n    amount.parse('0.001', external.config.nativeTokenDecimals)\n  );\n\n  // Transfer native token from source chain, through gateway, to a cosmos chain\n  let route1 = fakeIt\n    ? await GatewayTransfer.from(\n        wh,\n        {\n          chain: external.chain,\n          txid: '5y2BnJ1Nwqe4m6KTSrry5Ni88xqVrqo4jdbuNwAPDuXEonQRVLbALf7abViwucKKr8U8cDfJtDmqnuRAAC6i6wtb',\n        },\n        600_000\n      )\n    : await transferIntoCosmos(wh, token, amt, leg1, leg2);\n  console.log('Route 1 (External =&gt; Cosmos)', route1);\n\n  // Lookup the Gateway representation of the wrappd token\n  const { denom } = route1.ibcTransfers![0]!.data;\n  const cosmosTokenAddress = Wormhole.parseAddress('Wormchain', denom);\n\n  // Transfer Gateway factory tokens over IBC through gateway to another Cosmos chain\n  let route2 = fakeIt\n    ? await GatewayTransfer.from(\n        wh,\n        {\n          chain: cosmos1.chain,\n          txid: '3014CABA727C8A1BFCBD282095C771ACBAB3B13CC595B702ABFD3A4502315FBD',\n        },\n        600_000\n      )\n    : await transferBetweenCosmos(\n        wh,\n        { chain: cosmos1.chain, address: cosmosTokenAddress },\n        1000n,\n        leg2,\n        leg3\n      );\n  console.log('Route 2 (Cosmos -&gt; Cosmos): ', route2);\n\n  // Transfer Gateway factory token through gateway back to source chain\n  let route3 = fakeIt\n    ? await GatewayTransfer.from(\n        wh,\n        {\n          chain: cosmos2.chain,\n          txid: 'BEDD0CE2FEA8FF5DF81FCA5142E72745E154F87D496CDA147FC4D5D46A7C7D81',\n        },\n        600_000\n      )\n    : await transferOutOfCosmos(\n        wh,\n        { chain: cosmos2.chain, address: cosmosTokenAddress },\n        1000n,\n        leg3,\n        leg1\n      );\n  console.log('Route 3 (Cosmos =&gt; External): ', route3);\n})();\n\nasync function transferIntoCosmos(\n  wh: Wormhole&lt;Network&gt;,\n  token: TokenId,\n  amount: bigint,\n  src: SignerStuff&lt;Network, Chain&gt;,\n  dst: SignerStuff&lt;Network, Chain&gt;\n): Promise&lt;GatewayTransfer&lt;Network&gt;&gt; {\n  console.log(\n    `Beginning transfer into Cosmos from ${\n      src.chain.chain\n    }:${src.address.address.toString()} to ${\n      dst.chain.chain\n    }:${dst.address.address.toString()}`\n  );\n\n  const xfer = await GatewayTransfer.from(wh, {\n    token: token,\n    amount: amount,\n    from: src.address,\n    to: dst.address,\n  } as GatewayTransferDetails);\n  console.log('Created GatewayTransfer: ', xfer.transfer);\n\n  const srcTxIds = await xfer.initiateTransfer(src.signer);\n  console.log('Started transfer on source chain', srcTxIds);\n\n  const attests = await xfer.fetchAttestation(600_000);\n  console.log('Got Attestations', attests);\n  return xfer;\n}\n\nasync function transferBetweenCosmos&lt;N extends Network&gt;(\n  wh: Wormhole&lt;N&gt;,\n  token: TokenId,\n  amount: bigint,\n  src: SignerStuff&lt;N, Chain&gt;,\n  dst: SignerStuff&lt;N, Chain&gt;\n): Promise&lt;GatewayTransfer&lt;N&gt;&gt; {\n  console.log(\n    `Beginning transfer within cosmos from ${\n      src.chain.chain\n    }:${src.address.address.toString()} to ${\n      dst.chain.chain\n    }:${dst.address.address.toString()}`\n  );\n\n  const xfer = await GatewayTransfer.from(wh, {\n    token: token,\n    amount: amount,\n    from: src.address,\n    to: dst.address,\n  } as GatewayTransferDetails);\n  console.log('Created GatewayTransfer: ', xfer.transfer);\n\n  const srcTxIds = await xfer.initiateTransfer(src.signer);\n  console.log('Started transfer on source chain', srcTxIds);\n\n  const attests = await xfer.fetchAttestation(60_000);\n  console.log('Got attests: ', attests);\n\n  return xfer;\n}\n\nasync function transferOutOfCosmos&lt;N extends Network&gt;(\n  wh: Wormhole&lt;N&gt;,\n  token: TokenId,\n  amount: bigint,\n  src: SignerStuff&lt;N, Chain&gt;,\n  dst: SignerStuff&lt;N, Chain&gt;\n): Promise&lt;GatewayTransfer&lt;N&gt;&gt; {\n  console.log(\n    `Beginning transfer out of cosmos from ${\n      src.chain.chain\n    }:${src.address.address.toString()} to ${\n      dst.chain.chain\n    }:${dst.address.address.toString()}`\n  );\n\n  const xfer = await GatewayTransfer.from(wh, {\n    token: token,\n    amount: amount,\n    from: src.address,\n    to: dst.address,\n  } as GatewayTransferDetails);\n  console.log('Created GatewayTransfer: ', xfer.transfer);\n  const srcTxIds = await xfer.initiateTransfer(src.signer);\n  console.log('Started transfer on source chain', srcTxIds);\n\n  const attests = await xfer.fetchAttestation(600_000);\n  console.log('Got attests', attests);\n\n  // Since we're leaving cosmos, this is required to complete the transfer\n  const dstTxIds = await xfer.completeTransfer(dst.signer);\n  console.log('Completed transfer on destination chain', dstTxIds);\n\n  return xfer;\n}\n</code></pre>"},{"location":"build/applications/wormhole-sdk/#recovering-transfers","title":"Recovering Transfers","text":"<p>It may be necessary to recover an abandoned transfer before it is completed. To do this, instantiate the <code>Transfer</code> class with the <code>from</code> static method and pass one of several types of identifiers. A <code>TransactionId</code> or <code>WormholeMessageId</code> may be used to recover the transfer.</p> <pre><code>  const xfer = await CircleTransfer.from(wh, txid);\n\n  const attestIds = await xfer.fetchAttestation(60 * 60 * 1000);\n  console.log('Got attestation: ', attestIds);\n\n  const dstTxIds = await xfer.completeTransfer(signer);\n  console.log('Completed transfer: ', dstTxIds);\n</code></pre> View the complete script <pre><code>import {\n  Chain,\n  CircleTransfer,\n  Network,\n  Signer,\n  TransactionId,\n  TransferState,\n  Wormhole,\n  amount,\n  wormhole,\n} from '@wormhole-foundation/sdk';\nimport evm from '@wormhole-foundation/sdk/evm';\nimport solana from '@wormhole-foundation/sdk/solana';\nimport { SignerStuff, getSigner, waitForRelay } from './helpers/index.js';\n\n/*\nNotes:\nOnly a subset of chains are supported by Circle for CCTP, see core/base/src/constants/circle.ts for currently supported chains\n\nAutoRelayer takes a 0.1 USDC fee when transferring to any chain beside Goerli, which is 1 USDC\n*/\n//\n\n(async function () {\n  // Init the Wormhole object, passing in the config for which network\n  // to use (e.g. Mainnet/Testnet) and what Platforms to support\n  const wh = await wormhole('Testnet', [evm, solana]);\n\n  // Grab chain Contexts\n  const sendChain = wh.getChain('Avalanche');\n  const rcvChain = wh.getChain('Solana');\n\n  // Get signer from local key but anything that implements\n  // Signer interface (e.g. wrapper around web wallet) should work\n  const source = await getSigner(sendChain);\n  const destination = await getSigner(rcvChain);\n\n  // 6 decimals for USDC (except for BSC, so check decimals before using this)\n  const amt = amount.units(amount.parse('0.2', 6));\n\n  // Choose whether or not to have the attestation delivered for you\n  const automatic = false;\n\n  // If the transfer is requested to be automatic, you can also request that\n  // during redemption, the receiver gets some amount of native gas transferred to them\n  // so that they may pay for subsequent transactions\n  // The amount specified here is denominated in the token being transferred (USDC here)\n  const nativeGas = automatic ? amount.units(amount.parse('0.0', 6)) : 0n;\n\n  await cctpTransfer(wh, source, destination, {\n    amount: amt,\n    automatic,\n    nativeGas,\n  });\n\n})();\n\nasync function cctpTransfer&lt;N extends Network&gt;(\n  wh: Wormhole&lt;N&gt;,\n  src: SignerStuff&lt;N, any&gt;,\n  dst: SignerStuff&lt;N, any&gt;,\n  req: {\n    amount: bigint;\n    automatic: boolean;\n    nativeGas?: bigint;\n  }\n) {\n\n  const xfer = await wh.circleTransfer(\n    // Amount as bigint (base units)\n    req.amount,\n    // Sender chain/address\n    src.address,\n    // Receiver chain/address\n    dst.address,\n    // Automatic delivery boolean\n    req.automatic,\n    // Payload to be sent with the transfer\n    undefined,\n    // If automatic, native gas can be requested to be sent to the receiver\n    req.nativeGas\n  );\n\n  // Note, if the transfer is requested to be Automatic, a fee for performing the relay\n  // will be present in the quote. The fee comes out of the amount requested to be sent.\n  // If the user wants to receive 1.0 on the destination, the amount to send should be 1.0 + fee.\n  // The same applies for native gas dropoff\n  const quote = await CircleTransfer.quoteTransfer(\n    src.chain,\n    dst.chain,\n    xfer.transfer\n  );\n  console.log('Quote', quote);\n\n  console.log('Starting Transfer');\n  const srcTxids = await xfer.initiateTransfer(src.signer);\n  console.log(`Started Transfer: `, srcTxids);\n\n  if (req.automatic) {\n    const relayStatus = await waitForRelay(srcTxids[srcTxids.length - 1]!);\n    console.log(`Finished relay: `, relayStatus);\n    return;\n  }\n\n  console.log('Waiting for Attestation');\n  const attestIds = await xfer.fetchAttestation(60_000);\n  console.log(`Got Attestation: `, attestIds);\n\n  console.log('Completing Transfer');\n  const dstTxids = await xfer.completeTransfer(dst.signer);\n  console.log(`Completed Transfer: `, dstTxids);\n}\n\nexport async function completeTransfer(\n  wh: Wormhole&lt;Network&gt;,\n  txid: TransactionId,\n  signer: Signer\n): Promise&lt;void&gt; {\n\n  const xfer = await CircleTransfer.from(wh, txid);\n\n  const attestIds = await xfer.fetchAttestation(60 * 60 * 1000);\n  console.log('Got attestation: ', attestIds);\n\n  const dstTxIds = await xfer.completeTransfer(signer);\n  console.log('Completed transfer: ', dstTxIds);\n}\n</code></pre>"},{"location":"build/applications/wormhole-sdk/#routes","title":"Routes","text":"<p>While a specific <code>WormholeTransfer</code>, such as <code>TokenTransfer</code> or <code>CCTPTransfer</code>, may be used, the developer must know exactly which transfer type to use for a given request.</p> <p>To provide a more flexible and generic interface, the <code>Wormhole</code> class provides a method to produce a <code>RouteResolver</code> that can be configured with a set of possible routes to be supported.</p> <p>The following section demonstrates setting up and validating a token transfer using Wormhole's routing system.</p> <pre><code>  // Create new resolver, passing the set of routes to consider\n  const resolver = wh.resolver([\n    routes.TokenBridgeRoute, // manual token bridge\n    routes.AutomaticTokenBridgeRoute, // automatic token bridge\n    routes.CCTPRoute, // manual CCTP\n    routes.AutomaticCCTPRoute, // automatic CCTP\n    routes.AutomaticPorticoRoute, // Native eth transfers\n  ]);\n</code></pre> <p>Once created, the resolver can be used to provide a list of input and possible output tokens.</p> <pre><code>  // What tokens are available on the source chain?\n  const srcTokens = await resolver.supportedSourceTokens(sendChain);\n  console.log(\n    'Allowed source tokens: ',\n    srcTokens.map((t) =&gt; canonicalAddress(t))\n  );\n\n  const sendToken = Wormhole.tokenId(sendChain.chain, 'native');\n\n  // Given the send token, what can we possibly get on the destination chain?\n  const destTokens = await resolver.supportedDestinationTokens(\n    sendToken,\n    sendChain,\n    destChain\n  );\n  console.log(\n    'For the given source token and routes configured, the following tokens may be receivable: ',\n    destTokens.map((t) =&gt; canonicalAddress(t))\n  );\n  // Grab the first one for the example\n  const destinationToken = destTokens[0]!;\n</code></pre> <p>Once the tokens are selected, a <code>RouteTransferRequest</code> may be created to provide a list of routes that can fulfill the request. Creating a transfer request fetches the token details since all routes will need to know about the tokens.</p> <pre><code>  // Creating a transfer request fetches token details\n  // Since all routes will need to know about the tokens\n  const tr = await routes.RouteTransferRequest.create(wh, {\n    source: sendToken,\n    destination: destinationToken,\n  });\n\n  // Resolve the transfer request to a set of routes that can perform it\n  const foundRoutes = await resolver.findRoutes(tr);\n  console.log(\n    'For the transfer parameters, we found these routes: ',\n    foundRoutes\n  );\n</code></pre> <p>Choosing the best route is currently left to the developer, but strategies might include sorting by output amount or expected time to complete the transfer (no estimate is currently provided).</p> <p>After choosing the best route, extra parameters like <code>amount</code>, <code>nativeGasDropoff</code>, and <code>slippage</code> can be passed, depending on the specific route selected. A quote can be retrieved with the validated request.</p> <p>After successful validation, the code requests a transfer quote. This quote likely includes important details such as fees, estimated time, and the final amount to be received. If the quote is generated successfully, it's displayed for the user to review and decide whether to proceed with the transfer. This process ensures that all transfer details are properly set up and verified before any actual transfer occurs.</p> <pre><code>  console.log(\n    'This route offers the following default options',\n    bestRoute.getDefaultOptions()\n  );\n\n  // Specify the amount as a decimal string\n  const amt = '0.001';\n  // Create the transfer params for this request\n  const transferParams = { amount: amt, options: { nativeGas: 0 } };\n\n  // Validate the transfer params passed, this returns a new type of ValidatedTransferParams\n  // which (believe it or not) is a validated version of the input params\n  // This new var must be passed to the next step, quote\n  const validated = await bestRoute.validate(tr, transferParams);\n  if (!validated.valid) throw validated.error;\n  console.log('Validated parameters: ', validated.params);\n\n  // Get a quote for the transfer, this too returns a new type that must\n  // be passed to the next step, execute (if you like the quote)\n  const quote = await bestRoute.quote(tr, validated.params);\n  if (!quote.success) throw quote.error;\n  console.log('Best route quote: ', quote);\n</code></pre> <p>Finally, assuming the quote looks good, the route can initiate the request with the quote and the <code>signer</code>.</p> <pre><code>    const receipt = await bestRoute.initiate(\n      tr,\n      sender.signer,\n      quote,\n      receiver.address\n    );\n    console.log('Initiated transfer with receipt: ', receipt);\n</code></pre> View the complete script <pre><code>import {\n  Wormhole,\n  canonicalAddress,\n  routes,\n  wormhole,\n} from '@wormhole-foundation/sdk';\n\nimport evm from '@wormhole-foundation/sdk/evm';\nimport solana from '@wormhole-foundation/sdk/solana';\nimport { getSigner } from './helpers/index.js';\n\n(async function () {\n  // Setup\n  const wh = await wormhole('Testnet', [evm, solana]);\n\n  // Get chain contexts\n  const sendChain = wh.getChain('Avalanche');\n  const destChain = wh.getChain('Solana');\n\n  // Get signers from local config\n  const sender = await getSigner(sendChain);\n  const receiver = await getSigner(destChain);\n\n  // Create new resolver, passing the set of routes to consider\n  const resolver = wh.resolver([\n    routes.TokenBridgeRoute, // manual token bridge\n    routes.AutomaticTokenBridgeRoute, // automatic token bridge\n    routes.CCTPRoute, // manual CCTP\n    routes.AutomaticCCTPRoute, // automatic CCTP\n    routes.AutomaticPorticoRoute, // Native eth transfers\n  ]);\n\n  // What tokens are available on the source chain?\n  const srcTokens = await resolver.supportedSourceTokens(sendChain);\n  console.log(\n    'Allowed source tokens: ',\n    srcTokens.map((t) =&gt; canonicalAddress(t))\n  );\n\n  const sendToken = Wormhole.tokenId(sendChain.chain, 'native');\n\n  // Given the send token, what can we possibly get on the destination chain?\n  const destTokens = await resolver.supportedDestinationTokens(\n    sendToken,\n    sendChain,\n    destChain\n  );\n  console.log(\n    'For the given source token and routes configured, the following tokens may be receivable: ',\n    destTokens.map((t) =&gt; canonicalAddress(t))\n  );\n  // Grab the first one for the example\n  const destinationToken = destTokens[0]!;\n\n  // Creating a transfer request fetches token details\n  // Since all routes will need to know about the tokens\n  const tr = await routes.RouteTransferRequest.create(wh, {\n    source: sendToken,\n    destination: destinationToken,\n  });\n\n  // Resolve the transfer request to a set of routes that can perform it\n  const foundRoutes = await resolver.findRoutes(tr);\n  console.log(\n    'For the transfer parameters, we found these routes: ',\n    foundRoutes\n  );\n\n  const bestRoute = foundRoutes[0]!;\n  console.log('Selected: ', bestRoute);\n\n  console.log(\n    'This route offers the following default options',\n    bestRoute.getDefaultOptions()\n  );\n\n  // Specify the amount as a decimal string\n  const amt = '0.001';\n  // Create the transfer params for this request\n  const transferParams = { amount: amt, options: { nativeGas: 0 } };\n\n  // Validate the transfer params passed, this returns a new type of ValidatedTransferParams\n  // which (believe it or not) is a validated version of the input params\n  // This new var must be passed to the next step, quote\n  const validated = await bestRoute.validate(tr, transferParams);\n  if (!validated.valid) throw validated.error;\n  console.log('Validated parameters: ', validated.params);\n\n  // Get a quote for the transfer, this too returns a new type that must\n  // be passed to the next step, execute (if you like the quote)\n  const quote = await bestRoute.quote(tr, validated.params);\n  if (!quote.success) throw quote.error;\n  console.log('Best route quote: ', quote);\n\n  // If you're sure you want to do this, set this to true\n  const imSure = false;\n  if (imSure) {\n    // Now the transfer may be initiated\n    // A receipt will be returned, guess what you gotta do with that?\n    const receipt = await bestRoute.initiate(\n      tr,\n      sender.signer,\n      quote,\n      receiver.address\n    );\n    console.log('Initiated transfer with receipt: ', receipt);\n\n    // Kick off a wait log, if there is an opportunity to complete, this function will do it\n    // See the implementation for how this works\n    await routes.checkAndCompleteTransfer(bestRoute, receipt, receiver.signer);\n  } else {\n    console.log('Not initiating transfer (set `imSure` to true to do so)');\n  }\n})();\n</code></pre> <p>See the <code>router.ts</code> example in the examples directory for a full working example.</p>"},{"location":"build/applications/wormhole-sdk/#see-also","title":"See Also","text":"<p>The TSdoc is available on GitHub.</p>"},{"location":"build/applications/connect/","title":"Wormhole Connect","text":""},{"location":"build/applications/connect/#get-started","title":"Get Started","text":"<p>Wormhole Connect is a React widget offering an easy-to-use interface to facilitate cross-chain asset transfers via Wormhole directly in a web application.</p> <ul> <li> <p> Overview</p> <p>Explore Wormhole Connect, the React widget that allows you to offer an easy-to-use UI for cross-chain asset transfers via Wormhole in a web application.</p> <p> Get started</p> </li> <li> <p> Routes</p> <p>Explore Wormhole Connect's routing capabilities for asset transfers, featuring Token Bridge, CCTP, NTT, and various blockchain-specific routes for optimal UX.</p> <p> Explore routes</p> </li> <li> <p> Features</p> <p>Learn which features of Connect are available for your network of choice.</p> <p> Discover supported features</p> </li> <li> <p> Configuration</p> <p>Configure Wormhole Connect for React or HTML, set themes, define tokens, networks, and customize RPC endpoints for enhanced blockchain interactions.</p> <p> Configure for customization</p> </li> </ul>"},{"location":"build/applications/connect/#additional-resources","title":"Additional Resources","text":"<ul> <li> <p> Codeless Interface</p> <p>Check out the codeless interface for an easy approach to styling and customizing a Connect widget for your multichain application.</p> <p> Quickly get started</p> </li> <li> <p> A Live Example</p> <p>View an example of the Wormhole Connect widget live in a production application.</p> <p> See Connect in action</p> </li> </ul>"},{"location":"build/applications/connect/configuration/","title":"Configure Your Connect Widget","text":""},{"location":"build/applications/connect/configuration/#introduction","title":"Introduction","text":"<p>Configure the Wormhole Connect React component by passing a <code>WormholeConnectConfig</code> object as the <code>config</code> attribute. If using the hosted version, provide <code>config</code> and <code>theme</code> as JSON-serialized strings on the mount point.</p> ReactHTML Tags <pre><code>import WormholeConnect, {\n  WormholeConnectConfig,\n} from '@wormhole-foundation/wormhole-connect';\n\nconst config: WormholeConnectConfig = {\n  networks: ['ethereum', 'polygon', 'solana'],\n  tokens: ['ETH', 'WETH', 'MATIC', 'WMATIC'],\n  rpcs: {\n    ethereum: 'https://rpc.ankr.com/eth',\n    solana: 'https://rpc.ankr.com/solana',\n  }\n}\n\n// ...\n\n&lt;WormholeConnect config={config} /&gt;\n</code></pre> <pre><code>&lt;div\n  id=\"wormhole-connect\"\n  data-config='{\"tokens\":[\"ETH\",\"WETH\",\"WBTC\",\"USDCeth\"]}'\n  data-theme='{\"background\":{\"default\": \"#81c784\"}}'\n/&gt;\n</code></pre>"},{"location":"build/applications/connect/configuration/#examples","title":"Examples","text":"<p>Below are some examples of different ways you can configure Connect. See <code>WormholeConnectConfig</code> in the below file for a full view of the supported configuration parameters.</p> View <code>WormholeConnectConfig</code> <pre><code>import {\n  ChainName,\n  WormholeContext,\n  WormholeConfig,\n  ChainResourceMap,\n} from 'sdklegacy';\nimport MAINNET from './mainnet';\nimport TESTNET from './testnet';\nimport DEVNET from './devnet';\nimport type { WormholeConnectConfig } from './types';\nimport {\n  Network,\n  InternalConfig,\n  Route,\n  WrappedTokenAddressCache,\n} from './types';\nimport {\n  mergeCustomTokensConfig,\n  mergeNttGroups,\n  validateDefaults,\n} from './utils';\nimport { wrapEventHandler } from './events';\n\nimport { SDKConverter } from './converter';\n\nimport {\n  wormhole as getWormholeV2,\n  Wormhole as WormholeV2,\n  Network as NetworkV2,\n  Token as TokenV2,\n  Chain as ChainV2,\n  ChainTokens as ChainTokensV2,\n  WormholeConfigOverrides as WormholeConfigOverridesV2,\n} from '@wormhole-foundation/sdk';\n\nimport '@wormhole-foundation/sdk/addresses';\nimport evm from '@wormhole-foundation/sdk/evm';\nimport solana from '@wormhole-foundation/sdk/solana';\nimport aptos from '@wormhole-foundation/sdk/aptos';\nimport sui from '@wormhole-foundation/sdk/sui';\nimport cosmwasm from '@wormhole-foundation/sdk/cosmwasm';\nimport algorand from '@wormhole-foundation/sdk/algorand';\n\nexport function buildConfig(\n  customConfig?: WormholeConnectConfig,\n): InternalConfig&lt;NetworkV2&gt; {\n  const network = (\n    customConfig?.network ||\n    customConfig?.env || // TODO remove; deprecated\n    import.meta.env.REACT_APP_CONNECT_ENV?.toLowerCase() ||\n    'mainnet'\n  ).toLowerCase() as Network;\n\n  if (!['mainnet', 'testnet', 'devnet'].includes(network))\n    throw new Error(`Invalid env \"${network}\"`);\n\n  const networkData = { MAINNET, DEVNET, TESTNET }[network.toUpperCase()]!;\n\n  const tokens = mergeCustomTokensConfig(\n    networkData.tokens,\n    customConfig?.tokensConfig,\n  );\n\n  const sdkConfig = WormholeContext.getConfig(network);\n\n  const rpcs = Object.assign(\n    {},\n    sdkConfig.rpcs,\n    networkData.rpcs,\n    customConfig?.rpcs,\n  );\n\n  const wh = getWormholeContext(network, sdkConfig, rpcs);\n\n  if (customConfig?.bridgeDefaults) {\n    validateDefaults(customConfig.bridgeDefaults, networkData.chains, tokens);\n  }\n\n  const sdkConverter = new SDKConverter(wh);\n\n  return {\n    wh,\n    sdkConfig,\n    sdkConverter,\n\n    v2Network: sdkConverter.toNetworkV2(network),\n\n    network,\n    isMainnet: network === 'mainnet',\n    // External resources\n    rpcs,\n    rest: Object.assign(\n      {},\n      sdkConfig.rest,\n      networkData.rest,\n      customConfig?.rest,\n    ),\n    graphql: Object.assign({}, networkData.graphql, customConfig?.graphql),\n    wormholeApi: {\n      mainnet: 'https://api.wormholescan.io/',\n      testnet: 'https://api.testnet.wormholescan.io/',\n      devnet: '',\n    }[network],\n    wormholeRpcHosts: {\n      mainnet: [\n        'https://wormhole-v2-mainnet-api.mcf.rocks',\n        'https://wormhole-v2-mainnet-api.chainlayer.network',\n        'https://wormhole-v2-mainnet-api.staking.fund',\n      ],\n      testnet: [\n        'https://guardian.testnet.xlabs.xyz',\n        'https://guardian-01.testnet.xlabs.xyz',\n        'https://guardian-02.testnet.xlabs.xyz',\n      ],\n      devnet: ['http://localhost:7071'],\n    }[network],\n    coinGeckoApiKey: customConfig?.coinGeckoApiKey,\n\n    // Callbacks\n    triggerEvent: wrapEventHandler(customConfig?.eventHandler),\n    validateTransfer: customConfig?.validateTransferHandler,\n\n    // White lists\n    chains: networkData.chains,\n    chainsArr: Object.values(networkData.chains).filter((chain) =&gt; {\n      return customConfig?.networks\n        ? customConfig.networks!.includes(chain.key)\n        : true;\n    }),\n    tokens,\n    tokensArr: Object.values(tokens).filter((token) =&gt; {\n      return customConfig?.tokens\n        ? customConfig.tokens!.includes(token.key)\n        : true;\n    }),\n\n    // For token bridge ^_^\n    wrappedTokenAddressCache: new WrappedTokenAddressCache(\n      tokens,\n      sdkConverter,\n    ),\n\n    gasEstimates: networkData.gasEstimates,\n    // TODO: routes that aren't supported yet are disabled\n    routes: (customConfig?.routes ?? Object.values(Route)).filter((r) =&gt;\n      [\n        Route.Bridge,\n        Route.Relay,\n        Route.NttManual,\n        Route.NttRelay,\n        Route.CCTPManual,\n        Route.CCTPRelay,\n      ].includes(r as Route),\n    ),\n\n    // UI details\n    cta: customConfig?.cta,\n    explorer: customConfig?.explorer,\n    attestUrl: {\n      mainnet: 'https://portalbridge.com/advanced-tools/#/register',\n      devnet: '',\n      testnet:\n        'https://wormhole-foundation.github.io/example-token-bridge-ui/#/register',\n    }[network],\n    bridgeDefaults: customConfig?.bridgeDefaults,\n    cctpWarning: customConfig?.cctpWarning?.href || '',\n    pageHeader: customConfig?.pageHeader,\n    pageSubHeader: customConfig?.pageSubHeader,\n    menu: customConfig?.menu ?? [],\n    searchTx: customConfig?.searchTx,\n    moreTokens: customConfig?.moreTokens,\n    moreNetworks: customConfig?.moreNetworks,\n    partnerLogo: customConfig?.partnerLogo,\n    walletConnectProjectId:\n      customConfig?.walletConnectProjectId ??\n      import.meta.env.REACT_APP_WALLET_CONNECT_PROJECT_ID,\n    showHamburgerMenu: customConfig?.showHamburgerMenu ?? false,\n    previewMode: !!customConfig?.previewMode,\n\n    // Route options\n    ethBridgeMaxAmount: customConfig?.ethBridgeMaxAmount ?? 5,\n    wstETHBridgeMaxAmount: customConfig?.wstETHBridgeMaxAmount ?? 5,\n\n    // NTT config\n    nttGroups: mergeNttGroups(\n      tokens,\n      networkData.nttGroups,\n      customConfig?.nttGroups,\n    ),\n\n    // Guardian Set\n    guardianSet: networkData.guardianSet,\n\n    // Render Redesign views\n    useRedesign: customConfig?.useRedesign,\n  };\n}\n\n// Running buildConfig with no argument generates the default configuration\nconst config = buildConfig();\nexport default config;\n\n// TODO SDKV2: REMOVE\nexport function getWormholeContext(\n  network: Network,\n  sdkConfig: WormholeConfig,\n  rpcs: ChainResourceMap,\n): WormholeContext {\n  const wh: WormholeContext = new WormholeContext(network, {\n    ...sdkConfig,\n    ...{ rpcs },\n  });\n\n  return wh;\n}\n\nexport function getDefaultWormholeContext(network: Network): WormholeContext {\n  const sdkConfig = WormholeContext.getConfig(network);\n  const networkData = { mainnet: MAINNET, devnet: DEVNET, testnet: TESTNET }[\n    network\n  ]!;\n\n  const rpcs = Object.assign({}, sdkConfig.rpcs, networkData.rpcs);\n\n  return getWormholeContext(network, sdkConfig, rpcs);\n}\n\nexport async function getWormholeContextV2(): Promise&lt;WormholeV2&lt;NetworkV2&gt;&gt; {\n  if (config.v2Wormhole) return config.v2Wormhole;\n  config.v2Wormhole = await newWormholeContextV2();\n  return config.v2Wormhole;\n}\n\nexport async function newWormholeContextV2(): Promise&lt;WormholeV2&lt;NetworkV2&gt;&gt; {\n  const v2Config: WormholeConfigOverridesV2&lt;NetworkV2&gt; = { chains: {} };\n\n  for (const key in config.chains) {\n    const chainV1 = key as ChainName;\n    const chainConfigV1 = config.chains[chainV1]!;\n\n    const chainContextV1 = chainConfigV1.context;\n\n    const chainV2 = config.sdkConverter.toChainV2(\n      chainV1 as ChainName,\n    ) as ChainV2;\n\n    const rpc = config.rpcs[chainV1];\n    const tokenMap: ChainTokensV2 = {};\n\n    for (const token of config.tokensArr) {\n      const nativeChainV2 = config.sdkConverter.toChainV2(token.nativeChain);\n\n      const tokenV2: Partial&lt;TokenV2&gt; = {\n        key: token.key,\n        chain: chainV2,\n        symbol: token.symbol,\n      };\n\n      if (nativeChainV2 == chainV2) {\n        const decimals =\n          token.decimals[chainContextV1] ?? token.decimals.default;\n        if (!decimals) {\n          continue;\n        } else {\n          tokenV2.decimals = decimals;\n        }\n        const address = config.sdkConverter.getNativeTokenAddressV2(token);\n        if (!address) throw new Error('Token must have address');\n        tokenV2.address = address;\n      } else {\n        tokenV2.original = nativeChainV2;\n        if (token.foreignAssets) {\n          const fa = token.foreignAssets[chainV1]!;\n\n          if (!fa) {\n            continue;\n          } else {\n            tokenV2.address = fa.address;\n            tokenV2.decimals = fa.decimals;\n          }\n        } else {\n          continue;\n        }\n      }\n\n      tokenMap[token.key] = tokenV2 as TokenV2;\n    }\n\n    v2Config.chains![chainV2] = { rpc, tokenMap };\n  }\n\n  return await getWormholeV2(\n    config.v2Network,\n    [evm, solana, aptos, cosmwasm, sui, algorand],\n    v2Config,\n  );\n}\n\n// setConfig can be called afterwards to override the default config with integrator-provided config\n\nexport function setConfig(customConfig?: WormholeConnectConfig) {\n  const newConfig: InternalConfig&lt;NetworkV2&gt; = buildConfig(customConfig);\n\n  // We overwrite keys in the existing object so the references to the config\n  // imported elsewhere point to the new values\n  for (const key in newConfig) {\n    /* @ts-ignore */\n    config[key] = newConfig[key];\n  }\n}\n\n// TODO: add config validation step to buildConfig\n//validateConfigs();\n</code></pre>"},{"location":"build/applications/connect/configuration/#custom-networks-and-rpc-endpoints","title":"Custom Networks and RPC Endpoints","text":"<p>Specify supported networks, tokens, and custom RPC endpoints. Your users may encounter rate limits using public RPC endpoints if you don't provide your own.</p> <pre><code>import WormholeConnect, {\n  WormholeConnectConfig,\n} from '@wormhole-foundation/wormhole-connect';\n\nconst config: WormholeConnectConfig = {\n  env: 'mainnet',\n  networks: ['ethereum', 'polygon', 'solana'],\n  tokens: ['ETH', 'WETH', 'MATIC', 'WMATIC'],\n  rpcs: {\n    ethereum: 'https://rpc.ankr.com/eth',\n    solana: 'https://rpc.ankr.com/solana',\n  },\n};\n\nfunction App() {\n  return &lt;WormholeConnect config={config} /&gt;;\n}\n</code></pre>"},{"location":"build/applications/connect/configuration/#fully-customized-theme","title":"Fully Customized Theme","text":"<p>Wormhole Connect offers a high level of customizability that suits and integrates with your application's design, including various options for buttons, backgrounds, popovers, fonts, and more. The following example demonstrates a variety of appearance customizations. Remember, if you prefer a visual to aid in designing your widget, you can use the no code style interface.</p> <pre><code>import WormholeConnect, {\n  WormholeConnectTheme,\n} from '@wormhole-foundation/wormhole-connect';\nimport red from '@mui/material/colors/red';\nimport lightblue from '@mui/material/colors/lightBlue';\nimport grey from '@mui/material/colors/grey';\nimport green from '@mui/material/colors/green';\nimport orange from '@mui/material/colors/orange';\n\nconst customTheme: WormholeConnectTheme = {\n  mode: 'dark',\n  primary: grey,\n  secondary: grey,\n  divider: 'rgba(255, 255, 255, 0.2)',\n  background: {\n    default: '#232323',\n  },\n  text: {\n    primary: '#ffffff',\n    secondary: grey[500],\n  },\n  error: red,\n  info: lightblue,\n  success: green,\n  warning: orange,\n  button: {\n    primary: 'rgba(255, 255, 255, 0.2)',\n    primaryText: '#ffffff',\n    disabled: 'rgba(255, 255, 255, 0.1)',\n    disabledText: 'rgba(255, 255, 255, 0.4)',\n    action: orange[300],\n    actionText: '#000000',\n    hover: 'rgba(255, 255, 255, 0.7)',\n  },\n  options: {\n    hover: '#474747',\n    select: '#5b5b5b',\n  },\n  card: {\n    background: '#333333',\n    secondary: '#474747',\n    elevation: 'none',\n  },\n  popover: {\n    background: '#1b2033',\n    secondary: 'rgba(255, 255, 255, 0.5)',\n    elevation: 'none',\n  },\n  modal: {\n    background: '#474747',\n  },\n  font: {\n    primary: 'Impact',\n    header: 'Impact',\n  }\n};\n\nexport default function App() {\n  return &lt;WormholeConnect theme={customTheme} /&gt;;\n}\n</code></pre>"},{"location":"build/applications/connect/configuration/#environment","title":"Environment","text":"<p>You can configure Connect to be used in TestNet environments, too. You can toggle between MainNet and TestNet environments by defining the <code>WormholeConnectConfig</code> as follows:</p> MainNetTestNet <pre><code>const config: WormholeConnectConfig = {\n  \"env\": \"mainnet\"\n}\n</code></pre> <pre><code>const config: WormholeConnectConfig = {\n  \"env\": \"testnet\"\n}\n</code></pre>"},{"location":"build/applications/connect/configuration/#custom-rpc-endpoint","title":"Custom RPC Endpoint","text":"<p>You can define a custom RPC provider for your Connect widget to use. This can be especially helpful if you'd like to replace public endpoints with dedicated or private endpoints.</p> <pre><code>const config: WormholeConnectConfig = {\n  \"rpcs\": {\n    \"solana\": \"https://rpc.ankr.com/solana/ee827255553bb0fa9e0aaeab27e988707e60ea06ae36be0658b778072e94979e\"\n  }\n}\n</code></pre>"},{"location":"build/applications/connect/configuration/#arbitrary-token","title":"Arbitrary Token","text":"<p>The following section shows how to add an arbitrary token to your deployment of Connect. </p> <p>Note</p> <p>You will need to register your token with the Token Bridge to get the contract addresses necessary for it to work with Connect.</p> <p>This example configuration limits Connect to the Solana and Ethereum networks and a handful of tokens, including\u00a0<code>BSKT</code>, which isn't built in by default and provided under the\u00a0<code>tokensConfig</code>\u00a0key.</p> <p>See src/config/types.ts for the type definition of <code>TokensConfig</code>.</p> <pre><code>const config: WormholeConnectConfig = {\n    \"networks\":[\n        \"solana\",\n        \"ethereum\"\n    ],\n    \"tokens\":[\n        \"ETH\",\n        \"WETH\",\n        \"MATIC\",\n        \"WMATIC\",\n        \"BSKT\"\n    ],\n    \"tokensConfig\":{\n        \"BSKT\":{\n            \"key\":\"BSKT\",\n            \"symbol\":\"BSKT\",\n            \"nativeChain\":\"solana\",\n            \"tokenId\":{\n                \"chain\":\"solana\",\n                \"address\":\"6gnCPhXtLnUD76HjQuSYPENLSZdG8RvDB1pTLM5aLSJA\"\n            },\n            \"coinGeckoId\":\"basket\",\n            \"icon\":\"https://assets.coingecko.com/coins/images/34661/standard/BSKT_Logo.png?1705636891\",\n            \"color\":\"#2894EE\",\n            \"decimals\":{\n                \"default\":5\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"build/applications/connect/configuration/#more-configuration-options","title":"More Configuration Options","text":""},{"location":"build/applications/connect/configuration/#whitelisting-tokens","title":"Whitelisting Tokens","text":"<p>By default, Connect will offer its complete built-in list of assets, but you can restrict the displayed assets by defining a subset of tokens under <code>tokens</code>. The default full list is as follows:</p> MainNet TestNet ETH ETH, ETHsepolia WETH WETH, WETHsepolia USDCeth USDCeth WBTC - USDT - DAI - BUSD - MATIC MATIC WMATIC WMATIC USDCpolygon - BNB BNB WBNB WBNB USDCbnb - AVAX AVAX WAVAX WAVAX USDCavax USDCavax FTM FTM WFTM WFTM CELO CELO GLMR GLMR WGLMR WGLMR SOL WSOL PYTH - SUI SUI USDCsol - APT APT ETHarbitrum ETHarbitrum, ETHarbitrum_sepolia WETHarbitrum WETHarbitrum, WETHarbitrum_sepolia USDCarbitrum USDCarbitrum ETHoptimism ETHoptimism, ETHoptimism_sepolia WETHoptimism WETHoptimism, WETHoptimism_sepolia USDCoptimism USDCoptimism ETHbase ETHbase, ETHbase_sepolia WETHbase WETHbase, WETHbase_sepolia tBTC tBTC tBTCpolygon tBTCpolygon tBTCoptimism tBTCoptimism tBTCarbitrum tBTCarbitrum tBTCbase tBTCbase tBTCsol tBTCsol WETHpolygon - WETHbsc - wstETH wstETH wstETHarbitrum - wstETHoptimism - wstETHpolygon - wstETHbase -"},{"location":"build/applications/connect/configuration/#routes","title":"Routes","text":"<p>By default, Connect will offer its complete built-in list of routes, but you can restrict the possible route assets by defining a subset under <code>routes.</code> By default, Connect will offer its complete built-in list:</p> Mainnet TestNet bridge bridge relay relay cctpManual cctpManual cctpRelay cctpRelay nttManual nttManual nttRelay nttRelay ethBridge - wstETHBridge - usdtBridge - cosmosGateway cosmosGateway tBTC tBTC"},{"location":"build/applications/connect/configuration/#wallet-connect-project-id","title":"Wallet Connect Project ID","text":"<p>If you would like to offer WalletConnect as a supported wallet option, you'll need to obtain a project ID on the WalletConnect cloud dashboard.</p>"},{"location":"build/applications/connect/configuration/#toggle-hamburger-menu","title":"Toggle Hamburger Menu","text":"<p>By setting the <code>showHamburgerMenu</code> option to false, you can deactivate the hamburger menu, causing the links to be positioned at the bottom.</p>"},{"location":"build/applications/connect/configuration/#add-extra-menu-entry","title":"Add Extra Menu Entry","text":"<p>By setting the <code>showHamburgerMenu</code> option to <code>false,</code> you can add extra links. The following properties are accessed through the <code>menu[]</code> property (e.g., <code>menu[].label</code>):</p> Property Description <code>label</code> Link name to show up <code>href</code> Target URL or URN <code>target</code> Anchor standard target, by default <code>_blank</code> <code>order</code> Order where the new item should be injected"},{"location":"build/applications/connect/configuration/#sample-configuration","title":"Sample Configuration","text":"<pre><code>{\n    \"showHamburgerMenu\":false,\n    \"menu\":[\n        {\n            \"label\":\"Advance Tools\",\n            \"href\":\"https://portalbridge.com\",\n            \"target\":\"_self\",\n            \"order\":1\n        }\n    ]\n}\n</code></pre>"},{"location":"build/applications/connect/configuration/#coingecko-api-key","title":"CoinGecko API Key","text":"<p>The CoinGecko API can be used to fetch token price data. If you have a CoinGecko API Plan, you can include the API key in the configuration. Remember to always take steps to protect your sensitive API keys, such as defining them in <code>.env</code> files and including such files in your <code>.gitignore</code>.</p>"},{"location":"build/applications/connect/configuration/#more-networks","title":"More Networks","text":"<p>Specify a set of extra networks to be displayed on the network selection modal, each linking to a different page, dApp, or mobile app the user will be redirected to. The following properties are accessed through the <code>moreNetworks</code> property (e.g., <code>moreNetworks.href</code>):</p> Property Description <code>href</code> Required. Default value for missing network hrefs <code>target</code> Default value for missing network link targets. Defaults to <code>_self</code> <code>description</code> Brief description that should be displayed as a tooltip when the user hovers over a more network icon. Used as default for missing network descriptions <code>networks[].icon</code> Required. URL data encoded icon to display <code>networks[].href</code> Network href to redirect to. If present, the values <code>sourceChain</code> and <code>targetChain</code> are replaced with the currently selected chains before redirecting <code>networks[].label</code> Required. Display text <code>networks[].name</code> Unique network key. Defaults to a snake_case version of the label <code>networks[].description</code> Description value. Defaults to <code>moreNetworks.description</code> <code>networks[].target</code> href target value. Defaults to <code>moreNetworks.target</code> <code>networks[].showOpenInNewIcon</code> Disable top right open in new icon. Defaults to true if target is <code>_blank</code> or false if target is <code>_self</code> View full configuration <pre><code>{\n    ...\n    \"moreNetworks\": {\n        \"href\": \"https://example.com\",\n        \"target\": \"_blank\",\n        \"description\": \"brief description that should be displayed as tooltip when the user hovers over a more network icon\",\n        \"networks\": [\n            {\n                \"icon\": \"https://assets.coingecko.com/coins/images/34661/standard/BSKT_Logo.png?1705636891\",\n                \"name\": \"more\",\n                \"label\": \"More networks\",\n                \"href\": \"https://portalbridge.com/#/transfer\",\n                \"showOpenInNewIcon\": false\n            }\n        ]\n    }\n    ...\n}\n</code></pre>"},{"location":"build/applications/connect/configuration/#more-tokens","title":"More Tokens","text":"<p>Show a particular entry on the select tokens modal, redirecting the user to a different page, dApp, or mobile app. The following properties are accessed through the <code>moreTokens</code> property (e.g., <code>moreTokens.label</code>):</p> Property Description <code>label</code> Required. Display text <code>href</code> Required. URL to redirect to. If present, the values <code>sourceChain</code> and <code>targetChain</code> are replaced with the currently selected chains before redirecting <code>target</code> href target. Defaults to <code>_self</code>"},{"location":"build/applications/connect/configuration/#explorer","title":"Explorer","text":"<p>Enable the explorer button to allow users to search for their transactions on a given explorer, filtering by their wallet address. The following properties are accessed through the <code>explorer</code> property (e.g., <code>explorer.label</code>):</p> Property Description <code>label</code> Display text. Defaults to <code>Transactions</code> <code>href</code> Required. URL of the explorer, for instance https://wormholescan.io/. If present, the value <code>address</code> is replaced with the connected wallet address <code>target</code> <code>href</code> target. Defaults to <code>_blank</code>"},{"location":"build/applications/connect/features/","title":"Features","text":""},{"location":"build/applications/connect/features/#feature-support-matrix","title":"Feature Support Matrix","text":"<p>Scroll down for details about each column.</p> Network Token Bridge Token Bridge Relayer Circle CCTP ETH Bridge Gas Drop Off Solana \u2705 \u2705 \u2705 \u274c \u2705 Ethereum \u2705 \u2705 \u2705 \u2705 \u2705 BSC \u2705 \u2705 \u274c \u2705 \u2705 Polygon \u2705 \u2705 \u2705 \u2705 \u2705 Avalanche \u2705 \u2705 \u2705 \u2705 \u2705 Fantom \u2705 \u2705 \u274c \u274c \u2705 Klaytn \u2705 \u274c \u274c \u274c \u274c Celo \u2705 \u2705 \u274c \u274c \u2705 Moonbeam \u2705 \u2705 \u274c \u274c \u2705 Injective \u2705 \u274c \u274c \u274c \u274c Sui \u2705 \u2705 \u274c \u274c \u2705 Aptos \u2705 \u274c \u274c \u274c \u274c Arbitrum \u2705 \u2705 \u2705 \u2705 \u2705 Optimism \u2705 \u2705 \u2705 \u2705 \u2705 Base \u2705 \u2705 \u2705 \u2705 \u2705 Sei \u2705 \u274c \u274c \u274c \u274c Scroll \u2705 \u274c \u274c \u274c \u274c Blast \u2705 \u274c \u274c \u274c \u274c X Layer \u2705 \u274c \u274c \u274c \u274c Osmosis \u2705 (Gateway) \u2705 (IBC) \u274c \u274c \u274c CosmosHub \u2705 (Gateway) \u2705 (IBC) \u274c \u274c \u274c Evmos \u2705 (Gateway) \u2705 (IBC) \u274c \u274c \u274c Kujira \u2705 (Gateway) \u2705 (IBC) \u274c \u274c \u274c"},{"location":"build/applications/connect/features/#feature-explanation","title":"Feature Explanation","text":""},{"location":"build/applications/connect/features/#token-bridge","title":"Token Bridge","text":"<p>Wormhole is best known for its Token Bridge transfer method. It locks assets on the source chain and mints Wormhole-wrapped \"IOU\" tokens on the destination chain. To transfer the assets back, the Wormhole-wrapped tokens are burned, unlocking the tokens on their original chain.</p> <p>This route appears if both of the following conditions are satisfied:</p> <ul> <li>Both the origin and destination chains support Token Bridge </li> <li>No non-Token Bridge routes are available for the selected token</li> </ul>"},{"location":"build/applications/connect/features/#token-bridge-relayer","title":"Token Bridge Relayer","text":"<p>On the routes page, this is referred to as the automatic route in the Token Bridge section.</p> <p>Trustless relayers can execute the second transaction on behalf of the user, so the user only needs to perform one transaction on the origin chain to have the tokens delivered to the destination automatically\u2014for a small fee.</p> <p>This route appears if all of the following conditions are satisfied:</p> <ul> <li>Both the origin and destination chains support Token Bridge</li> <li>Both the origin and destination chains support Token Bridge relayer</li> <li>No non-Token Bridge routes are available for the selected token</li> <li>The relayer supports the selected token on the origin chain</li> </ul>"},{"location":"build/applications/connect/features/#circle-cctp","title":"Circle CCTP","text":"<p>Circle, the issuer of USDC, provides a native way for native USDC to be transferred between CCTP-enabled chains.</p> <p>This route appears if all of the following conditions are satisfied:</p> <ul> <li>Both the origin and destination chains support Circle CCTP</li> <li>The selected token is native Circle-issued USDC</li> </ul>"},{"location":"build/applications/connect/features/#eth-bridge","title":"ETH Bridge","text":"<p>Powered by Uniswap liquidity pools, this route can transfer native ETH or wstETH between certain EVMs without going through the native bridges.</p> <p>This route appears if all of the following conditions are satisfied:</p> <ul> <li>Both the origin and destination chains support the ETH Bridge</li> <li>The selected token is native ETH, wstETH, or canonical wETH</li> </ul>"},{"location":"build/applications/connect/features/#gas-drop-off","title":"Gas Drop Off","text":"<p>A relayer can drop off some gas tokens on the destination chain by swapping some of the assets transferred to the native gas token. This is useful if the user wishes to transfer assets to a chain where they don't already have gas. This way, they don't need to onboard into the ecosystem from a centralized exchange.</p> <p>This route appears if all of the following conditions are satisfied:</p> <ul> <li>Both the origin and destination chains support gas drop off</li> <li>An automatic route is selected</li> <li>The relayer accepts the selected token to swap into the gas token</li> </ul>"},{"location":"build/applications/connect/overview/","title":"Wormhole Connect","text":""},{"location":"build/applications/connect/overview/#introduction","title":"Introduction","text":"<p>Wormhole Connect is a React widget that lets developers offer an easy-to-use interface to facilitate cross-chain asset transfers via Wormhole directly in a web application. Check out the Wormhole Connect GitHub repository.</p> <p>The Wormhole TypeScript SDK allows you to implement the same functionality as the Connect widget but in your own UI. Check out the docs for more information on using the SDK instead of Connect.</p>"},{"location":"build/applications/connect/overview/#features","title":"Features","text":"<p>Wormhole Connect is easy to customize to suit your application's needs. You can specify technical details like supported assets and custom RPCs or forgo customization and have a full-featured widget. The widget UI is highly customizable, with extensive styling options available, including a user-friendly no code styling interface for those who prefer a more visual approach to design. The features of Wormhole Connect include:</p> <ul> <li>Multiple ways to bridge assets (routes)</li> <li>Extensive ways to style the UI (including the no code styling interface)</li> <li>Ways to configure what feature set to offer</li> <li>Ability to configure any token to bridge via Wormhole</li> <li>Ability to drop off some gas at the destination</li> </ul> <p>For more details about the features of Wormhole Connect and a breakdown of supported features by chain, be sure to check the features page.</p>"},{"location":"build/applications/connect/overview/#production-dapp-examples","title":"Production DApp Examples","text":"<p>Wormhole Connect is deployed live in several production apps. Here are a few:</p> <ul> <li>Portal Bridge</li> <li>Jupiter</li> <li>Pancake Swap</li> </ul>"},{"location":"build/applications/connect/overview/#integrate-connect","title":"Integrate Connect","text":""},{"location":"build/applications/connect/overview/#import-directly-into-a-react-app","title":"Import Directly into a React App","text":"<p>First, install the Wormhole Connect npm package. You can read more about the package by clicking on the following button:  </p> <pre><code>npm i @wormhole-foundation/wormhole-connect\n</code></pre> <p>Now you can import the React component:</p> <pre><code>import WormholeConnect from '@wormhole-foundation/wormhole-connect';\n\nfunction App() {\n  return (\n    &lt;WormholeConnect /&gt;\n  );\n}\n</code></pre>"},{"location":"build/applications/connect/overview/#use-hosted-version-via-cdn","title":"Use Hosted Version via CDN","text":"<p>If you're not using React, you can still embed Connect on your website by using the hosted version. The sample code below uses the popular and free <code>unpkg.com</code> CDN from which your app will load the widget.</p> <p>Simply copy and paste the following into your HTML body, and replace the <code>INSERT_WORMHOLE_CONNECT_VERSION</code> in the links with the most recent production version of Wormhole Connect. You can check what the most recent version is on NPM.</p> <pre><code>&lt;!-- Mounting point. Include in &lt;body&gt; --&gt;\n&lt;div id=\"wormhole-connect\"&gt;&lt;/div&gt;\n\n&lt;!-- Dependencies --&gt;\n&lt;script\n  type=\"module\"\n  src=\"https://www.unpkg.com/@wormhole-foundation/wormhole-connect@INSERT_WORMHOLE_CONNECT_VERSION/dist/main.js\"\n  defer\n&gt;&lt;/script&gt;\n&lt;link\n  rel=\"https://www.unpkg.com/@wormhole-foundation/wormhole-connect@INSERT_WORMHOLE_CONNECT_VERSION/dist/main.css\"\n/&gt;\n</code></pre> <p>For example, for 0.3.13:</p> <pre><code>&lt;!-- Mounting point. Include in &lt;body&gt; --&gt;\n&lt;div id=\"wormhole-connect\"&gt;&lt;/div&gt;\n\n&lt;!-- Dependencies --&gt;\n&lt;script\n  type=\"module\"\n  src=\"https://www.unpkg.com/@wormhole-foundation/wormhole-connect@0.3.13/dist/main.js\"\n  defer\n&gt;&lt;/script&gt;\n&lt;link\n  rel=\"https://www.unpkg.com/@wormhole-foundation/wormhole-connect@0.3.13/dist/main.css\"\n/&gt;\n</code></pre> <p>Note</p> <p>It is important to periodically update your Wormhole Connect instance to the latest version, as there are frequent functionality and security releases.</p>"},{"location":"build/applications/connect/overview/#configuration","title":"Configuration","text":"<p>This is just an overview of what's possible. Check the Configuration docs for details about all the configuration options.</p> <p>The default configuration of Wormhole Connect may not be exactly what you're looking for. You may want to:</p> <ul> <li>Use custom styles </li> <li>Restrict the chains that you allow in your app</li> <li>Add support for your project's token, and eliminate tokens you don't want to reduce noise</li> <li>Configuring custom RPC URLs (This is highly recommended as default public RPCs are heavily throttled)</li> <li>Restrict the routes that are available</li> </ul> <p>For additional information on the preceding options, check the configuration options and customize your widget however you like.</p>"},{"location":"build/applications/connect/routes/","title":"Routes","text":""},{"location":"build/applications/connect/routes/#routes-overview","title":"Routes Overview","text":"<p>This page explains the concept of routes in Wormhole Connect. To configure routes for your widget, check the Wormhole Connect Configuration.</p> <p>Routes are methods by which the widget will transfer the assets. Wormhole Connect supports Token Bridge transfers for any arbitrary token, and for specific tokens, it also supports more advanced transfer methods that provide superior UX.</p> <p>When you select the source chain, source token, and destination chain, Wormhole Connect will display the best routes available for that particular combination. In practice, if routes other than the Token Bridge are available, only those will be displayed. Check the feature matrix to see under which exact conditions the routes appear.</p>"},{"location":"build/applications/connect/routes/#token-bridge-routes","title":"Token Bridge Routes","text":"<p>The Token Bridge is Wormhole's best-known transfer method. It locks assets on the source chain and mints Wormhole-wrapped \"IOU\" tokens on the destination chain. To transfer the assets back, the Wormhole-wrapped tokens are burned, unlocking the tokens on their original chain.</p>"},{"location":"build/applications/connect/routes/#manual-route","title":"Manual Route","text":"<p>The manual route transfer method requires two transactions: one on the origin chain to lock the tokens (or burn the Wormhole-wrapped tokens) and one on the destination chain to mint the Wormhole-wrapped tokens (or unlock the original tokens). To offer this option, enable the <code>bridge</code> route in the configuration.</p>"},{"location":"build/applications/connect/routes/#automatic-route","title":"Automatic Route","text":"<p>Trustless relayers can execute the second transaction on the user's behalf, so the user only needs to perform one transaction on the origin chain to have the tokens delivered to the destination automatically - for a small fee. Wormhole Connect automatically detects whether the relayer supports a token and will display the option if the <code>relay</code> route is enabled in the configuration.</p>"},{"location":"build/applications/connect/routes/#cctp-routes-usdc","title":"CCTP Routes (USDC)","text":"<p>Circle, the issuer of USDC, provides a native way for native USDC to be transferred between CCTP-enabled chains. Wormhole Connect can facilitate such transfers.</p> <p>Note that if native USDC is transferred from the CCTP-enabled chains to any other outside of this list, the transfer will be routed through the Token Bridge, and the resulting asset will be a Wormhole-wrapped token instead of native USDC.</p>"},{"location":"build/applications/connect/routes/#manual-route-cctp","title":"Manual Route","text":"<p>This transfer method requires two transactions: one on the origin chain to burn the USDC and one on the destination chain to mint the USDC. The manual CCTP route relies on CCTP only and doesn't use Wormhole messaging in the background. Enable the <code>cctpManual</code> route in the configuration to offer this option.</p>"},{"location":"build/applications/connect/routes/#automatic-route-cctp","title":"Automatic Route","text":"<p>Trustless relayers can execute the second transaction on the user's behalf. Therefore, the user only needs to perform one transaction on the origin chain to have the tokens delivered to the destination automatically\u2014for a small fee. To offer this option, enable the <code>cctpRelay</code> route in the configuration.</p>"},{"location":"build/applications/connect/routes/#native-token-transfers-ntt-routes","title":"Native Token Transfers (NTT) Routes","text":"<p>Wormhole's Native Token Transfer (NTT) framework enables token issuers to retain full ownership of their tokens across any number of chains, unlike the Token Bridge. The token issuer must deploy NTT contracts, and Wormhole Connect needs to be configured with the appropriate <code>nttGroups</code> before such tokens are recognized as transferrable via NTT. Refer to the documentation in the NTT repository for more information about the contracts needed and the framework in general.</p>"},{"location":"build/applications/connect/routes/#manual-route-ntt","title":"Manual Route","text":"<p>This transfer method requires two transactions: one on the origin chain to burn or lock the tokens and one on the destination chain to mint them. To offer this option, enable the <code>nttManual</code> route in the configuration.</p>"},{"location":"build/applications/connect/routes/#automatic-route-ntt","title":"Automatic Route","text":"<p>Trustless relayers can execute the second transaction on the user's behalf, so the user only needs to perform one transaction on the origin chain to have the tokens delivered to the destination automatically\u2014for a small fee. Wormhole Connect automatically detects whether the relayer supports a token and will display the option if the <code>nttRelay</code> route is enabled in the configuration.</p>"},{"location":"build/applications/connect/routes/#eth-bridge-route-for-native-eth-and-wsteth","title":"ETH Bridge Route for Native ETH and wstETH","text":"<p>Powered by Uniswap liquidity pools, this route can transfer native ETH or wstETH between certain EVMs without going through the native bridges. For example, you can transfer native ETH from Arbitrum to Optimism and end up with Optimism ETH all in one go. Supported chains are Ethereum, Arbitrum, Optimism, Base, Polygon (canonical wETH), BSC (canonical wETH), and Avalanche (canonical wETH).</p>"},{"location":"build/applications/connect/routes/#automatic-route-eth","title":"Automatic Route","text":"<p>Only the relayed route is available due to the complexity of the transaction that needs to be executed at the destination. To offer this option, enable the <code>ethBridge</code> and/or <code>wstETHBridge</code> route in the configuration to provide this option.</p>"},{"location":"build/applications/connect/routes/#usdt-bridge-route","title":"USDT Bridge Route","text":"<p>Operating on the same technology as the ETH Bridge, this route can transfer USDT between certain EVMs without going through the native bridges. The resulting token will be the canonical USDT token on the destination instead of the Wormhole-wrapped variant. Supported chains are Ethereum, Polygon, Avalanche, Arbitrum, Optimism, BSC, and Base.</p>"},{"location":"build/applications/connect/routes/#automatic-route-usdt","title":"Automatic Route","text":"<p>Only the relayed route is available due to the complexity of the transaction that needs to be executed on the destination. Enable the <code>usdtBridge</code> route in the configuration to offer this option.</p>"},{"location":"build/applications/connect/routes/#cosmos-gateway-route","title":"Cosmos Gateway Route","text":"<p>Wormhole Gateway is a Cosmos-SDK chain that bridges non-native assets into the Cosmos ecosystem and serves as a source for unified liquidity across Cosmos chains. This transfer method is offered when the destination is an IBC-compatible Cosmos chain (e.g., Osmosis, CosmosHub, Evmos, Kujira, or Injective).</p>"},{"location":"build/applications/connect/routes/#automatic-route-cosmos","title":"Automatic Route","text":"<p>The Wormhole Guardian Network automatically delivers messages to Wormhole Gateway if the tokens are destined for IBC-compatible Cosmos chains, requiring no input or extra \"Gateway gas\" from the user. When the Wormhole-wrapped tokens are minted on Gateway, they are automatically transferred to their intended destination via a network of IBC relayers. Enable the <code>cosmosGateway</code> route in the configuration to offer this option.</p>"},{"location":"build/applications/connect/routes/#tbtc-route","title":"tBTC Route","text":"<p>You can bridge Threshold's Bitcoin via this hybrid solution that combines the Token Bridge and Threshold's contracts. Native tBTC is first locked in the Wormhole Token Bridge, transferred to the destination in the form of Wormhole-wrapped tBTC, which is then immediately locked in Threshold's contract that mints native tBTC for it. The net result is that the user ends up with native tBTC on chains where this Threshold contract is deployed (e.g., Solana, Polygon, Arbitrum, Optimism, or Base).</p> <p>Note that if native tBTC is transferred out of these chains to any other outside of this list, the transfer will be routed through the Token Bridge, and the resulting asset will be a Wormhole-wrapped token instead of native tBTC.</p>"},{"location":"build/applications/connect/routes/#manual-route-tbtc","title":"Manual Route","text":"<p>This transfer method requires two transactions: one on the origin chain to burn or lock the tokens and one on the destination chain to mint them. To provide this option, enable the <code>tbtc</code> route in the configuration.</p>"},{"location":"build/applications/queries/","title":"Queries","text":""},{"location":"build/applications/queries/#get-started","title":"Get Started","text":"<p>Wormhole Queries offers on-demand access to Guardian-attested on-chain data via a simple REST endpoint to initiate an off-chain request via a proxy.</p> <ul> <li> <p> Overview</p> <p>Explore Wormhole Queries, offering real-time access to verified blockchain data via a REST API endpoint, enabling secure cross-chain interactions and verifications.</p> <p> Learn about Queries</p> </li> <li> <p> Use Queries</p> <p>Explore a simple demo of interacting with Wormhole Queries using an <code>eth_call</code> request to query the supply of wETH on Ethereum using a Wormhole query.</p> <p> Get hands-on</p> </li> <li> <p> Query FAQs</p> <p>Explore frequently asked questions about Wormhole Queries.</p> <p> Check out the FAQs</p> </li> </ul>"},{"location":"build/applications/queries/faqs/","title":"FAQs about Queries","text":""},{"location":"build/applications/queries/faqs/#what-libraries-are-available-to-handle-queries","title":"What Libraries Are Available to Handle Queries?","text":"<ul> <li> <p>The Query TypeScript SDK can be used to create query requests, mock query responses for testing, and parse query responses. The SDK also includes utilities for posting query responses</p> </li> <li> <p>The Solidity <code>QueryResponse</code> abstract contract can be used to parse and verify query responses on EVM chains. See the Solana Stake Pool repository as an example use case</p> </li> <li> <p><code>QueryTest.sol</code> can be used for mocking query requests and responses in Forge tests</p> </li> <li> <p>The Go query package can also be used to create query requests and parse query responses</p> </li> </ul> <p>Note</p> <p>A Rust SDK for Solana is being actively investigated by the Wormhole contributors. See the Solana Queries Verification repository as a proof of concept.</p>"},{"location":"build/applications/queries/faqs/#are-there-any-query-examples","title":"Are There Any Query Examples?","text":"<p>Certainly. You can find a complete guide on the Use Queries page. Additionally, you can find full code examples in the following repositories:</p> <ul> <li>Basic Example Query Demo</li> <li>Solana Stake Pool Example Query</li> <li>Solana Program Derived Address (PDA) / Token Account Balance Example Query</li> <li>Solana Queries Verification Example</li> </ul>"},{"location":"build/applications/queries/faqs/#what-is-the-format-of-the-response-signature","title":"What Is the Format of the Response Signature?","text":"<p>The Guardian node calculates an ECDSA signature using <code>Sign</code> function of the crypto package where the digest hash is:</p> <p><code>keccak256(\"query_response_0000000000000000000|\"+keccak256(responseBytes))</code> </p> <p>See the Guardian Key Usage white paper for more background. Once this signature is created, the Guardian's index in the Guardian set is appended to the end.</p> <p>Note</p> <p>If you are used to <code>ecrecover</code> you will notice that the <code>v</code> byte is <code>0</code> or <code>1</code> as opposed to <code>27</code> or <code>28</code>. The <code>signaturesToEvmStruct</code> method in the Query TypeScript SDK accounts for this as well as structuring the signatures into an <code>IWormhole.SignatureStruct[]</code>.</p>"},{"location":"build/applications/queries/faqs/#can-anyone-run-a-query-proxy-server","title":"Can Anyone Run a Query Proxy Server?","text":"<p>Permissions for Query Proxy are managed by the Guardians. The Guardian nodes are configured to only listen to a set of allow-listed proxies. However, it is possible that this restriction may be lifted in the future and/or more proxies could be added.</p> <p>It is also important to note that the proxies don't impact the verifiability of the request or result, i.e., their role in the process is trustless.</p>"},{"location":"build/applications/queries/overview/","title":"Queries Overview","text":"<p>Wormhole Guardians, who run full nodes for various connected chains, facilitate a new cross-chain query service that allows for on-demand attested responses to queries, bypassing the inefficiencies of traditional transaction-based data retrieval. This method is faster and cost-effective, eliminating the need for gas payments and transaction finality wait times.</p> <p>Note</p> <p>Queries are currently in closed beta, though you can start developing today. Check out Use Queries and reach out to Join the beta.</p> <p>Wormhole Queries offers on-demand access to Guardian-attested on-chain data. The current implementation provides integrators with a simple REST endpoint to initiate an off-chain request via a proxy. The proxy then forwards the request to the Guardians and gathers a quorum of responses. The result returns the encoded response, including the request details and the Guardian signatures. The request validation performed by the query module includes a three step process that involves verifying the signature to ensure it has the correct prefix, confirming that the signer is authorized to execute query requests, and validating the legitimacy of all per-chain requests contained in the query. You can read more about Queries in the white paper.</p>"},{"location":"build/applications/queries/overview/#the-flow-of-a-query","title":"The Flow of a Query","text":"<p>The general overview of a query's flow is as follows: an off-chain process sends HTTPS query requests to a Query Proxy, which validates and forwards them to the Guardians; these Guardians independently validate, sign, and return the response, with the entire process typically taking less than a second.</p> <p></p> <p>The step-by-step flow of a query is as follows:</p> <ol> <li>An off-chain process initiates a query request via HTTPS to the query proxy (or Query Server) </li> <li>The query proxy validates the request and forwards it to the Guardians via a gossip network</li> <li>The Guardians independently validate the request, make the requisite RPC calls, verify the results, sign, and gossip a response back to the Query Proxy</li> <li>The Query Proxy aggregates the results and returns a response when it reaches a quorum of two-thirds or more of the current Guardian set - the exact quorum requirements as the core bridge</li> <li>The off-chain process can then submit these requests to an on-chain contract which should verify the signatures and validate the request before processing the result</li> </ol> <p>In this flow, the Query Proxy is a permissioned but trustless part of the protocol. In most cases, this entire process takes less than one second. If a request is invalid or cannot be processed by the Guardians, they will retry for up to one minute before timing out. Requests can be batched to have the Guardians make multiple calls to multiple networks. This can further reduce overhead for processing query responses on-chain. Up to 255 queries can be batched together, with certain types allowing for batching themselves.</p>"},{"location":"build/applications/queries/overview/#supported-query-types","title":"Supported Query Types","text":"<p>There are currently five supported types of queries. See the white paper for more details on each.</p>"},{"location":"build/applications/queries/overview/#eth-call","title":"eth_call","text":"<p>This query type is effectively an equivalent of eth_call against a block specified by number or hash.</p> <p>Calls are batched to allow specifying multiple calls (even to multiple contracts) against the same block. These calls are included in a single batch RPC call, simplifying on-chain verification. Up to 255 calls may be batched in an single <code>eth_call</code> query.</p> <p>The result contains the specified block number, hash, timestamp, and the call result.</p>"},{"location":"build/applications/queries/overview/#eth-call-by-timestamp","title":"eth_call By Timestamp","text":"<p>This query type is similar to <code>eth_call</code> but targets a timestamp instead of a specific <code>block_id</code>. This can be useful when forming requests based on uncorrelated data, such as requiring data from another chain based on the block timestamp of a given chain.</p> <p>The result also contains the target and block details with the following enforced conditions: <code>target_block.timestamp &lt;= target_time &lt; following_block.timestamp</code> and <code>following_block_num - 1 == target_block_num</code>.</p>"},{"location":"build/applications/queries/overview/#eth-call-with-finality","title":"eth_call With Finality","text":"<p>This query type is similar to <code>eth_call</code> but ensures that the specified block has reached the specified finality before returning the query results. The finality may be <code>finalized</code> or <code>safe.</code> Note that if a chain doesn't natively support the <code>safe</code> tag, this will be equivalent to <code>finalized.</code></p>"},{"location":"build/applications/queries/overview/#sol_account","title":"sol_account","text":"<p>This query is used to read data for one or more accounts on Solana, akin to <code>getMultipleAccounts</code>.</p>"},{"location":"build/applications/queries/overview/#sol_pda","title":"sol_pda","text":"<p>This query is used to read data for one or more Program Derived Addresses(PDA) on Solana, akin to calling <code>getMultipleAccounts</code> on the result of <code>PublicKey.findProgramAddressSync(seeds, programId).</code> This query is helpful for times when you want to more generally read accounts owned by a program and verify the derivation on another chain, like how associated token accounts are all derived from the Associated Token Account Program.</p>"},{"location":"build/applications/queries/overview/#supported-chains","title":"Supported Chains","text":"<p>The following table provides expected support based on testing. However, the success of any given query is based on the success of the underlying call on each Guardian\u2019s RPC node.</p> <p>For example, many chains have implementations forked from Geth, which keeps 128 blocks of state in memory by default (without running in archive mode). While this is good for about 25 minutes of history on Ethereum MainNet, it is only about three minutes on Optimism. While Guardian nodes can be expected to have access to recent state, there are currently no guarantees of how far back in history they have access to.</p>"},{"location":"build/applications/queries/overview/#mainnet","title":"MainNet","text":"Chain Wormhole Chain ID eth_call By Timestamp With Finality Expected History Ethereum 2 \u2705 \u2705 \u2705 128 blocks BSC 4 \u2705 \u2705 \u2705 128 blocks Polygon 5 \u2705 \u2705 \u2705 128 blocks Avalanche 6 \u2705 \u2705 \u2705 32 blocks Oasis Emerald 7 \u2705 \u2705 \u2705 archive Fantom 10 \u2705 \u2705 \u2705 16 blocks Karura 11 \u2705 \u2705 \u2705 archive Acala 12 \u2705 \u2705 \u2705 archive Klaytn 13 \u2705 \u2705 \u2705 128 blocks Celo 14 \u2705 \u2139\ufe0f hints required* \u2705 128 blocks Moonbeam 16 \u2705 \u2139\ufe0f hints required* \u2705 256 blocks Arbitrum One 23 \u2705 \u2705 \u2705 ~6742 blocks Optimism 24 \u2705 \u2705 \u274c 128 blocks Base 30 \u2705 \u2705 \u2705 archive <p>*<code>EthCallByTimestamp</code> arguments for <code>targetBlock</code> and <code>followingBlock</code> are currently required for requests to be successful on these chains.</p>"},{"location":"build/applications/queries/overview/#next-steps","title":"Next Steps","text":"<p>Remember that Wormhole Queries are currently in beta. You can register to join the beta to fully experiment with Wormhole Queries. </p> <p>Be sure to check out the FAQs and the Use Queries guide.</p> <p>You can also check out the following examples of applications that make use of Wormhole Queries: </p> <ul> <li>Basic demo</li> <li>Solana Stake Pool</li> <li>Solana Program Derived Address (PDA) / Token Account Balance</li> <li>Solana Queries Verification</li> </ul>"},{"location":"build/applications/queries/use-queries/","title":"Use Queries","text":"<p>You can visit the Example Queries Demo to view an interactive example of an application interacting with the Query Demo contract.</p> <p>This guide covers using a simple <code>eth_call</code> request to get the total supply of WETH on Ethereum.</p>"},{"location":"build/applications/queries/use-queries/#rpc-basics","title":"RPC Basics","text":"<p>Before digging into anything Queries-specific, this page will look at how to make an <code>eth_call</code> against a public Ethereum RPC. Suppose you'd like to query the WETH contract for its total supply; before making a request, you need some information about the contract you want to call, including:</p> <ul> <li>To - the contract to call. WETH is 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2</li> <li>Data - the method identifier and ABI-encoded parameters, which can be obtained as follows: <code>web3.eth.abi.encodeFunctionSignature(\"totalSupply()\")</code> which yields <code>0x18160ddd</code></li> <li>Block ID - the block number, hash, or tag. Tag options include <code>latest,</code> <code>safe,</code> or <code>finalized</code></li> </ul> <p>The prepared curl request is as follows:</p> eth_call JSON-RPC request<pre><code>curl https://ethereum.publicnode.com -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_call\",\"params\":[{\"to\":\"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\",\"data\":\"0x18160ddd\"},\"latest\"],\"id\":1}'\n</code></pre> <p>And the corresponding response is:</p> eth_call JSON-RPC reponse<pre><code>{\n  \"jsonrpc\":\"2.0\",\n  \"id\":1,\n  \"result\":\"0x000000000000000000000000000000000000000000029fd3d129b582d7949e71\"\n}\n</code></pre> <p>Converting the returned value of the executed call from hexidecimal results in the value <code>3172615244782286193073777</code>. You can compare your result to the Read Contract tab in Etherscan. Your result will be different as WETH is minted/burned over time.</p>"},{"location":"build/applications/queries/use-queries/#construct-a-query","title":"Construct a Query","text":"<p>You can use the Wormhole Query SDK to construct a query. You will also need an RPC endpoint from the provider of your choice. This example uses Axios for RPC requests. Ensure that you also have TypeScript installed. </p> <pre><code>npm i @wormhole-foundation/wormhole-query-sdk axios\n</code></pre> <p>In order to make an <code>EthCallQueryRequest</code>, you need a specific block number or hash as well as the call data to request.</p> <p>You can request the latest block from a public node using <code>eth_getBlockByNumber</code>.</p> <pre><code>const rpc = 'https://ethereum.publicnode.com';\n  const latestBlock: string = (\n    await axios.post(rpc, {\n      method: 'eth_getBlockByNumber',\n      params: ['latest', false],\n      id: 1,\n      jsonrpc: '2.0',\n    })\n  ).data?.result?.number;\n</code></pre> <p>Then construct the call data.</p> <pre><code>const callData: EthCallData = {\n  to: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2', // WETH\n  data: '0x18160ddd', // web3.eth.abi.encodeFunctionSignature(\"totalSupply()\")\n};\n</code></pre> <p>Finally, put it all together in a <code>QueryRequest</code>.</p> <pre><code>  // Form the query request\n  const request = new QueryRequest(\n    0, // Nonce\n    [\n      new PerChainQueryRequest(\n        2, // Ethereum Wormhole Chain ID\n        new EthCallQueryRequest(latestBlock, [callData])\n      ),\n    ]\n  );\n</code></pre> <p>This request consists of one <code>PerChainQueryRequest</code>, which is an <code>EthCallQueryRequest</code> to Ethereum. You can use <code>console.log</code> to print the JSON object and review the structure.</p> <pre><code>  console.log(JSON.stringify(request, undefined, 2));\n// {\n//   \"nonce\": 0,\n//   \"requests\": [\n//     {\n//       \"chainId\": 2,\n//       \"query\": {\n//         \"callData\": [\n//           {\n//             \"to\": \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\",\n//             \"data\": \"0x18160ddd\"\n//           }\n//         ],\n//         \"blockTag\": \"0x11e9068\"\n//       }\n//     }\n//   ],\n//   \"version\": 1\n// }\n</code></pre>"},{"location":"build/applications/queries/use-queries/#mock-a-query","title":"Mock a Query","text":"<p>For easier testing, the Query SDK provides a <code>QueryProxyMock</code> method. This method will perform the request and sign the result with the DevNet Guardian key. The <code>mock</code> call returns the same format as the Query Proxy.</p> <pre><code>  const mock = new QueryProxyMock({ 2: rpc });\n  const mockData = await mock.mock(request);\n  console.log(mockData);\n// {\n//   signatures: ['...'],\n//   bytes: '...'\n// }\n</code></pre> <p>This response is suited for on-chain use, but the SDK also includes a parser to make the results readable via the client.</p> <pre><code>  const mockQueryResponse = QueryResponse.from(mockData.bytes);\n  const mockQueryResult = (\n    mockQueryResponse.responses[0].response as EthCallQueryResponse\n  ).results[0];\n  console.log(\n    `Mock Query Result: ${mockQueryResult} (${BigInt(mockQueryResult)})`\n  );\n// Mock Query Result: 0x000000000000000000000000000000000000000000029fd09d4d81addb3ccfee (3172556167631284394053614)\n</code></pre> <p>Testing this all together might look like the following:</p> <pre><code>import {\n  EthCallData,\n  EthCallQueryRequest,\n  EthCallQueryResponse,\n  PerChainQueryRequest,\n  QueryProxyMock,\n  QueryRequest,\n  QueryResponse,\n} from '@wormhole-foundation/wormhole-query-sdk';\nimport axios from 'axios';\n\nconst rpc = 'https://ethereum.publicnode.com';\nconst callData: EthCallData = {\n  to: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2', // WETH\n  data: '0x18160ddd', // web3.eth.abi.encodeFunctionSignature(\"totalSupply()\")\n};\n\n(async () =&gt; {\n  const latestBlock: string = (\n    await axios.post(rpc, {\n      method: 'eth_getBlockByNumber',\n      params: ['latest', false],\n      id: 1,\n      jsonrpc: '2.0',\n    })\n  ).data?.result?.number;\n  if (!latestBlock) {\n    console.error(`\u274c Invalid block returned`);\n    return;\n  }\n  console.log('Latest Block:     ', latestBlock, `(${BigInt(latestBlock)})`);\n  const targetResponse = await axios.post(rpc, {\n    method: 'eth_call',\n    params: [callData, latestBlock],\n    id: 1,\n    jsonrpc: '2.0',\n  });\n  // console.log(finalizedResponse.data);\n  if (targetResponse.data.error) {\n    console.error(`\u274c ${targetResponse.data.error.message}`);\n  }\n  const targetResult = targetResponse.data?.result;\n  console.log('Target Result:    ', targetResult, `(${BigInt(targetResult)})`);\n  // Form the query request\n  const request = new QueryRequest(\n    0, // Nonce\n    [\n      new PerChainQueryRequest(\n        2, // Ethereum Wormhole Chain ID\n        new EthCallQueryRequest(latestBlock, [callData])\n      ),\n    ]\n  );\n  console.log(JSON.stringify(request, undefined, 2));\n  const mock = new QueryProxyMock({ 2: rpc });\n  const mockData = await mock.mock(request);\n  console.log(mockData);\n  const mockQueryResponse = QueryResponse.from(mockData.bytes);\n  const mockQueryResult = (\n    mockQueryResponse.responses[0].response as EthCallQueryResponse\n  ).results[0];\n  console.log(\n    `Mock Query Result: ${mockQueryResult} (${BigInt(mockQueryResult)})`\n  );\n})();\n</code></pre>"},{"location":"build/applications/queries/use-queries/#fork-testing","title":"Fork Testing","text":"<p>It is common to test against a local fork of MainNet with something like</p> <pre><code>anvil --fork-url https://ethereum.publicnode.com\n</code></pre> <p>In order for mock requests to verify against the MainNet Core Contract, you need to replace the current Guardian set with the single DevNet key used by the mock.</p> <p>Here's an example for Ethereum MainNet, where the <code>-a</code> parameter is the Core Contract address on that chain.</p> <pre><code>npx @wormhole-foundation/wormhole-cli evm hijack -a 0x98f3c9e6E3fAce36bAAd05FE09d375Ef1464288B -g 0xbeFA429d57cD18b7F8A4d91A2da9AB4AF05d0FBe\n</code></pre> <p>If you are using <code>EthCallWithFinality</code>, you will need to mine additional blocks (32 if using Anvil) after the latest transaction for it to become finalized. Anvil supports auto-mining with the <code>-b</code> flag if you want to test code that waits naturally for the chain to advance. For integration tests, you may want to simply <code>anvil_mine</code> with <code>0x20</code>.</p>"},{"location":"build/applications/queries/use-queries/#make-a-query-request","title":"Make a Query Request","text":"<p>The standardized means of making a <code>QueryRequest</code> with an API key is as follows:</p> <pre><code>const serialized = request.serialize();\nconst proxyResponse = (await axios.post)&lt;QueryProxyQueryResponse&gt;(\n  QUERY_URL,\n  {\n    bytes: Buffer.from(serialized).toString('hex'),\n  },\n  { headers: { 'X-API-Key': YOUR_API_KEY } }\n);\n</code></pre> <p>Remember to always take steps to protect your sensitive API keys, such as defining them in <code>.env</code> files and including such files in your <code>.gitignore</code>.</p> <p>A TestNet Query Proxy is available at <code>https://testnet.query.wormhole.com/v1/query</code></p> <p>A MainNet Query Proxy is available at <code>https://query.wormhole.com/v1/query</code></p>"},{"location":"build/applications/queries/use-queries/#verify-a-query-response-on-chain","title":"Verify a Query Response On-Chain","text":"<p>A <code>QueryResponse</code> abstract contract is provided to assist with verifying query responses. You can begin by installing the Wormhole Solidity SDK with the following command:</p> <pre><code>forge install wormhole-foundation/wormhole-solidity-sdk\n</code></pre> <p>Broadly, using a query response on-chain comes down to three main steps:</p> <ol> <li>Parse and verify the query response</li> <li>The <code>parseAndVerifyQueryResponse</code> handles verifying the Guardian signatures against the current Guardian set stored in the Core bridge contract</li> <li>Validate the request details. This may be different for every integrator depending on their use case, but generally checks the following:<ul> <li>Is the request against the expected chain?</li> <li>Is the request of the expected type? The <code>parseEthCall</code> helpers perform this check when parsing</li> <li>Is the resulting block number and time expected? Some consumers might require that a block number be higher than the last, or the block time be within the last 5 minutes. <code>validateBlockNum</code> and <code>validateBlockTime</code> can help with the checks</li> <li>Is the request for the expected contract and function signature? The <code>validateMultipleEthCallData</code> can help with non-parameter-dependent cases</li> <li>Is the result of the expected length for the expected result type?</li> </ul> </li> <li>Run <code>abi.decode</code> on the result </li> </ol> <p>See the QueryDemo contract for an example and read the docstrings of the preceding methods for detailed usage instructions.</p> View the complete <code>QueryDemo</code> <pre><code>// contracts/query/QueryDemo.sol\n// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.0;\n\nimport \"wormhole-solidity-sdk/libraries/BytesParsing.sol\";\nimport \"wormhole-solidity-sdk/interfaces/IWormhole.sol\";\nimport \"wormhole-solidity-sdk/QueryResponse.sol\";\n\nerror InvalidOwner();\n// @dev for the onlyOwner modifier\nerror InvalidCaller();\nerror InvalidCalldata();\nerror InvalidForeignChainID();\nerror ObsoleteUpdate();\nerror StaleUpdate();\nerror UnexpectedResultLength();\nerror UnexpectedResultMismatch();\n\n/// @dev QueryDemo is an example of using the QueryResponse library to parse and verify Cross Chain Query (CCQ) responses.\ncontract QueryDemo is QueryResponse {\n    using BytesParsing for bytes;\n\n    struct ChainEntry {\n        uint16 chainID;\n        address contractAddress;\n        uint256 counter;\n        uint256 blockNum;\n        uint256 blockTime;\n    }\n\n    address private immutable owner;\n    uint16 private immutable myChainID;\n    mapping(uint16 =&gt; ChainEntry) private counters;\n    uint16[] private foreignChainIDs;\n\n    bytes4 public GetMyCounter = bytes4(hex\"916d5743\");\n\n    constructor(address _owner, address _wormhole, uint16 _myChainID) QueryResponse(_wormhole) {\n        if (_owner == address(0)) {\n            revert InvalidOwner();\n        }\n        owner = _owner;\n\n        myChainID = _myChainID;\n        counters[_myChainID] = ChainEntry(_myChainID, address(this), 0, 0, 0);\n    }\n\n    // updateRegistration should be used to add the other chains and to set / update contract addresses.\n    function updateRegistration(uint16 _chainID, address _contractAddress) public onlyOwner {\n        if (counters[_chainID].chainID == 0) {\n            foreignChainIDs.push(_chainID);\n            counters[_chainID].chainID = _chainID;\n        }\n\n        counters[_chainID].contractAddress = _contractAddress;\n    }\n\n    // getMyCounter (call signature 916d5743) returns the counter value for this chain. It is meant to be used in a cross chain query.\n    function getMyCounter() public view returns (uint256) {\n        return counters[myChainID].counter;\n    }\n\n    // getState() returns this chain's view of all the counters. It is meant to be used in the front end.\n    function getState() public view returns (ChainEntry[] memory) {\n        ChainEntry[] memory ret = new ChainEntry[](foreignChainIDs.length + 1);\n        ret[0] = counters[myChainID];\n        uint256 length = foreignChainIDs.length;\n\n        for (uint256 i = 0; i &lt; length;) {\n            ret[i + 1] = counters[foreignChainIDs[i]];\n            unchecked {\n                ++i;\n            }\n        }\n\n        return ret;\n    }\n\n    // @notice Takes the cross chain query response for the other counters, stores the results for the other chains, and updates the counter for this chain.\n    function updateCounters(bytes memory response, IWormhole.Signature[] memory signatures) public {\n        ParsedQueryResponse memory r = parseAndVerifyQueryResponse(response, signatures);\n        uint256 numResponses = r.responses.length;\n        if (numResponses != foreignChainIDs.length) {\n            revert UnexpectedResultLength();\n        }\n\n        for (uint256 i = 0; i &lt; numResponses;) {\n            // Create a storage pointer for frequently read and updated data stored on the blockchain\n            ChainEntry storage chainEntry = counters[r.responses[i].chainId];\n            if (chainEntry.chainID != foreignChainIDs[i]) {\n                revert InvalidForeignChainID();\n            }\n\n            EthCallQueryResponse memory eqr = parseEthCallQueryResponse(r.responses[i]);\n\n            // Validate that update is not obsolete\n            validateBlockNum(eqr.blockNum, chainEntry.blockNum);\n\n            // Validate that update is not stale\n            validateBlockTime(eqr.blockTime, block.timestamp - 300);\n\n            if (eqr.result.length != 1) {\n                revert UnexpectedResultMismatch();\n            }\n\n            // Validate addresses and function signatures\n            address[] memory validAddresses = new address[](1);\n            bytes4[] memory validFunctionSignatures = new bytes4[](1);\n            validAddresses[0] = chainEntry.contractAddress;\n            validFunctionSignatures[0] = GetMyCounter;\n\n            validateMultipleEthCallData(eqr.result, validAddresses, validFunctionSignatures);\n\n            require(eqr.result[0].result.length == 32, \"result is not a uint256\");\n\n            chainEntry.blockNum = eqr.blockNum;\n            chainEntry.blockTime = eqr.blockTime / 1_000_000;\n            chainEntry.counter = abi.decode(eqr.result[0].result, (uint256));\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        counters[myChainID].blockNum = block.number;\n        counters[myChainID].blockTime = block.timestamp;\n        counters[myChainID].counter += 1;\n    }\n\n    modifier onlyOwner() {\n        if (owner != msg.sender) {\n            revert InvalidOwner();\n        }\n        _;\n    }\n}\n</code></pre>"},{"location":"build/applications/queries/use-queries/#submit-a-query-response-on-chain","title":"Submit a Query Response On-Chain","text":"<p>The <code>QueryProxyQueryResponse</code> result requires a slight tweak when submitting to the contract to match the format of <code>function parseAndVerifyQueryResponse(bytes memory response, IWormhole.Signature[] memory signatures)</code>. A helper function, <code>signaturesToEvmStruct</code>, is provided in the SDK for this.</p> <p>This example submits the transaction to the demo contract:</p> <pre><code>const tx = await contract.updateCounters(\n  `0x${response.data.bytes}`,\n  signaturesToEvmStruct(response.data.signatures)\n);\n</code></pre>"},{"location":"build/contract-integrations/","title":"Build Contract Integrations","text":""},{"location":"build/contract-integrations/#get-started","title":"Get Started","text":"<p>The content in this section will teach you how to create smart contracts that integrate with Wormhole's messaging protocols, enabling your applications to send and receive messages across multiple blockchains. Discover the tools and techniques to build seamless cross-chain functionality into your decentralized applications.</p> <ul> <li> <p> Wormhole Relayer</p> <p>Get familiar with the Wormhole relayer interfaces and learn the essential requirements for interacting with the relayer to send and receive cross-chain messages.</p> <p> Get started with the Wormhole relayer</p> </li> <li> <p> Core Contracts</p> <p>Discover how to develop or adapt your contracts to interact directly with Wormhole's Core Contracts for sending and receiving cross-chain messages.</p> <p> Get started with Core Contracts</p> </li> <li> <p> Gateway</p> <p>Use the Wormhole Gateway, a Cosmos SDK chain enabling asset bridging into the Cosmos ecosystem, unifying liquidity, and supporting cross-chain transfers.</p> <p> Get started with Gateway</p> </li> <li> <p> Native Token Transfers</p> <p>Find guidance on how to get started with the Native Token Transfers (NTT) framework, including deploying and configuring NTT contracts.</p> <p> Get started with NTT</p> </li> <li> <p> Fast Transfers</p> <p>Learn how to take advantage of the Fast Transfers protocol for quick, efficient cross-chain liquidity movement.</p> <p> Get started with Fast Transfers</p> </li> <li> <p> Development Environment</p> <p>Learn how to set up a development environment for comprehensive testing, including VAA generation and relaying, to ensure full integration functionality.</p> <p> Set up a dev environment</p> </li> </ul>"},{"location":"build/contract-integrations/cctp/","title":"Get Started with CCTP","text":""},{"location":"build/contract-integrations/cctp/#introduction","title":"Introduction","text":"<p>Circle's Cross-Chain Transfer Protocol (CCTP) by Circle is a permissionless utility that facilitates secure and efficient USDC transfers across blockchain networks through native burning and minting mechanisms.</p> <p>As decentralized finance (DeFi) protocols evolve, the need for flexible, secure cross-chain messaging has expanded, requiring solutions beyond simple asset transfers. Wormhole enhances CCTP's capabilities by allowing developers to compose more complex cross-chain interactions. With Wormhole's generic messaging, applications can execute smart contract logic alongside native USDC transfers, enabling richer, more versatile cross-chain experiences.</p> <p>This guide will walk you through getting started with Wormhole's CCTP contracts and show you how to integrate CCTP into your smart contracts, enabling the composition of advanced cross-chain functions with native USDC transfers.</p>"},{"location":"build/contract-integrations/cctp/#prerequisites","title":"Prerequisites","text":"<p>To interact with the Wormhole CCTP, you'll need the following:</p> <ul> <li>The address of the CCTP contract on the chains you're deploying your contract on</li> <li>The Wormhole chain ID of the chains you're deploying your contract on</li> </ul>"},{"location":"build/contract-integrations/cctp/#wormholes-cctp-integration-contract","title":"Wormhole's CCTP Integration Contract","text":"<p>Wormhole's Circle Integration contract, <code>CircleIntegration.sol</code>, is the contract you'll interact with directly. It burns and mints Circle-supported tokens by using Circle's CCTP contracts.</p> <p>The Circle Integration contract emits Wormhole messages with arbitrary payloads to allow additional composability when performing cross-chain transfers of Circle-supported assets.</p> <p>This contract can be found in Wormhole's <code>wormhole-circle-integration</code> repository on GitHub.</p> <p>Note</p> <p>Wormhole supports all CCTP-supported chains, but Circle currently supports only a handful of chains. Please refer to the CCTP section of the Contract Addresses reference page to view the complete list of supported chains.</p> Circle Integration contract <pre><code>// SPDX-License-Identifier: Apache 2\npragma solidity ^0.8.19;\n\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IWormhole} from \"wormhole/interfaces/IWormhole.sol\";\nimport {BytesLib} from \"wormhole/libraries/external/BytesLib.sol\";\n\nimport {ICircleBridge} from \"../interfaces/circle/ICircleBridge.sol\";\n\nimport {CircleIntegrationGovernance} from \"./CircleIntegrationGovernance.sol\";\nimport {CircleIntegrationMessages} from \"./CircleIntegrationMessages.sol\";\n\n/**\n * @notice This contract burns and mints Circle-supported tokens by using Circle's Cross-Chain Transfer Protocol. It also emits\n * Wormhole messages with arbitrary payloads to allow for additional composability when performing cross-chain\n * transfers of Circle-suppored assets.\n */\ncontract CircleIntegration is\n    CircleIntegrationMessages,\n    CircleIntegrationGovernance,\n    ReentrancyGuard\n{\n    using BytesLib for bytes;\n\n    /**\n     * @notice Emitted when Circle-supported assets have been minted to the mintRecipient\n     * @param emitterChainId Wormhole chain ID of emitter contract on source chain\n     * @param emitterAddress Address (bytes32 zero-left-padded) of emitter on source chain\n     * @param sequence Sequence of Wormhole message used to mint tokens\n     */\n    event Redeemed(\n        uint16 indexed emitterChainId,\n        bytes32 indexed emitterAddress,\n        uint64 indexed sequence\n    );\n\n    /**\n     * @notice `transferTokensWithPayload` calls the Circle Bridge contract to burn Circle-supported tokens. It emits\n     * a Wormhole message containing a user-specified payload with instructions for what to do with\n     * the Circle-supported assets once they have been minted on the target chain.\n     * @dev reverts if:\n     * - user passes insufficient value to pay Wormhole message fee\n     * - `token` is not supported by Circle Bridge\n     * - `amount` is zero\n     * - `targetChain` is not supported\n     * - `mintRecipient` is bytes32(0)\n     * @param transferParams Struct containing the following attributes:\n     * - `token` Address of the token to be burned\n     * - `amount` Amount of `token` to be burned\n     * - `targetChain` Wormhole chain ID of the target blockchain\n     * - `mintRecipient` The recipient wallet or contract address on the target chain\n     * @param batchId ID for Wormhole message batching\n     * @param payload Arbitrary payload to be delivered to the target chain via Wormhole\n     * @return messageSequence Wormhole sequence number for this contract\n     */\n    function transferTokensWithPayload(\n        TransferParameters memory transferParams,\n        uint32 batchId,\n        bytes memory payload\n    ) public payable nonReentrant returns (uint64 messageSequence) {\n        // cache wormhole instance and fees to save on gas\n        IWormhole wormhole = wormhole();\n        uint256 wormholeFee = wormhole.messageFee();\n\n        // confirm that the caller has sent enough ether to pay for the wormhole message fee\n        require(msg.value == wormholeFee, \"insufficient value\");\n\n        // Call the circle bridge and `depositForBurnWithCaller`. The `mintRecipient`\n        // should be the target contract (or wallet) composing on this contract.\n        (uint64 nonce, uint256 amountReceived) = _transferTokens(\n            transferParams.token,\n            transferParams.amount,\n            transferParams.targetChain,\n            transferParams.mintRecipient\n        );\n\n        // encode DepositWithPayload message\n        bytes memory encodedMessage = encodeDepositWithPayload(\n            DepositWithPayload({\n                token: addressToBytes32(transferParams.token),\n                amount: amountReceived,\n                sourceDomain: localDomain(),\n                targetDomain: getDomainFromChainId(transferParams.targetChain),\n                nonce: nonce,\n                fromAddress: addressToBytes32(msg.sender),\n                mintRecipient: transferParams.mintRecipient,\n                payload: payload\n            })\n        );\n\n        // send the DepositWithPayload wormhole message\n        messageSequence = wormhole.publishMessage{value: wormholeFee}(\n            batchId,\n            encodedMessage,\n            wormholeFinality()\n        );\n    }\n\n    function _transferTokens(\n        address token,\n        uint256 amount,\n        uint16 targetChain,\n        bytes32 mintRecipient\n    ) internal returns (uint64 nonce, uint256 amountReceived) {\n        // sanity check user input\n        require(amount &gt; 0, \"amount must be &gt; 0\");\n        require(mintRecipient != bytes32(0), \"invalid mint recipient\");\n        require(isAcceptedToken(token), \"token not accepted\");\n        require(\n            getRegisteredEmitter(targetChain) != bytes32(0),\n            \"target contract not registered\"\n        );\n\n        // take custody of tokens\n        amountReceived = custodyTokens(token, amount);\n\n        // cache Circle Bridge instance\n        ICircleBridge circleBridge = circleBridge();\n\n        // approve the Circle Bridge to spend tokens\n        SafeERC20.safeApprove(\n            IERC20(token),\n            address(circleBridge),\n            amountReceived\n        );\n\n        // burn tokens on the bridge\n        nonce = circleBridge.depositForBurnWithCaller(\n            amountReceived,\n            getDomainFromChainId(targetChain),\n            mintRecipient,\n            token,\n            getRegisteredEmitter(targetChain)\n        );\n    }\n\n    function custodyTokens(\n        address token,\n        uint256 amount\n    ) internal returns (uint256) {\n        // query own token balance before transfer\n        (, bytes memory queriedBalanceBefore) = token.staticcall(\n            abi.encodeWithSelector(IERC20.balanceOf.selector, address(this))\n        );\n        uint256 balanceBefore = abi.decode(queriedBalanceBefore, (uint256));\n\n        // deposit tokens\n        SafeERC20.safeTransferFrom(\n            IERC20(token),\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        // query own token balance after transfer\n        (, bytes memory queriedBalanceAfter) = token.staticcall(\n            abi.encodeWithSelector(IERC20.balanceOf.selector, address(this))\n        );\n        uint256 balanceAfter = abi.decode(queriedBalanceAfter, (uint256));\n\n        return balanceAfter - balanceBefore;\n    }\n\n    /**\n     * @notice `redeemTokensWithPayload` verifies the Wormhole message from the source chain and\n     * verifies that the passed Circle Bridge message is valid. It calls the Circle Bridge\n     * contract by passing the Circle message and attestation to mint tokens to the specified\n     * mint recipient. It also verifies that the caller is the specified mint recipient to ensure\n     * atomic execution of the additional instructions in the Wormhole message.\n     * @dev reverts if:\n     * - Wormhole message is not properly attested\n     * - Wormhole message was not emitted from a registered contrat\n     * - Wormhole message was already consumed by this contract\n     * - msg.sender is not the encoded mintRecipient\n     * - Circle Bridge message and Wormhole message are not associated\n     * - `receiveMessage` call to Circle Transmitter fails\n     * @param params Struct containing the following attributes:\n     * - `encodedWormholeMessage` Wormhole message emitted by a registered contract including\n     * information regarding the token burn on the source chain and an arbitrary message.\n     * - `circleBridgeMessage` Message emitted by Circle Bridge contract with information regarding\n     * the token burn on the source chain.\n     * - `circleAttestation` Serialized EC Signature attesting the cross-chain transfer\n     * @return depositInfo Struct containing the following attributes:\n     * - `token` Address (bytes32 left-zero-padded) of token to be minted\n     * - `amount` Amount of tokens to be minted\n     * - `sourceDomain` Circle domain for the source chain\n     * - `targetDomain` Circle domain for the target chain\n     * - `nonce` Circle sequence number for the transfer\n     * - `fromAddress` Source CircleIntegration contract caller's address\n     * - `mintRecipient` Recipient of minted tokens (must be caller of this contract)\n     * - `payload` Arbitrary Wormhole message payload\n     */\n    function redeemTokensWithPayload(\n        RedeemParameters calldata params\n    ) public returns (DepositWithPayload memory depositInfo) {\n        // verify the wormhole message\n        IWormhole.VM memory verifiedMessage = verifyWormholeRedeemMessage(\n            params.encodedWormholeMessage\n        );\n\n        // Decode the message payload into the DepositWithPayload struct. Call the Circle TokenMinter\n        // contract to determine the address of the encoded token on this chain.\n        depositInfo = decodeDepositWithPayload(verifiedMessage.payload);\n        depositInfo.token = fetchLocalTokenAddress(\n            depositInfo.sourceDomain,\n            depositInfo.token\n        );\n\n        // confirm that circle gave us a valid token address\n        require(depositInfo.token != bytes32(0), \"invalid local token address\");\n\n        // confirm that the caller is the `mintRecipient` to ensure atomic execution\n        require(\n            addressToBytes32(msg.sender) == depositInfo.mintRecipient,\n            \"caller must be mintRecipient\"\n        );\n\n        // confirm that the caller passed the correct message pair\n        require(\n            verifyCircleMessage(\n                params.circleBridgeMessage,\n                depositInfo.sourceDomain,\n                depositInfo.targetDomain,\n                depositInfo.nonce\n            ),\n            \"invalid message pair\"\n        );\n\n        // call the circle bridge to mint tokens to the recipient\n        bool success = circleTransmitter().receiveMessage(\n            params.circleBridgeMessage,\n            params.circleAttestation\n        );\n        require(success, \"CIRCLE_INTEGRATION: failed to mint tokens\");\n\n        // emit Redeemed event\n        emit Redeemed(\n            verifiedMessage.emitterChainId,\n            verifiedMessage.emitterAddress,\n            verifiedMessage.sequence\n        );\n    }\n\n    function verifyWormholeRedeemMessage(\n        bytes memory encodedMessage\n    ) internal returns (IWormhole.VM memory) {\n        require(evmChain() == block.chainid, \"invalid evm chain\");\n\n        // parse and verify the Wormhole core message\n        (\n            IWormhole.VM memory verifiedMessage,\n            bool valid,\n            string memory reason\n        ) = wormhole().parseAndVerifyVM(encodedMessage);\n\n        // confirm that the core layer verified the message\n        require(valid, reason);\n\n        // verify that this message was emitted by a trusted contract\n        require(verifyEmitter(verifiedMessage), \"unknown emitter\");\n\n        // revert if this message has been consumed already\n        require(\n            !isMessageConsumed(verifiedMessage.hash),\n            \"message already consumed\"\n        );\n        consumeMessage(verifiedMessage.hash);\n\n        return verifiedMessage;\n    }\n\n    function verifyEmitter(\n        IWormhole.VM memory vm\n    ) internal view returns (bool) {\n        // verify that the sender of the wormhole message is a trusted\n        return (getRegisteredEmitter(vm.emitterChainId) == vm.emitterAddress &amp;&amp;\n            vm.emitterAddress != bytes32(0));\n    }\n\n    function verifyCircleMessage(\n        bytes memory circleMessage,\n        uint32 sourceDomain,\n        uint32 targetDomain,\n        uint64 nonce\n    ) internal pure returns (bool) {\n        // parse the circle bridge message inline\n        uint32 circleSourceDomain = circleMessage.toUint32(4);\n        uint32 circleTargetDomain = circleMessage.toUint32(8);\n        uint64 circleNonce = circleMessage.toUint64(12);\n\n        // confirm that both the Wormhole message and Circle message share the same transfer info\n        return (sourceDomain == circleSourceDomain &amp;&amp;\n            targetDomain == circleTargetDomain &amp;&amp;\n            nonce == circleNonce);\n    }\n\n    /**\n     * @notice Fetches the local token address given an address and domain from\n     * a different chain.\n     * @param sourceDomain Circle domain for the sending chain.\n     * @param sourceToken Address of the token for the sending chain.\n     * @return Address bytes32 formatted address of the `sourceToken` on this chain.\n     */\n    function fetchLocalTokenAddress(\n        uint32 sourceDomain,\n        bytes32 sourceToken\n    ) public view returns (bytes32) {\n        return\n            addressToBytes32(\n                circleTokenMinter().remoteTokensToLocalTokens(\n                    keccak256(abi.encodePacked(sourceDomain, sourceToken))\n                )\n            );\n    }\n\n    /**\n     * @notice Converts type address to bytes32 (left-zero-padded)\n     * @param address_ Address to convert to bytes32\n     * @return Address bytes32\n     */\n    function addressToBytes32(address address_) public pure returns (bytes32) {\n        return bytes32(uint256(uint160(address_)));\n    }\n}\n</code></pre> <p>The functions provided by the Circle Integration contract are as follows:</p> <ul> <li> <p><code>transferTokensWithPayload</code> - calls the Circle Bridge contract to burn Circle-supported tokens. It emits a Wormhole message containing a user-specified payload with instructions for what to do with the Circle-supported assets once they have been minted on the target chain</p> Parameters <p><code>transferParams</code> TransferParameters</p> <p>A tuple containing the parameters for the transfer.</p> <code>TransferParameters</code> struct <p><code>token</code> address</p> <p>Address of the token to be burned.</p> <p><code>amount</code> uint256</p> <p>Amount of the token to be burned.</p> <p><code>targetChain</code> uint16</p> <p>Wormhole chain ID of the target blockchain.</p> <p><code>mintRecipient</code> bytes32</p> <p>The recipient wallet or contract address on the target chain.</p> <p><code>batchId</code> uint32</p> <p>The ID for Wormhole message batching.</p> <p><code>payload</code> bytes</p> <p>Arbitrary payload to be delivered to the target chain via Wormhole.</p> Returns <p><code>messageSequence</code> uint64</p> <p>Wormhole sequence number for this contract.</p> </li> <li> <p><code>redeemTokensWithPayload</code> - verifies the Wormhole message from the source chain and verifies that the passed Circle Bridge message is valid. It calls the Circle Bridge contract by passing the Circle message and attestation to the <code>receiveMessage</code> function, which is responsible for minting tokens to the specified mint recipient. It also verifies that the caller is the specified mint recipient to ensure atomic execution of the additional instructions in the Wormhole message</p> Parameters <p><code>params</code> RedeemParameters</p> <p>A tuple containing the parameters for the redemption.</p> <code>RedeemParameters</code> struct <p><code>encodedWormholeMessage</code> bytes</p> <p>Wormhole message emitted by a registered contract including information regarding the token burn on the source chain and an arbitrary message.</p> <p><code>circleBridgeMessage</code> bytes</p> <p>Message emitted by Circle Bridge contract with information regarding the token burn on the source chain.</p> <p><code>circleAttestation</code> bytes</p> <p>Serialized EC signature attesting the cross-chain transfer.</p> Returns <p><code>depositInfo</code> DepositWithPayload</p> <p>Information about the deposit.</p> <code>DepositWithPayload</code> struct <p><code>token</code> bytes32</p> <p>Address (<code>bytes32</code> left-zero-padded) of token to be minted.</p> <p><code>amount</code> uint256</p> <p>Amount of tokens to be minted.</p> <p><code>sourceDomain</code> uint32</p> <p>Circle domain for the source chain.</p> <p><code>targetDomain</code> uint32</p> <p>Circle domain for the target chain.</p> <p><code>nonce</code> uint64</p> <p>Circle sequence number for the transfer.</p> <p><code>fromAddress</code> bytes32</p> <p>Source Circle Integration contract caller's address.</p> <p><code>mintRecipient</code> bytes32</p> <p>Recipient of minted tokens (must be caller of this contract).</p> <p><code>payload</code> bytes</p> <p>Arbitrary Wormhole message payload.</p> Emits <p><code>Redeemed</code> - event emitted when Circle-supported assets have been minted to the <code>mintRecipient</code></p> Event arguments <p><code>emitterChainId</code> uint16</p> <p>Wormhole chain ID of emitter contract on source chain.</p> <p><code>emitterAddress</code> bytes32</p> <p>Address (<code>bytes32</code> zero-left-padded) of emitter on source chain.</p> <p><code>sequence</code> uint64</p> <p>Sequence of Wormhole message used to mint tokens.</p> </li> </ul>"},{"location":"build/contract-integrations/cctp/#circles-cctp-contracts","title":"Circle's CCTP Contracts","text":"<p>Three key contracts power Circle's CCTP:</p> <ul> <li><code>TokenMessenger</code> - the entry point for cross-chain USDC transfers, routing messages to initiate USDC burns on the source chain, and mint USDC on the destination chain</li> <li><code>MessageTransmitter</code> - handles generic message passing, sending messages from the source chain and receiving them on the destination chain</li> <li><code>TokenMinter</code> - responsible for the actual minting and burning of USDC, utilizing chain-specific settings for both the burners and minters across different networks</li> </ul> <p>The following sections will examine these contracts in-depth, focusing on the methods invoked indirectly through function calls in the Wormhole Circle Integration contract.</p> <p>Note</p> <p>When using Wormhole's CCTP integration, you will not directly interact with these contracts. You will indirectly interact with them through the Wormhole Circle Integration contract.</p> <p>These contracts can be found in Circle's <code>evm-cctp-contracts</code> repository on GitHub.</p>"},{"location":"build/contract-integrations/cctp/#token-messenger-contract","title":"Token Messenger Contract","text":"<p>The Token Messenger contract enables cross-chain USDC transfers by coordinating message exchanges between blockchains. It works alongside the Message Transmitter contract to relay messages for burning USDC on a source chain and minting it on a destination chain. The contract emits events to track both the burning of tokens and their subsequent minting on the destination chain.</p> <p>To ensure secure communication, the Token Messenger restricts message handling to registered remote Token Messenger contracts only. It verifies the proper conditions for token burning and manages local and remote minters using chain-specific settings.</p> <p>Additionally, the contract provides methods for updating or replacing previously sent burn messages, adding or removing remote Token Messenger contracts, and managing the minting process for cross-chain transfers.</p> Token Messenger contract <pre><code>/*\n * Copyright (c) 2022, Circle Internet Financial Limited.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npragma solidity 0.7.6;\n\nimport \"./interfaces/IMessageHandler.sol\";\nimport \"./interfaces/ITokenMinter.sol\";\nimport \"./interfaces/IMintBurnToken.sol\";\nimport \"./interfaces/IMessageTransmitter.sol\";\nimport \"./messages/BurnMessage.sol\";\nimport \"./messages/Message.sol\";\nimport \"./roles/Rescuable.sol\";\n\n/**\n * @title TokenMessenger\n * @notice Sends messages and receives messages to/from MessageTransmitters\n * and to/from TokenMinters\n */\ncontract TokenMessenger is IMessageHandler, Rescuable {\n    // ============ Events ============\n    /**\n     * @notice Emitted when a DepositForBurn message is sent\n     * @param nonce unique nonce reserved by message\n     * @param burnToken address of token burnt on source domain\n     * @param amount deposit amount\n     * @param depositor address where deposit is transferred from\n     * @param mintRecipient address receiving minted tokens on destination domain as bytes32\n     * @param destinationDomain destination domain\n     * @param destinationTokenMessenger address of TokenMessenger on destination domain as bytes32\n     * @param destinationCaller authorized caller as bytes32 of receiveMessage() on destination domain, if not equal to bytes32(0).\n     * If equal to bytes32(0), any address can call receiveMessage().\n     */\n    event DepositForBurn(\n        uint64 indexed nonce,\n        address indexed burnToken,\n        uint256 amount,\n        address indexed depositor,\n        bytes32 mintRecipient,\n        uint32 destinationDomain,\n        bytes32 destinationTokenMessenger,\n        bytes32 destinationCaller\n    );\n\n    /**\n     * @notice Emitted when tokens are minted\n     * @param mintRecipient recipient address of minted tokens\n     * @param amount amount of minted tokens\n     * @param mintToken contract address of minted token\n     */\n    event MintAndWithdraw(\n        address indexed mintRecipient,\n        uint256 amount,\n        address indexed mintToken\n    );\n\n    /**\n     * @notice Emitted when a remote TokenMessenger is added\n     * @param domain remote domain\n     * @param tokenMessenger TokenMessenger on remote domain\n     */\n    event RemoteTokenMessengerAdded(uint32 domain, bytes32 tokenMessenger);\n\n    /**\n     * @notice Emitted when a remote TokenMessenger is removed\n     * @param domain remote domain\n     * @param tokenMessenger TokenMessenger on remote domain\n     */\n    event RemoteTokenMessengerRemoved(uint32 domain, bytes32 tokenMessenger);\n\n    /**\n     * @notice Emitted when the local minter is added\n     * @param localMinter address of local minter\n     * @notice Emitted when the local minter is added\n     */\n    event LocalMinterAdded(address localMinter);\n\n    /**\n     * @notice Emitted when the local minter is removed\n     * @param localMinter address of local minter\n     * @notice Emitted when the local minter is removed\n     */\n    event LocalMinterRemoved(address localMinter);\n\n    // ============ Libraries ============\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n    using BurnMessage for bytes29;\n    using Message for bytes29;\n\n    // ============ State Variables ============\n    // Local Message Transmitter responsible for sending and receiving messages to/from remote domains\n    IMessageTransmitter public immutable localMessageTransmitter;\n\n    // Version of message body format\n    uint32 public immutable messageBodyVersion;\n\n    // Minter responsible for minting and burning tokens on the local domain\n    ITokenMinter public localMinter;\n\n    // Valid TokenMessengers on remote domains\n    mapping(uint32 =&gt; bytes32) public remoteTokenMessengers;\n\n    // ============ Modifiers ============\n    /**\n     * @notice Only accept messages from a registered TokenMessenger contract on given remote domain\n     * @param domain The remote domain\n     * @param tokenMessenger The address of the TokenMessenger contract for the given remote domain\n     */\n    modifier onlyRemoteTokenMessenger(uint32 domain, bytes32 tokenMessenger) {\n        require(\n            _isRemoteTokenMessenger(domain, tokenMessenger),\n            \"Remote TokenMessenger unsupported\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Only accept messages from the registered message transmitter on local domain\n     */\n    modifier onlyLocalMessageTransmitter() {\n        // Caller must be the registered message transmitter for this domain\n        require(_isLocalMessageTransmitter(), \"Invalid message transmitter\");\n        _;\n    }\n\n    // ============ Constructor ============\n    /**\n     * @param _messageTransmitter Message transmitter address\n     * @param _messageBodyVersion Message body version\n     */\n    constructor(address _messageTransmitter, uint32 _messageBodyVersion) {\n        require(\n            _messageTransmitter != address(0),\n            \"MessageTransmitter not set\"\n        );\n        localMessageTransmitter = IMessageTransmitter(_messageTransmitter);\n        messageBodyVersion = _messageBodyVersion;\n    }\n\n    // ============ External Functions  ============\n    /**\n     * @notice Deposits and burns tokens from sender to be minted on destination domain.\n     * Emits a `DepositForBurn` event.\n     * @dev reverts if:\n     * - given burnToken is not supported\n     * - given destinationDomain has no TokenMessenger registered\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\n     * to this contract is less than `amount`.\n     * - burn() reverts. For example, if `amount` is 0.\n     * - MessageTransmitter returns false or reverts.\n     * @param amount amount of tokens to burn\n     * @param destinationDomain destination domain\n     * @param mintRecipient address of mint recipient on destination domain\n     * @param burnToken address of contract to burn deposited tokens, on local domain\n     * @return _nonce unique nonce reserved by message\n     */\n    function depositForBurn(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken\n    ) external returns (uint64 _nonce) {\n        return\n            _depositForBurn(\n                amount,\n                destinationDomain,\n                mintRecipient,\n                burnToken,\n                // (bytes32(0) here indicates that any address can call receiveMessage()\n                // on the destination domain, triggering mint to specified `mintRecipient`)\n                bytes32(0)\n            );\n    }\n\n    /**\n     * @notice Deposits and burns tokens from sender to be minted on destination domain. The mint\n     * on the destination domain must be called by `destinationCaller`.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * depositForBurn() should be preferred for use cases where a specific destination caller is not required.\n     * Emits a `DepositForBurn` event.\n     * @dev reverts if:\n     * - given destinationCaller is zero address\n     * - given burnToken is not supported\n     * - given destinationDomain has no TokenMessenger registered\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\n     * to this contract is less than `amount`.\n     * - burn() reverts. For example, if `amount` is 0.\n     * - MessageTransmitter returns false or reverts.\n     * @param amount amount of tokens to burn\n     * @param destinationDomain destination domain\n     * @param mintRecipient address of mint recipient on destination domain\n     * @param burnToken address of contract to burn deposited tokens, on local domain\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @return nonce unique nonce reserved by message\n     */\n    function depositForBurnWithCaller(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller\n    ) external returns (uint64 nonce) {\n        // Destination caller must be nonzero. To allow any destination caller, use depositForBurn().\n        require(destinationCaller != bytes32(0), \"Invalid destination caller\");\n\n        return\n            _depositForBurn(\n                amount,\n                destinationDomain,\n                mintRecipient,\n                burnToken,\n                destinationCaller\n            );\n    }\n\n    /**\n     * @notice Replace a BurnMessage to change the mint recipient and/or\n     * destination caller. Allows the sender of a previous BurnMessage\n     * (created by depositForBurn or depositForBurnWithCaller)\n     * to send a new BurnMessage to replace the original.\n     * The new BurnMessage will reuse the amount and burn token of the original,\n     * without requiring a new deposit.\n     * @dev The new message will reuse the original message's nonce. For a\n     * given nonce, all replacement message(s) and the original message are\n     * valid to broadcast on the destination domain, until the first message\n     * at the nonce confirms, at which point all others are invalidated.\n     * Note: The msg.sender of the replaced message must be the same as the\n     * msg.sender of the original message.\n     * @param originalMessage original message bytes (to replace)\n     * @param originalAttestation original attestation bytes\n     * @param newDestinationCaller the new destination caller, which may be the\n     * same as the original destination caller, a new destination caller, or an empty\n     * destination caller (bytes32(0), indicating that any destination caller is valid.)\n     * @param newMintRecipient the new mint recipient, which may be the same as the\n     * original mint recipient, or different.\n     */\n    function replaceDepositForBurn(\n        bytes calldata originalMessage,\n        bytes calldata originalAttestation,\n        bytes32 newDestinationCaller,\n        bytes32 newMintRecipient\n    ) external {\n        bytes29 _originalMsg = originalMessage.ref(0);\n        _originalMsg._validateMessageFormat();\n        bytes29 _originalMsgBody = _originalMsg._messageBody();\n        _originalMsgBody._validateBurnMessageFormat();\n\n        bytes32 _originalMsgSender = _originalMsgBody._getMessageSender();\n        // _originalMsgSender must match msg.sender of original message\n        require(\n            msg.sender == Message.bytes32ToAddress(_originalMsgSender),\n            \"Invalid sender for message\"\n        );\n        require(\n            newMintRecipient != bytes32(0),\n            \"Mint recipient must be nonzero\"\n        );\n\n        bytes32 _burnToken = _originalMsgBody._getBurnToken();\n        uint256 _amount = _originalMsgBody._getAmount();\n\n        bytes memory _newMessageBody = BurnMessage._formatMessage(\n            messageBodyVersion,\n            _burnToken,\n            newMintRecipient,\n            _amount,\n            _originalMsgSender\n        );\n\n        localMessageTransmitter.replaceMessage(\n            originalMessage,\n            originalAttestation,\n            _newMessageBody,\n            newDestinationCaller\n        );\n\n        emit DepositForBurn(\n            _originalMsg._nonce(),\n            Message.bytes32ToAddress(_burnToken),\n            _amount,\n            msg.sender,\n            newMintRecipient,\n            _originalMsg._destinationDomain(),\n            _originalMsg._recipient(),\n            newDestinationCaller\n        );\n    }\n\n    /**\n     * @notice Handles an incoming message received by the local MessageTransmitter,\n     * and takes the appropriate action. For a burn message, mints the\n     * associated token to the requested recipient on the local domain.\n     * @dev Validates the local sender is the local MessageTransmitter, and the\n     * remote sender is a registered remote TokenMessenger for `remoteDomain`.\n     * @param remoteDomain The domain where the message originated from.\n     * @param sender The sender of the message (remote TokenMessenger).\n     * @param messageBody The message body bytes.\n     * @return success Bool, true if successful.\n     */\n    function handleReceiveMessage(\n        uint32 remoteDomain,\n        bytes32 sender,\n        bytes calldata messageBody\n    )\n        external\n        override\n        onlyLocalMessageTransmitter\n        onlyRemoteTokenMessenger(remoteDomain, sender)\n        returns (bool)\n    {\n        bytes29 _msg = messageBody.ref(0);\n        _msg._validateBurnMessageFormat();\n        require(\n            _msg._getVersion() == messageBodyVersion,\n            \"Invalid message body version\"\n        );\n\n        bytes32 _mintRecipient = _msg._getMintRecipient();\n        bytes32 _burnToken = _msg._getBurnToken();\n        uint256 _amount = _msg._getAmount();\n\n        ITokenMinter _localMinter = _getLocalMinter();\n\n        _mintAndWithdraw(\n            address(_localMinter),\n            remoteDomain,\n            _burnToken,\n            Message.bytes32ToAddress(_mintRecipient),\n            _amount\n        );\n\n        return true;\n    }\n\n    /**\n     * @notice Add the TokenMessenger for a remote domain.\n     * @dev Reverts if there is already a TokenMessenger set for domain.\n     * @param domain Domain of remote TokenMessenger.\n     * @param tokenMessenger Address of remote TokenMessenger as bytes32.\n     */\n    function addRemoteTokenMessenger(uint32 domain, bytes32 tokenMessenger)\n        external\n        onlyOwner\n    {\n        require(tokenMessenger != bytes32(0), \"bytes32(0) not allowed\");\n\n        require(\n            remoteTokenMessengers[domain] == bytes32(0),\n            \"TokenMessenger already set\"\n        );\n\n        remoteTokenMessengers[domain] = tokenMessenger;\n        emit RemoteTokenMessengerAdded(domain, tokenMessenger);\n    }\n\n    /**\n     * @notice Remove the TokenMessenger for a remote domain.\n     * @dev Reverts if there is no TokenMessenger set for `domain`.\n     * @param domain Domain of remote TokenMessenger\n     */\n    function removeRemoteTokenMessenger(uint32 domain) external onlyOwner {\n        // No TokenMessenger set for given remote domain.\n        require(\n            remoteTokenMessengers[domain] != bytes32(0),\n            \"No TokenMessenger set\"\n        );\n\n        bytes32 _removedTokenMessenger = remoteTokenMessengers[domain];\n        delete remoteTokenMessengers[domain];\n        emit RemoteTokenMessengerRemoved(domain, _removedTokenMessenger);\n    }\n\n    /**\n     * @notice Add minter for the local domain.\n     * @dev Reverts if a minter is already set for the local domain.\n     * @param newLocalMinter The address of the minter on the local domain.\n     */\n    function addLocalMinter(address newLocalMinter) external onlyOwner {\n        require(newLocalMinter != address(0), \"Zero address not allowed\");\n\n        require(\n            address(localMinter) == address(0),\n            \"Local minter is already set.\"\n        );\n\n        localMinter = ITokenMinter(newLocalMinter);\n\n        emit LocalMinterAdded(newLocalMinter);\n    }\n\n    /**\n     * @notice Remove the minter for the local domain.\n     * @dev Reverts if the minter of the local domain is not set.\n     */\n    function removeLocalMinter() external onlyOwner {\n        address _localMinterAddress = address(localMinter);\n        require(_localMinterAddress != address(0), \"No local minter is set.\");\n\n        delete localMinter;\n        emit LocalMinterRemoved(_localMinterAddress);\n    }\n\n    // ============ Internal Utils ============\n    /**\n     * @notice Deposits and burns tokens from sender to be minted on destination domain.\n     * Emits a `DepositForBurn` event.\n     * @param _amount amount of tokens to burn (must be non-zero)\n     * @param _destinationDomain destination domain\n     * @param _mintRecipient address of mint recipient on destination domain\n     * @param _burnToken address of contract to burn deposited tokens, on local domain\n     * @param _destinationCaller caller on the destination domain, as bytes32\n     * @return nonce unique nonce reserved by message\n     */\n    function _depositForBurn(\n        uint256 _amount,\n        uint32 _destinationDomain,\n        bytes32 _mintRecipient,\n        address _burnToken,\n        bytes32 _destinationCaller\n    ) internal returns (uint64 nonce) {\n        require(_amount &gt; 0, \"Amount must be nonzero\");\n        require(_mintRecipient != bytes32(0), \"Mint recipient must be nonzero\");\n\n        bytes32 _destinationTokenMessenger = _getRemoteTokenMessenger(\n            _destinationDomain\n        );\n\n        ITokenMinter _localMinter = _getLocalMinter();\n        IMintBurnToken _mintBurnToken = IMintBurnToken(_burnToken);\n        require(\n            _mintBurnToken.transferFrom(\n                msg.sender,\n                address(_localMinter),\n                _amount\n            ),\n            \"Transfer operation failed\"\n        );\n        _localMinter.burn(_burnToken, _amount);\n\n        // Format message body\n        bytes memory _burnMessage = BurnMessage._formatMessage(\n            messageBodyVersion,\n            Message.addressToBytes32(_burnToken),\n            _mintRecipient,\n            _amount,\n            Message.addressToBytes32(msg.sender)\n        );\n\n        uint64 _nonceReserved = _sendDepositForBurnMessage(\n            _destinationDomain,\n            _destinationTokenMessenger,\n            _destinationCaller,\n            _burnMessage\n        );\n\n        emit DepositForBurn(\n            _nonceReserved,\n            _burnToken,\n            _amount,\n            msg.sender,\n            _mintRecipient,\n            _destinationDomain,\n            _destinationTokenMessenger,\n            _destinationCaller\n        );\n\n        return _nonceReserved;\n    }\n\n    /**\n     * @notice Sends a BurnMessage through the local message transmitter\n     * @dev calls local message transmitter's sendMessage() function if `_destinationCaller` == bytes32(0),\n     * or else calls sendMessageWithCaller().\n     * @param _destinationDomain destination domain\n     * @param _destinationTokenMessenger address of registered TokenMessenger contract on destination domain, as bytes32\n     * @param _destinationCaller caller on the destination domain, as bytes32. If `_destinationCaller` == bytes32(0),\n     * any address can call receiveMessage() on destination domain.\n     * @param _burnMessage formatted BurnMessage bytes (message body)\n     * @return nonce unique nonce reserved by message\n     */\n    function _sendDepositForBurnMessage(\n        uint32 _destinationDomain,\n        bytes32 _destinationTokenMessenger,\n        bytes32 _destinationCaller,\n        bytes memory _burnMessage\n    ) internal returns (uint64 nonce) {\n        if (_destinationCaller == bytes32(0)) {\n            return\n                localMessageTransmitter.sendMessage(\n                    _destinationDomain,\n                    _destinationTokenMessenger,\n                    _burnMessage\n                );\n        } else {\n            return\n                localMessageTransmitter.sendMessageWithCaller(\n                    _destinationDomain,\n                    _destinationTokenMessenger,\n                    _destinationCaller,\n                    _burnMessage\n                );\n        }\n    }\n\n    /**\n     * @notice Mints tokens to a recipient\n     * @param _tokenMinter address of TokenMinter contract\n     * @param _remoteDomain domain where burned tokens originate from\n     * @param _burnToken address of token burned\n     * @param _mintRecipient recipient address of minted tokens\n     * @param _amount amount of minted tokens\n     */\n    function _mintAndWithdraw(\n        address _tokenMinter,\n        uint32 _remoteDomain,\n        bytes32 _burnToken,\n        address _mintRecipient,\n        uint256 _amount\n    ) internal {\n        ITokenMinter _minter = ITokenMinter(_tokenMinter);\n        address _mintToken = _minter.mint(\n            _remoteDomain,\n            _burnToken,\n            _mintRecipient,\n            _amount\n        );\n\n        emit MintAndWithdraw(_mintRecipient, _amount, _mintToken);\n    }\n\n    /**\n     * @notice return the remote TokenMessenger for the given `_domain` if one exists, else revert.\n     * @param _domain The domain for which to get the remote TokenMessenger\n     * @return _tokenMessenger The address of the TokenMessenger on `_domain` as bytes32\n     */\n    function _getRemoteTokenMessenger(uint32 _domain)\n        internal\n        view\n        returns (bytes32)\n    {\n        bytes32 _tokenMessenger = remoteTokenMessengers[_domain];\n        require(_tokenMessenger != bytes32(0), \"No TokenMessenger for domain\");\n        return _tokenMessenger;\n    }\n\n    /**\n     * @notice return the local minter address if it is set, else revert.\n     * @return local minter as ITokenMinter.\n     */\n    function _getLocalMinter() internal view returns (ITokenMinter) {\n        require(address(localMinter) != address(0), \"Local minter is not set\");\n        return localMinter;\n    }\n\n    /**\n     * @notice Return true if the given remote domain and TokenMessenger is registered\n     * on this TokenMessenger.\n     * @param _domain The remote domain of the message.\n     * @param _tokenMessenger The address of the TokenMessenger on remote domain.\n     * @return true if a remote TokenMessenger is registered for `_domain` and `_tokenMessenger`,\n     * on this TokenMessenger.\n     */\n    function _isRemoteTokenMessenger(uint32 _domain, bytes32 _tokenMessenger)\n        internal\n        view\n        returns (bool)\n    {\n        return\n            _tokenMessenger != bytes32(0) &amp;&amp;\n            remoteTokenMessengers[_domain] == _tokenMessenger;\n    }\n\n    /**\n     * @notice Returns true if the message sender is the local registered MessageTransmitter\n     * @return true if message sender is the registered local message transmitter\n     */\n    function _isLocalMessageTransmitter() internal view returns (bool) {\n        return\n            address(localMessageTransmitter) != address(0) &amp;&amp;\n            msg.sender == address(localMessageTransmitter);\n    }\n}\n</code></pre> <p>This contract and the interfaces, contracts, and libraries it relies on are stored in Circle's <code>evm-cctp-contracts</code> repository on GitHub.</p> <p>The functions provided by the Token Messenger contract are as follows:</p> <ul> <li> <p><code>depositForBurn</code> - deposits and burns tokens from the sender to be minted on the destination domain. Minted tokens will be transferred to <code>mintRecipient</code></p> Parameters <p><code>amount</code> uint256</p> <p>The amount of tokens to burn.</p> <p><code>destinationDomain</code> uint32</p> <p>The network where the token will be minted after burn.</p> <p><code>mintRecipient</code> bytes32</p> <p>Address of mint recipient on destination domain.</p> <p><code>burnToken</code> address</p> <p>Address of contract to burn deposited tokens, on local domain.</p> Returns <p><code>_nonce</code> uint64</p> <p>Unique nonce reserved by message.</p> Emits <p><code>DepositForBurn</code> - event emitted when <code>depositForBurn</code> is called. The <code>destinationCaller</code> is set to <code>bytes32(0)</code> to allow any address to call <code>receiveMessage</code> on the destination domain</p> Event Arguments <p><code>nonce</code> uint64 </p> <p>Unique nonce reserved by message (indexed).</p> <p><code>burnToken</code> address </p> <p>Address of token burnt on source domain.</p> <p><code>amount</code> uint256</p> <p>The deposit amount.</p> <p><code>depositor</code> address</p> <p>Address where deposit is transferred from.</p> <p><code>mintRecipient</code> bytes32</p> <p>Address receiving minted tokens on destination domain.</p> <p><code>destinationDomain</code> uint32 -</p> <p>Destination domain.</p> <p><code>destinationTokenMessenger</code> bytes32</p> <p>Address of <code>TokenMessenger</code> on destination domain.</p> <p><code>destinationCaller</code> bytes32</p> <p>Authorized caller of the <code>receiveMessage</code> function on the destination domain, if not equal to <code>bytes32(0)</code>. If equal to <code>bytes32(0)</code>, any address can call <code>receiveMessage</code>.</p> </li> <li> <p><code>depositForBurnWithCaller</code> - deposits and burns tokens from the sender to be minted on the destination domain. This method differs from <code>depositForBurn</code> in that the mint on the destination domain can only be called by the designated <code>destinationCaller</code> address</p> Parameters <p><code>amount</code> uint256</p> <p>The amount of tokens to burn.</p> <p><code>destinationDomain</code> uint32</p> <p>The network where the token will be minted after burn.</p> <p><code>mintRecipient</code> bytes32</p> <p>Address of mint recipient on destination domain.</p> <p><code>burnToken</code> address</p> <p>Address of contract to burn deposited tokens, on local domain.</p> <p><code>destinationCaller</code> bytes32</p> <p>Address of the caller on the destination domain who will trigger the mint.</p> Returns <p><code>_nonce</code> uint64</p> <p>Unique nonce reserved by message.</p> Emits <p><code>DepositForBurn</code> - event emitted when <code>depositForBurnWithCaller</code> is called</p> Event Arguments <p><code>nonce</code> uint64 </p> <p>Unique nonce reserved by message (indexed).</p> <p><code>burnToken</code> address </p> <p>Address of token burnt on source domain.</p> <p><code>amount</code> uint256</p> <p>The deposit amount.</p> <p><code>depositor</code> address</p> <p>Address where deposit is transferred from.</p> <p><code>mintRecipient</code> bytes32</p> <p>Address receiving minted tokens on destination domain.</p> <p><code>destinationDomain</code> uint32 -</p> <p>Destination domain.</p> <p><code>destinationTokenMessenger</code> bytes32</p> <p>Address of <code>TokenMessenger</code> on destination domain.</p> <p><code>destinationCaller</code> bytes32</p> <p>Authorized caller of the <code>receiveMessage</code> function on the destination domain, if not equal to <code>bytes32(0)</code>. If equal to <code>bytes32(0)</code>, any address can call <code>receiveMessage</code>.</p> </li> <li> <p><code>replaceDepositForBurn</code> \u2014 replaces a previous <code>BurnMessage</code> to modify the mint recipient and/or the destination caller. The replacement message reuses the <code>_nonce</code> created by the original message, which allows the original message's sender to update the details without requiring a new deposit</p> Parameters <p><code>originalMessage</code> bytes</p> <p>The original burn message to be replaced.</p> <p><code>originalAttestation</code> bytes</p> <p>The attestation of the original message.</p> <p><code>newDestinationCaller</code> bytes32</p> <p>The new caller on the destination domain, can be the same or updated.</p> <p><code>newMintRecipient</code> bytes32</p> <p>The new recipient for the minted tokens, can be the same or updated.</p> Returns <p>None.</p> Emits <p><code>DepositForBurn</code> - event emitted when <code>replaceDepositForBurn</code> is called. Note that the <code>destinationCaller</code> will reflect the new destination caller, which may be the same as the original destination caller, a new destination caller, or an empty destination caller (<code>bytes32(0)</code>), indicating that any destination caller is valid</p> Event Arguments <p><code>nonce</code> uint64 </p> <p>Unique nonce reserved by message (indexed).</p> <p><code>burnToken</code> address </p> <p>Address of token burnt on source domain.</p> <p><code>amount</code> uint256</p> <p>The deposit amount.</p> <p><code>depositor</code> address</p> <p>Address where deposit is transferred from.</p> <p><code>mintRecipient</code> bytes32</p> <p>Address receiving minted tokens on destination domain.</p> <p><code>destinationDomain</code> uint32 -</p> <p>Destination domain.</p> <p><code>destinationTokenMessenger</code> bytes32</p> <p>Address of <code>TokenMessenger</code> on destination domain.</p> <p><code>destinationCaller</code> bytes32</p> <p>Authorized caller of the <code>receiveMessage</code> function on the destination domain, if not equal to <code>bytes32(0)</code>. If equal to <code>bytes32(0)</code>, any address can call <code>receiveMessage</code>.</p> </li> <li> <p><code>handleReceiveMessage</code> - handles an incoming message received by the local <code>MessageTransmitter</code> and takes the appropriate action. For a burn message, it mints the associated token to the requested recipient on the local domain.</p> Note <p>Though this function can only be called by the local <code>MessageTransmitter</code>, it is included here as it emits the essential event for minting tokens and withdrawing to send to the recipient.</p> Parameters <p><code>remoteDomain</code> uint32</p> <p>The domain where the message originated.</p> <p><code>sender</code> bytes32</p> <p>The address of the sender of the message.</p> <p><code>messageBody</code> bytes</p> <p>The bytes making up the body of the message.</p> Returns <p><code>success</code> boolean</p> <p>Returns <code>true</code> if successful, otherwise, it returns <code>false</code>.</p> Emits <p><code>MintAndWithdraw</code> - event emitted when tokens are minted</p> Event arguments <p><code>localMinter</code> address</p> <p>Minter responsible for minting and burning tokens on the local domain.</p> <p><code>remoteDomain</code> uint32</p> <p>The domain where the message originated from.</p> <p><code>burnToken</code> address</p> <p>Address of contract to burn deposited tokens, on local domain.</p> <p><code>mintRecipient</code> address</p> <p>Recipient address of minted tokens (indexed).</p> <p><code>amount</code> uint256</p> <p>Amount of minted tokens.</p> </li> </ul>"},{"location":"build/contract-integrations/cctp/#message-transmitter-contract","title":"Message Transmitter Contract","text":"<p>The Message Transmitter contract ensures secure messaging across blockchain domains by managing message dispatch and tracking communication with events like <code>MessageSent</code> and <code>MessageReceived</code>. It uses a unique nonce for each message, which ensures proper validation, verifies attestation signatures, and prevents replay attacks.</p> <p>The contract supports flexible delivery options, allowing messages to be sent to a specific <code>destinationCaller</code> or broadcast more generally. It also includes domain-specific configurations to manage communication between chains.</p> <p>Additional features include replacing previously sent messages, setting maximum message body sizes, and verifying that messages are received only once per nonce to maintain network integrity.</p> Message Transmitter contract <pre><code>/*\n * Copyright (c) 2022, Circle Internet Financial Limited.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npragma solidity 0.7.6;\n\nimport \"@memview-sol/contracts/TypedMemView.sol\";\nimport \"./interfaces/IMessageTransmitter.sol\";\nimport \"./interfaces/IMessageHandler.sol\";\nimport \"./messages/Message.sol\";\nimport \"./roles/Pausable.sol\";\nimport \"./roles/Rescuable.sol\";\nimport \"./roles/Attestable.sol\";\n\n/**\n * @title MessageTransmitter\n * @notice Contract responsible for sending and receiving messages across chains.\n */\ncontract MessageTransmitter is\n    IMessageTransmitter,\n    Pausable,\n    Rescuable,\n    Attestable\n{\n    // ============ Events ============\n    /**\n     * @notice Emitted when a new message is dispatched\n     * @param message Raw bytes of message\n     */\n    event MessageSent(bytes message);\n\n    /**\n     * @notice Emitted when a new message is received\n     * @param caller Caller (msg.sender) on destination domain\n     * @param sourceDomain The source domain this message originated from\n     * @param nonce The nonce unique to this message\n     * @param sender The sender of this message\n     * @param messageBody message body bytes\n     */\n    event MessageReceived(\n        address indexed caller,\n        uint32 sourceDomain,\n        uint64 indexed nonce,\n        bytes32 sender,\n        bytes messageBody\n    );\n\n    /**\n     * @notice Emitted when max message body size is updated\n     * @param newMaxMessageBodySize new maximum message body size, in bytes\n     */\n    event MaxMessageBodySizeUpdated(uint256 newMaxMessageBodySize);\n\n    // ============ Libraries ============\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n    using Message for bytes29;\n\n    // ============ State Variables ============\n    // Domain of chain on which the contract is deployed\n    uint32 public immutable localDomain;\n\n    // Message Format version\n    uint32 public immutable version;\n\n    // Maximum size of message body, in bytes.\n    // This value is set by owner.\n    uint256 public maxMessageBodySize;\n\n    // Next available nonce from this source domain\n    uint64 public nextAvailableNonce;\n\n    // Maps a bytes32 hash of (sourceDomain, nonce) -&gt; uint256 (0 if unused, 1 if used)\n    mapping(bytes32 =&gt; uint256) public usedNonces;\n\n    // ============ Constructor ============\n    constructor(\n        uint32 _localDomain,\n        address _attester,\n        uint32 _maxMessageBodySize,\n        uint32 _version\n    ) Attestable(_attester) {\n        localDomain = _localDomain;\n        maxMessageBodySize = _maxMessageBodySize;\n        version = _version;\n    }\n\n    // ============ External Functions  ============\n    /**\n     * @notice Send the message to the destination domain and recipient\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination chain as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessage(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes calldata messageBody\n    ) external override whenNotPaused returns (uint64) {\n        bytes32 _emptyDestinationCaller = bytes32(0);\n        uint64 _nonce = _reserveAndIncrementNonce();\n        bytes32 _messageSender = Message.addressToBytes32(msg.sender);\n\n        _sendMessage(\n            destinationDomain,\n            recipient,\n            _emptyDestinationCaller,\n            _messageSender,\n            _nonce,\n            messageBody\n        );\n\n        return _nonce;\n    }\n\n    /**\n     * @notice Replace a message with a new message body and/or destination caller.\n     * @dev The `originalAttestation` must be a valid attestation of `originalMessage`.\n     * Reverts if msg.sender does not match sender of original message, or if the source domain of the original message\n     * does not match this MessageTransmitter's local domain.\n     * @param originalMessage original message to replace\n     * @param originalAttestation attestation of `originalMessage`\n     * @param newMessageBody new message body of replaced message\n     * @param newDestinationCaller the new destination caller, which may be the\n     * same as the original destination caller, a new destination caller, or an empty\n     * destination caller (bytes32(0), indicating that any destination caller is valid.)\n     */\n    function replaceMessage(\n        bytes calldata originalMessage,\n        bytes calldata originalAttestation,\n        bytes calldata newMessageBody,\n        bytes32 newDestinationCaller\n    ) external override whenNotPaused {\n        // Validate each signature in the attestation\n        _verifyAttestationSignatures(originalMessage, originalAttestation);\n\n        bytes29 _originalMsg = originalMessage.ref(0);\n\n        // Validate message format\n        _originalMsg._validateMessageFormat();\n\n        // Validate message sender\n        bytes32 _sender = _originalMsg._sender();\n        require(\n            msg.sender == Message.bytes32ToAddress(_sender),\n            \"Sender not permitted to use nonce\"\n        );\n\n        // Validate source domain\n        uint32 _sourceDomain = _originalMsg._sourceDomain();\n        require(\n            _sourceDomain == localDomain,\n            \"Message not originally sent from this domain\"\n        );\n\n        uint32 _destinationDomain = _originalMsg._destinationDomain();\n        bytes32 _recipient = _originalMsg._recipient();\n        uint64 _nonce = _originalMsg._nonce();\n\n        _sendMessage(\n            _destinationDomain,\n            _recipient,\n            newDestinationCaller,\n            _sender,\n            _nonce,\n            newMessageBody\n        );\n    }\n\n    /**\n     * @notice Send the message to the destination domain and recipient, for a specified `destinationCaller` on the\n     * destination domain.\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * WARNING: if the `destinationCaller` does not represent a valid address, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * sendMessage() should be preferred for use cases where a specific destination caller is not required.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination domain as bytes32\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessageWithCaller(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        bytes calldata messageBody\n    ) external override whenNotPaused returns (uint64) {\n        require(\n            destinationCaller != bytes32(0),\n            \"Destination caller must be nonzero\"\n        );\n\n        uint64 _nonce = _reserveAndIncrementNonce();\n        bytes32 _messageSender = Message.addressToBytes32(msg.sender);\n\n        _sendMessage(\n            destinationDomain,\n            recipient,\n            destinationCaller,\n            _messageSender,\n            _nonce,\n            messageBody\n        );\n\n        return _nonce;\n    }\n\n    /**\n     * @notice Receive a message. Messages with a given nonce\n     * can only be broadcast once for a (sourceDomain, destinationDomain)\n     * pair. The message body of a valid message is passed to the\n     * specified recipient for further processing.\n     *\n     * @dev Attestation format:\n     * A valid attestation is the concatenated 65-byte signature(s) of exactly\n     * `thresholdSignature` signatures, in increasing order of attester address.\n     * ***If the attester addresses recovered from signatures are not in\n     * increasing order, signature verification will fail.***\n     * If incorrect number of signatures or duplicate signatures are supplied,\n     * signature verification will fail.\n     *\n     * Message format:\n     * Field                 Bytes      Type       Index\n     * version               4          uint32     0\n     * sourceDomain          4          uint32     4\n     * destinationDomain     4          uint32     8\n     * nonce                 8          uint64     12\n     * sender                32         bytes32    20\n     * recipient             32         bytes32    52\n     * messageBody           dynamic    bytes      84\n     * @param message Message bytes\n     * @param attestation Concatenated 65-byte signature(s) of `message`, in increasing order\n     * of the attester address recovered from signatures.\n     * @return success bool, true if successful\n     */\n    function receiveMessage(bytes calldata message, bytes calldata attestation)\n        external\n        override\n        whenNotPaused\n        returns (bool success)\n    {\n        // Validate each signature in the attestation\n        _verifyAttestationSignatures(message, attestation);\n\n        bytes29 _msg = message.ref(0);\n\n        // Validate message format\n        _msg._validateMessageFormat();\n\n        // Validate domain\n        require(\n            _msg._destinationDomain() == localDomain,\n            \"Invalid destination domain\"\n        );\n\n        // Validate destination caller\n        if (_msg._destinationCaller() != bytes32(0)) {\n            require(\n                _msg._destinationCaller() ==\n                    Message.addressToBytes32(msg.sender),\n                \"Invalid caller for message\"\n            );\n        }\n\n        // Validate version\n        require(_msg._version() == version, \"Invalid message version\");\n\n        // Validate nonce is available\n        uint32 _sourceDomain = _msg._sourceDomain();\n        uint64 _nonce = _msg._nonce();\n        bytes32 _sourceAndNonce = _hashSourceAndNonce(_sourceDomain, _nonce);\n        require(usedNonces[_sourceAndNonce] == 0, \"Nonce already used\");\n        // Mark nonce used\n        usedNonces[_sourceAndNonce] = 1;\n\n        // Handle receive message\n        bytes32 _sender = _msg._sender();\n        bytes memory _messageBody = _msg._messageBody().clone();\n        require(\n            IMessageHandler(Message.bytes32ToAddress(_msg._recipient()))\n                .handleReceiveMessage(_sourceDomain, _sender, _messageBody),\n            \"handleReceiveMessage() failed\"\n        );\n\n        // Emit MessageReceived event\n        emit MessageReceived(\n            msg.sender,\n            _sourceDomain,\n            _nonce,\n            _sender,\n            _messageBody\n        );\n        return true;\n    }\n\n    /**\n     * @notice Sets the max message body size\n     * @dev This value should not be reduced without good reason,\n     * to avoid impacting users who rely on large messages.\n     * @param newMaxMessageBodySize new max message body size, in bytes\n     */\n    function setMaxMessageBodySize(uint256 newMaxMessageBodySize)\n        external\n        onlyOwner\n    {\n        maxMessageBodySize = newMaxMessageBodySize;\n        emit MaxMessageBodySizeUpdated(maxMessageBodySize);\n    }\n\n    // ============ Internal Utils ============\n    /**\n     * @notice Send the message to the destination domain and recipient. If `_destinationCaller` is not equal to bytes32(0),\n     * the message can only be received on the destination chain when called by `_destinationCaller`.\n     * @dev Format the message and emit `MessageSent` event with message information.\n     * @param _destinationDomain Domain of destination chain\n     * @param _recipient Address of message recipient on destination domain as bytes32\n     * @param _destinationCaller caller on the destination domain, as bytes32\n     * @param _sender message sender, as bytes32\n     * @param _nonce nonce reserved for message\n     * @param _messageBody Raw bytes content of message\n     */\n    function _sendMessage(\n        uint32 _destinationDomain,\n        bytes32 _recipient,\n        bytes32 _destinationCaller,\n        bytes32 _sender,\n        uint64 _nonce,\n        bytes calldata _messageBody\n    ) internal {\n        // Validate message body length\n        require(\n            _messageBody.length &lt;= maxMessageBodySize,\n            \"Message body exceeds max size\"\n        );\n\n        require(_recipient != bytes32(0), \"Recipient must be nonzero\");\n\n        // serialize message\n        bytes memory _message = Message._formatMessage(\n            version,\n            localDomain,\n            _destinationDomain,\n            _nonce,\n            _sender,\n            _recipient,\n            _destinationCaller,\n            _messageBody\n        );\n\n        // Emit MessageSent event\n        emit MessageSent(_message);\n    }\n\n    /**\n     * @notice hashes `_source` and `_nonce`.\n     * @param _source Domain of chain where the transfer originated\n     * @param _nonce The unique identifier for the message from source to\n              destination\n     * @return hash of source and nonce\n     */\n    function _hashSourceAndNonce(uint32 _source, uint64 _nonce)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(_source, _nonce));\n    }\n\n    /**\n     * Reserve and increment next available nonce\n     * @return nonce reserved\n     */\n    function _reserveAndIncrementNonce() internal returns (uint64) {\n        uint64 _nonceReserved = nextAvailableNonce;\n        nextAvailableNonce = nextAvailableNonce + 1;\n        return _nonceReserved;\n    }\n}\n</code></pre> <p>This contract and the interfaces, contracts, and libraries it relies on are stored in Circle's <code>evm-cctp-contracts</code> repository on GitHub.</p> <p>The functions provided by the Message Transmitter contract are as follows:</p> <ul> <li> <p><code>receiveMessage</code> \u2014 processes and validates an incoming message and its attestation. If valid, it triggers further action based on the message body</p> Parameters <p><code>message</code> bytes</p> <p>The message to be processed, including details such as sender, recipient, and message body.</p> <p><code>attestation</code> bytes</p> <p>Concatenated 65-byte signature(s) that attest to the validity of the <code>message</code>.</p> Returns <p><code>success</code> boolean</p> <p>Returns <code>true</code> if successful, otherwise, returns <code>false</code>.</p> Emits <p><code>MessageReceived</code> - event emitted when a new message is received</p> Event arguments <p><code>caller</code> address</p> <p>Caller on destination domain.</p> <p><code>sourceDomain</code> uint32</p> <p>The source domain this message originated from.</p> <p><code>nonce</code> uint64</p> <p>Nonce unique to this message (indexed).</p> <p><code>sender</code> bytes32</p> <p>Sender of this message.</p> <p><code>messageBody</code> bytes</p> <p>The body of the message.</p> </li> <li> <p><code>sendMessage</code> \u2014 sends a message to the destination domain and recipient. It increments the <code>nonce</code>, assigns a unique <code>nonce</code> to the message, and emits a <code>MessageSent</code> event</p> Parameters <p><code>destinationDomain</code> uint32</p> <p>The target blockchain network where the message is to be sent.</p> <p><code>recipient</code> bytes32</p> <p>The recipient's address on the destination domain.</p> <p><code>messageBody</code> bytes</p> <p>The raw bytes content of the message.</p> Returns <p><code>nonce</code> uint64</p> <p>Nonce unique to this message.</p> Emits </li> <li> <p><code>sendMessageWithCaller</code> \u2014  sends a message to the destination domain and recipient, requiring a specific caller to trigger the message on the target chain. It increments the <code>nonce</code>, assigns a unique <code>nonce</code> to the message, and emits a <code>MessageSent</code> event</p> Parameters <p><code>destinationDomain</code> uint32</p> <p>The target blockchain network where the message is to be sent.</p> <p><code>recipient</code> bytes32</p> <p>The recipient's address on the destination domain.</p> <p><code>destinationCaller</code> bytes32 </p> <p>The caller on the destination domain.</p> <p><code>messageBody</code> bytes</p> <p>The raw bytes content of the message.</p> Returns <p><code>nonce</code> uint64</p> <p>Nonce unique to this message.</p> Emits </li> <li> <p><code>replaceMessage</code> \u2014 replaces an original message with a new message body and/or updates the destination caller. The replacement message reuses the <code>_nonce</code> created by the original message</p> Parameters <p><code>originalMessage</code> bytes</p> <p>The original message to be replaced.</p> <p><code>originalAttestation</code> bytes</p> <p>Attestation verifying the original message.</p> <p><code>newMessageBody</code> bytes</p> <p>The new content for the replaced message.</p> <p><code>newDestinationCaller</code> bytes32</p> <p>The new destination caller, which may be the same as the original destination caller, a new destination caller, or an empty destination caller (<code>bytes32(0)</code>), indicating that any destination caller is valid.</p> Returns <p>None.</p> Emits </li> </ul>"},{"location":"build/contract-integrations/cctp/#token-minter-contract","title":"Token Minter Contract","text":"<p>The Token Minter contract manages the minting and burning of tokens across different blockchain domains. It maintains a registry that links local tokens to their corresponding remote tokens, ensuring that tokens maintain a 1:1 exchange rate across domains.</p> <p>The contract restricts minting and burning functions to a designated Token Messenger, which ensures secure and reliable cross-chain operations. When tokens are burned on a remote domain, an equivalent amount is minted on the local domain for a specified recipient, and vice versa.</p> <p>To enhance control and flexibility, the contract includes mechanisms to pause operations, set burn limits, and update the Token Controller, which governs token minting permissions. Additionally, it provides functionality to add or remove the local Token Messenger and retrieve the local token address associated with a remote token.</p> Token Minter contract <pre><code>/*\n * Copyright (c) 2022, Circle Internet Financial Limited.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npragma solidity 0.7.6;\n\nimport \"./interfaces/ITokenMinter.sol\";\nimport \"./interfaces/IMintBurnToken.sol\";\nimport \"./roles/Pausable.sol\";\nimport \"./roles/Rescuable.sol\";\nimport \"./roles/TokenController.sol\";\nimport \"./TokenMessenger.sol\";\n\n/**\n * @title TokenMinter\n * @notice Token Minter and Burner\n * @dev Maintains registry of local mintable tokens and corresponding tokens on remote domains.\n * This registry can be used by caller to determine which token on local domain to mint for a\n * burned token on a remote domain, and vice versa.\n * It is assumed that local and remote tokens are fungible at a constant 1:1 exchange rate.\n */\ncontract TokenMinter is ITokenMinter, TokenController, Pausable, Rescuable {\n    // ============ Events ============\n    /**\n     * @notice Emitted when a local TokenMessenger is added\n     * @param localTokenMessenger address of local TokenMessenger\n     * @notice Emitted when a local TokenMessenger is added\n     */\n    event LocalTokenMessengerAdded(address localTokenMessenger);\n\n    /**\n     * @notice Emitted when a local TokenMessenger is removed\n     * @param localTokenMessenger address of local TokenMessenger\n     * @notice Emitted when a local TokenMessenger is removed\n     */\n    event LocalTokenMessengerRemoved(address localTokenMessenger);\n\n    // ============ State Variables ============\n    // Local TokenMessenger with permission to call mint and burn on this TokenMinter\n    address public localTokenMessenger;\n\n    // ============ Modifiers ============\n    /**\n     * @notice Only accept messages from the registered message transmitter on local domain\n     */\n    modifier onlyLocalTokenMessenger() {\n        require(_isLocalTokenMessenger(), \"Caller not local TokenMessenger\");\n        _;\n    }\n\n    // ============ Constructor ============\n    /**\n     * @param _tokenController Token controller address\n     */\n    constructor(address _tokenController) {\n        _setTokenController(_tokenController);\n    }\n\n    // ============ External Functions  ============\n    /**\n     * @notice Mints `amount` of local tokens corresponding to the\n     * given (`sourceDomain`, `burnToken`) pair, to `to` address.\n     * @dev reverts if the (`sourceDomain`, `burnToken`) pair does not\n     * map to a nonzero local token address. This mapping can be queried using\n     * getLocalToken().\n     * @param sourceDomain Source domain where `burnToken` was burned.\n     * @param burnToken Burned token address as bytes32.\n     * @param to Address to receive minted tokens, corresponding to `burnToken`,\n     * on this domain.\n     * @param amount Amount of tokens to mint. Must be less than or equal\n     * to the minterAllowance of this TokenMinter for given `_mintToken`.\n     * @return mintToken token minted.\n     */\n    function mint(\n        uint32 sourceDomain,\n        bytes32 burnToken,\n        address to,\n        uint256 amount\n    )\n        external\n        override\n        whenNotPaused\n        onlyLocalTokenMessenger\n        returns (address mintToken)\n    {\n        address _mintToken = _getLocalToken(sourceDomain, burnToken);\n        require(_mintToken != address(0), \"Mint token not supported\");\n        IMintBurnToken _token = IMintBurnToken(_mintToken);\n\n        require(_token.mint(to, amount), \"Mint operation failed\");\n        return _mintToken;\n    }\n\n    /**\n     * @notice Burn tokens owned by this TokenMinter.\n     * @param burnToken burnable token address.\n     * @param burnAmount amount of tokens to burn. Must be\n     * &gt; 0, and &lt;= maximum burn amount per message.\n     */\n    function burn(address burnToken, uint256 burnAmount)\n        external\n        override\n        whenNotPaused\n        onlyLocalTokenMessenger\n        onlyWithinBurnLimit(burnToken, burnAmount)\n    {\n        IMintBurnToken _token = IMintBurnToken(burnToken);\n        _token.burn(burnAmount);\n    }\n\n    /**\n     * @notice Add TokenMessenger for the local domain. Only this TokenMessenger\n     * has permission to call mint() and burn() on this TokenMinter.\n     * @dev Reverts if a TokenMessenger is already set for the local domain.\n     * @param newLocalTokenMessenger The address of the new TokenMessenger on the local domain.\n     */\n    function addLocalTokenMessenger(address newLocalTokenMessenger)\n        external\n        onlyOwner\n    {\n        require(\n            newLocalTokenMessenger != address(0),\n            \"Invalid TokenMessenger address\"\n        );\n\n        require(\n            localTokenMessenger == address(0),\n            \"Local TokenMessenger already set\"\n        );\n\n        localTokenMessenger = newLocalTokenMessenger;\n\n        emit LocalTokenMessengerAdded(localTokenMessenger);\n    }\n\n    /**\n     * @notice Remove the TokenMessenger for the local domain.\n     * @dev Reverts if the TokenMessenger of the local domain is not set.\n     */\n    function removeLocalTokenMessenger() external onlyOwner {\n        address _localTokenMessengerBeforeRemoval = localTokenMessenger;\n        require(\n            _localTokenMessengerBeforeRemoval != address(0),\n            \"No local TokenMessenger is set\"\n        );\n\n        delete localTokenMessenger;\n        emit LocalTokenMessengerRemoved(_localTokenMessengerBeforeRemoval);\n    }\n\n    /**\n     * @notice Set tokenController to `newTokenController`, and\n     * emit `SetTokenController` event.\n     * @dev newTokenController must be nonzero.\n     * @param newTokenController address of new token controller\n     */\n    function setTokenController(address newTokenController)\n        external\n        override\n        onlyOwner\n    {\n        _setTokenController(newTokenController);\n    }\n\n    /**\n     * @notice Get the local token address associated with the given\n     * remote domain and token.\n     * @param remoteDomain Remote domain\n     * @param remoteToken Remote token\n     * @return local token address\n     */\n    function getLocalToken(uint32 remoteDomain, bytes32 remoteToken)\n        external\n        view\n        override\n        returns (address)\n    {\n        return _getLocalToken(remoteDomain, remoteToken);\n    }\n\n    // ============ Internal Utils ============\n    /**\n     * @notice Returns true if the message sender is the registered local TokenMessenger\n     * @return True if the message sender is the registered local TokenMessenger\n     */\n    function _isLocalTokenMessenger() internal view returns (bool) {\n        return\n            address(localTokenMessenger) != address(0) &amp;&amp;\n            msg.sender == address(localTokenMessenger);\n    }\n}\n</code></pre> <p>This contract and the interfaces and contracts it relies on are stored in Circle's <code>evm-cctp-contracts</code> repository on GitHub.</p> <p>Most of the methods of the Token Minter contract can be called only by the registered Token Messenger. However, there is one publicly accessible method, a public view function that allows anyone to query the local token associated with a remote domain and token.</p> <ul> <li> <p><code>getLocalToken</code> \u2014 a read-only function that returns the local token address associated with a given remote domain and token</p> Parameters <p><code>remoteDomain</code> uint32</p> <p>The remote blockchain domain where the token resides.</p> <p><code>remoteToken</code> bytes32</p> <p>The address of the token on the remote domain.</p> Returns <p>address</p> <p>The local token address.</p> </li> </ul>"},{"location":"build/contract-integrations/cctp/#how-to-interact-with-cctp-contracts","title":"How to Interact with CCTP Contracts","text":"<p>Before writing your own contracts, it's essential to understand the key functions and events of the Wormhole CCTP contracts. The primary functionality revolves around the following:</p> <ul> <li>Sending tokens with a message payload - initiating a cross-chain transfer of Circle-supported assets along with a message payload to a specific target address on the target chain</li> <li>Receiving tokens with a message payload - validating messages received from other chains via Wormhole and then minting the tokens for the recipient</li> </ul>"},{"location":"build/contract-integrations/cctp/#sending-tokens-and-messages","title":"Sending Tokens and Messages","text":"<p>To initiate a cross-chain transfer, you must call the <code>transferTokensWithPayload</code> method of Wormhole's Circle Integration (CCTP) contract. Once you have initiated a transfer, you must fetch the attested Wormhole message and parse the transaction logs to locate a transfer message emitted by the Circle Bridge contract. Then, a request must be sent to Circle's off-chain process with the transfer message to grab the attestation from the process's response, which validates the token mint on the target chain.</p> <p>To streamline this process, you can use the Wormhole Solidity SDK, which exposes the <code>WormholeRelayerSDK.sol</code> contract, including the <code>CCTPSender</code> abstract contract. By inheriting this contract, you can transfer USDC while automatically relaying the message payload to the destination chain via a Wormhole-deployed relayer.</p> CCTP Sender contract <pre><code>abstract contract CCTPSender is CCTPBase {\n    uint8 internal constant CONSISTENCY_LEVEL_FINALIZED = 15;\n\n    using CCTPMessageLib for *;\n\n    mapping(uint16 =&gt; uint32) public chainIdToCCTPDomain;\n\n    /**\n     * Sets the CCTP Domain corresponding to chain 'chain' to be 'cctpDomain'\n     * So that transfers of USDC to chain 'chain' use the target CCTP domain 'cctpDomain'\n     *\n     * This action can only be performed by 'cctpConfigurationOwner', who is set to be the deployer\n     *\n     * Currently, cctp domains are:\n     * Ethereum: Wormhole chain id 2, cctp domain 0\n     * Avalanche: Wormhole chain id 6, cctp domain 1\n     * Optimism: Wormhole chain id 24, cctp domain 2\n     * Arbitrum: Wormhole chain id 23, cctp domain 3\n     * Base: Wormhole chain id 30, cctp domain 6\n     *\n     * These can be set via:\n     * setCCTPDomain(2, 0);\n     * setCCTPDomain(6, 1);\n     * setCCTPDomain(24, 2);\n     * setCCTPDomain(23, 3);\n     * setCCTPDomain(30, 6);\n     */\n    function setCCTPDomain(uint16 chain, uint32 cctpDomain) public {\n        require(\n            msg.sender == cctpConfigurationOwner,\n            \"Not allowed to set CCTP Domain\"\n        );\n        chainIdToCCTPDomain[chain] = cctpDomain;\n    }\n\n    function getCCTPDomain(uint16 chain) internal view returns (uint32) {\n        return chainIdToCCTPDomain[chain];\n    }\n\n    /**\n     * transferUSDC wraps common boilerplate for sending tokens to another chain using IWormholeRelayer\n     * - approves the Circle TokenMessenger contract to spend 'amount' of USDC\n     * - calls Circle's 'depositForBurnWithCaller'\n     * - returns key for inclusion in WormholeRelayer `additionalVaas` argument\n     *\n     * Note: this requires that only the targetAddress can redeem transfers.\n     *\n     */\n\n    function transferUSDC(\n        uint256 amount,\n        uint16 targetChain,\n        address targetAddress\n    ) internal returns (MessageKey memory) {\n        IERC20(USDC).approve(address(circleTokenMessenger), amount);\n        bytes32 targetAddressBytes32 = addressToBytes32CCTP(targetAddress);\n        uint64 nonce = circleTokenMessenger.depositForBurnWithCaller(\n            amount,\n            getCCTPDomain(targetChain),\n            targetAddressBytes32,\n            USDC,\n            targetAddressBytes32\n        );\n        return\n            MessageKey(\n                CCTPMessageLib.CCTP_KEY_TYPE,\n                abi.encodePacked(getCCTPDomain(wormhole.chainId()), nonce)\n            );\n    }\n\n    // Publishes a CCTP transfer of 'amount' of USDC\n    // and requests a delivery of the transfer along with 'payload' to 'targetAddress' on 'targetChain'\n    //\n    // The second step is done by publishing a wormhole message representing a request\n    // to call 'receiveWormholeMessages' on the address 'targetAddress' on chain 'targetChain'\n    // with the payload 'abi.encode(amount, payload)'\n    // (and we encode the amount so it can be checked on the target chain)\n    function sendUSDCWithPayloadToEvm(\n        uint16 targetChain,\n        address targetAddress,\n        bytes memory payload,\n        uint256 receiverValue,\n        uint256 gasLimit,\n        uint256 amount\n    ) internal returns (uint64 sequence) {\n        MessageKey[] memory messageKeys = new MessageKey[](1);\n        messageKeys[0] = transferUSDC(amount, targetChain, targetAddress);\n\n        bytes memory userPayload = abi.encode(amount, payload);\n        address defaultDeliveryProvider = wormholeRelayer\n            .getDefaultDeliveryProvider();\n\n        (uint256 cost, ) = wormholeRelayer.quoteEVMDeliveryPrice(\n            targetChain,\n            receiverValue,\n            gasLimit\n        );\n\n        sequence = wormholeRelayer.sendToEvm{value: cost}(\n            targetChain,\n            targetAddress,\n            userPayload,\n            receiverValue,\n            0,\n            gasLimit,\n            targetChain,\n            address(0x0),\n            defaultDeliveryProvider,\n            messageKeys,\n            CONSISTENCY_LEVEL_FINALIZED\n        );\n    }\n\n    function addressToBytes32CCTP(address addr) private pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n}\n</code></pre> <p>The <code>CCTPSender</code> abstract contract exposes the <code>sendUSDCWithPayloadToEvm</code> function. This function publishes a CCTP transfer of the provided <code>amount</code> of USDC and requests that the transfer be delivered along with a <code>payload</code> to the specified <code>targetAddress</code> on the <code>targetChain</code>.</p> <pre><code>function sendUSDCWithPayloadToEvm(\n    uint16 targetChain,\n    address targetAddress,\n    bytes memory payload,\n    uint256 receiverValue,\n    uint256 gasLimit,\n    uint256 amount\n) internal returns (uint64 sequence) \n</code></pre> Parameters <p><code>targetChain</code> uint16</p> <p>The target chain for the transfer.</p> <p><code>targetAddress</code> address</p> <p>The target address for the transfer.</p> <p><code>payload</code> bytes</p> <p>Arbitrary payload to be delivered to the target chain via Wormhole.</p> <p><code>gasLimit</code> uint256</p> <p>The gas limit with which to call <code>targetAddress</code>.</p> <p><code>amount</code> uint256</p> <p>The amount of USDC to transfer.</p> Returns <p><code>sequence</code> uint64</p> <p>Sequence number of the published VAA containing the delivery instructions.</p> <p>When the <code>sendUSDCWithPayloadToEvm</code> function is called, the following series of actions are executed:</p> <ol> <li> <p>USDC transfer initiation:</p> <ul> <li>The Circle Token Messenger contract is approved to spend the specified amount of USDC.</li> <li>The <code>depositForBurnWithCaller</code> function of the Token Messenger contract is invoked</li> <li>A key is returned, which is to be provided to the Wormhole relayer for message delivery</li> </ul> </li> <li> <p>Message encoding - the message <code>payload</code> is encoded for transmission via the Wormhole relayer. The encoded value also includes the <code>amount</code> so that it can be checked on the target chain</p> </li> <li>Retrieving delivery provider - the current default delivery provider's address is retrieved</li> <li>Cost calculation - the transfer cost is calculated using the Wormhole relayer's <code>quoteEVMDeliveryPrice</code> function</li> <li> <p>Message dispatch:</p> <ul> <li>The <code>sendToEvm</code> function of the Wormhole relayer is called with the encoded payload, the delivery provider's address, and the arguments passed to <code>sendUSDCWithPayloadToEvm</code></li> <li>The function must be called with <code>msg.value</code> set to the previously calculated cost (from step 4)</li> <li>This function publishes an instruction for the delivery provider to relay the payload and VAAs specified by the key (from step 1) to the target address on the target chain</li> </ul> </li> </ol> <p>A simple example implementation is as follows:</p> <pre><code>function sendCrossChainDeposit(\n    uint16 targetChain,\n    address targetAddress,\n    address recipient,\n    uint256 amount,\n    uint256,\n    gasLimit\n) public payable {\n    uint256 cost = quoteCrossChainDeposit(targetChain);\n    require(\n        msg.value == cost,\n        \"msg.value must be quoteCrossChainDeposit(targetChain)\"\n    );\n\n    IERC20(USDC).transferFrom(msg.sender, address(this), amount);\n\n    bytes memory payload = abi.encode(recipient);\n    sendUSDCWithPayloadToEvm(\n        targetChain,\n        targetAddress, // address (on targetChain) to send token and payload to\n        payload,\n        0, // receiver value\n        gasLimit,\n        amount\n    );\n}\n</code></pre> <p>The above example sends a specified amount of USDC and the recipient's address as a payload to a target contract on another chain, ensuring that the correct cost is provided for the cross-chain transfer.</p>"},{"location":"build/contract-integrations/cctp/#receiving-tokens-and-messages","title":"Receiving Tokens and Messages","text":"<p>To complete the cross-chain transfer, you must invoke the <code>redeemTokensWithPayload</code> function on the target Wormhole Circle Integration contract. This function verifies the message's authenticity, decodes the payload, confirms the recipient and sender, checks message delivery, and then calls the <code>receiveMessage</code> function of the Message Transmitter contract.</p> <p>Using the Wormhole-deployed relayer automatically triggers the <code>receiveWormholeMessages</code> function. This function is defined in the <code>WormholeRelayerSDK.sol</code> contract from the Wormhole Solidity SDK and is implemented within the <code>CCTPReceiver</code> abstract contract.</p> CCTP Receiver contract <pre><code>abstract contract CCTPReceiver is CCTPBase {\n    function redeemUSDC(\n        bytes memory cctpMessage\n    ) internal returns (uint256 amount) {\n        (bytes memory message, bytes memory signature) = abi.decode(\n            cctpMessage,\n            (bytes, bytes)\n        );\n        uint256 beforeBalance = IERC20(USDC).balanceOf(address(this));\n        circleMessageTransmitter.receiveMessage(message, signature);\n        return IERC20(USDC).balanceOf(address(this)) - beforeBalance;\n    }\n\n    function receiveWormholeMessages(\n        bytes memory payload,\n        bytes[] memory additionalMessages,\n        bytes32 sourceAddress,\n        uint16 sourceChain,\n        bytes32 deliveryHash\n    ) external payable {\n        // Currently, 'sendUSDCWithPayloadToEVM' only sends one CCTP transfer\n        // That can be modified if the integrator desires to send multiple CCTP transfers\n        // in which case the following code would have to be modified to support\n        // redeeming these multiple transfers and checking that their 'amount's are accurate\n        require(\n            additionalMessages.length &lt;= 1,\n            \"CCTP: At most one Message is supported\"\n        );\n\n        uint256 amountUSDCReceived;\n        if (additionalMessages.length == 1)\n            amountUSDCReceived = redeemUSDC(additionalMessages[0]);\n\n        (uint256 amount, bytes memory userPayload) = abi.decode(\n            payload,\n            (uint256, bytes)\n        );\n\n        // Check that the correct amount was received\n        // It is important to verify that the 'USDC' sent in by the relayer is the same amount\n        // that the sender sent in on the source chain\n        require(amount == amountUSDCReceived, \"Wrong amount received\");\n\n        receivePayloadAndUSDC(\n            userPayload,\n            amountUSDCReceived,\n            sourceAddress,\n            sourceChain,\n            deliveryHash\n        );\n    }\n\n    // Implement this function to handle in-bound deliveries that include a CCTP transfer\n    function receivePayloadAndUSDC(\n        bytes memory payload,\n        uint256 amountUSDCReceived,\n        bytes32 sourceAddress,\n        uint16 sourceChain,\n        bytes32 deliveryHash\n    ) internal virtual {}\n}\n</code></pre> <p>Although you do not need to interact with the\u00a0<code>receiveWormholeMessages</code>\u00a0function directly, it's important to understand what it does. This function processes cross-chain messages and USDC transfers via Wormhole's Circle (CCTP) Bridge. Here's a summary of what it does:</p> <ol> <li>Validate additional messages - the function checks that there is at most one CCTP transfer message in the <code>additionalMessages</code> array, as it currently only supports processing a single CCTP transfer</li> <li>Redeem USDC:<ul> <li>If there is a CCTP message, it calls the <code>redeemUSDC</code> function of the <code>CCTPReceiver</code> contract to decode and redeem the USDC</li> <li>This results in the call of the <code>receiveMessage</code> function of Circle's Message Transmitter contract to redeem the USDC based on the provided message and signature</li> <li>The amount of USDC received is calculated by subtracting the contract's previous balance from the current balance after redeeming the USDC</li> </ul> </li> <li>Decode payload - the incoming payload is decoded, extracting both the expected amount of USDC and a <code>userPayload</code> (which could be any additional data)</li> <li>Verify the amount - it ensures that the amount of USDC received matches the amount encoded in the payload. If the amounts don't match, the transaction is reverted</li> <li>Handle the payload and USDC - after verifying the amounts, <code>receivePayloadAndUSDC</code> is called, which is meant to handle the actual logic for processing the received payload and USDC transfer</li> </ol> <p>You'll need to implement the <code>receivePayloadAndUSDC</code> function to transfer the USDC and handle the payload as your application needs. A simple example implementation is as follows:</p> <pre><code>function receivePayloadAndUSDC(\n    bytes memory payload,\n    uint256 amountUSDCReceived,\n    bytes32, // sourceAddress\n    uint16, // sourceChain\n    bytes32 // deliveryHash\n) internal override onlyWormholeRelayer {\n    address recipient = abi.decode(payload, (address));\n\n    IERC20(USDC).transfer(recipient, amountUSDCReceived);\n}\n</code></pre>"},{"location":"build/contract-integrations/cctp/#complete-example","title":"Complete Example","text":"<p>To view a complete example of creating a contract that integrates with Wormhole's CCTP contracts to send and receive USDC cross-chain, check out the Hello USDC repository on GitHub.</p>"},{"location":"build/contract-integrations/core-contracts/","title":"Get Started with Core Contracts","text":""},{"location":"build/contract-integrations/core-contracts/#introduction","title":"Introduction","text":"<p>Wormhole's Core Contracts, deployed on each supported blockchain network, enable the fundamental operations of sending and receiving cross-chain messages.</p> <p>While the implementation details of the Core Contracts varies by network, the core functionality remains consistent across chains. Each version of the Core Contract facilitates secure and reliable cross-chain communication, ensuring that developers can effectively publish and verify messages.</p> <p>This guide will walk you through the variations and key methods of the Core Contracts, providing you with the knowledge needed to integrate them into your cross-chain contracts. To learn more about Core Contracts' features and how it works, please refer to the\u00a0Core Contracts\u00a0page in the Learn section.</p>"},{"location":"build/contract-integrations/core-contracts/#prerequisites","title":"Prerequisites","text":"<p>To interact with the Wormhole Core Contract, you'll need the following:</p> <ul> <li>The address of the Core Contract on the chains you're deploying your contract on</li> <li>The Wormhole chain ID of the chains you're deploying your contract on</li> <li>The consistency levels (required finality) for the chains you're deploying your contract on</li> </ul>"},{"location":"build/contract-integrations/core-contracts/#how-to-interact-with-core-contracts","title":"How to Interact with Core Contracts","text":"<p>Before writing your own contracts, it's essential to understand the key functions and events of the Wormhole Core Contracts. The primary functionality revolves around:</p> <ul> <li>Sending messages - submitting messages to the Wormhole network for cross-chain communication</li> <li>Receiving and verifying messages - validating messages received from other chains via the Wormhole network</li> </ul> <p>While the implementation details of the Core Contracts vary by network, the core functionality remains consistent across chains.</p>"},{"location":"build/contract-integrations/core-contracts/#sending-messages","title":"Sending Messages","text":"<p>To send a message, regardless of the environment or chain, the Core Contract is invoked with a message argument from an emitter. This emitter might be your contract or an existing application such as the Token Bridge or NFT Bridge.</p> EVMSolana <p>The <code>IWormhole.sol</code> interface provides the <code>publishMessage</code> function, which can be used to publish a message directly to the Core Contract:</p> <pre><code>function publishMessage(\n    uint32 nonce,\n    bytes memory payload,\n    uint8 consistencyLevel\n) external payable returns (uint64 sequence);\n</code></pre> Parameters <p><code>nonce</code> uint32</p> <p>A free integer field that can be used however you like. Note that changing the <code>nonce</code> will result in a different digest.</p> <p><code>payload</code> bytes memory</p> <p>The content of the emitted message. Due to the constraints of individual blockchains, it may be capped to a certain maximum length.</p> <p><code>consistencyLevel</code> uint8</p> <p>A value that defines the required level of finality that must be reached before the Guardians will observe and attest to emitted events.</p> Returns <p><code>sequence</code> uint64</p> <p>A unique number that increments for every message for a given emitter (and implicitly chain). This, combined with the emitter address and emitter chain ID, allows the VAA for this message to be queried from the Wormholescan API.</p> Example <pre><code>IWormhole wormhole = IWormhole(wormholeAddr);\n\n// Get the fee for publishing a message\nuint256 wormholeFee = wormhole.messageFee();\n\n// Check fee and send parameters\n\n// Create the HelloWorldMessage struct\nHelloWorldMessage memory parsedMessage = HelloWorldMessage({\n    payloadID: uint8(1),\n    message: helloWorldMessage\n});\n\n// Encode the HelloWorldMessage struct into bytes\nbytes memory encodedMessage = encodeMessage(parsedMessage);\n\n// Send the HelloWorld message by calling publishMessage on the\n// wormhole core contract and paying the Wormhole protocol fee.\nmessageSequence = wormhole.publishMessage{value: wormholeFee}(\n    0, // batchID\n    encodedMessage,\n    wormholeFinality()\n);\n</code></pre> <p>View the complete Hello World example in the Wormhole Scaffolding repository on GitHub.</p> <p>The <code>wormhole_anchor_sdk::wormhole</code> module and the Wormhole program account can be used to pass a message directly to the Core Contract via the <code>wormhole::post_message</code> function:</p> <pre><code>pub fn post_message&lt;'info&gt;(\n    ctx: CpiContext&lt;'_, '_, '_, 'info, PostMessage&lt;'info&gt;&gt;,\n    batch_id: u32,\n    payload: Vec&lt;u8&gt;,\n    finality: Finality\n) -&gt; Result&lt;()&gt;\n</code></pre> Parameters <p><code>ctx</code> CpiContext&lt;'_, '_, '_, 'info, PostMessage&lt;'info&gt;&gt; </p> <p>Provides the necessary context for executing the function, including the accounts and program information required for the Cross-Program Invocation (CPI).</p> Type <code>pub struct CpiContext&lt;'a, 'b, 'c, 'info, T&gt;</code> <pre><code>pub struct CpiContext&lt;'a, 'b, 'c, 'info, T&gt;\nwhere\n    T: ToAccountMetas + ToAccountInfos&lt;'info&gt;,\n{\n    pub accounts: T,\n    pub remaining_accounts: Vec&lt;AccountInfo&lt;'info&gt;&gt;,\n    pub program: AccountInfo&lt;'info&gt;,\n    pub signer_seeds: &amp;'a [&amp;'b [&amp;'c [u8]]],\n}\n</code></pre> <p>For more information, please refer to the <code>wormhole_anchor_sdk</code> Rust docs.</p> Type <code>PostMessage&lt;'info&gt;</code> <pre><code>pub struct PostMessage&lt;'info&gt; {\n    pub config: AccountInfo&lt;'info&gt;,\n    pub message: AccountInfo&lt;'info&gt;,\n    pub emitter: AccountInfo&lt;'info&gt;,\n    pub sequence: AccountInfo&lt;'info&gt;,\n    pub payer: AccountInfo&lt;'info&gt;,\n    pub fee_collector: AccountInfo&lt;'info&gt;,\n    pub clock: AccountInfo&lt;'info&gt;,\n    pub rent: AccountInfo&lt;'info&gt;,\n    pub system_program: AccountInfo&lt;'info&gt;,\n}\n</code></pre> <p>For more information, please refer to the <code>wormhole_anchor_sdk</code> Rust docs.</p> <p><code>batch_id</code> u32</p> <p>An identifier for the message batch.</p> <p><code>payload</code> Vec&lt;u8&gt;</p> <p>The data being sent in the message. This is a variable-length byte array that contains the actual content or information being transmitted. To learn about the different types of payloads, check out the VAAs page.</p> <p><code>finality</code> Finality</p> <p>Specifies the level of finality or confirmation required for the message.</p> Type <code>Finality</code> <pre><code>pub enum Finality {\n    Confirmed,\n    Finalized,\n}\n</code></pre> Returns <p>Result&lt;()&gt;</p> <p>The result of the function\u2019s execution. If the function completes successfully, it returns <code>Ok(())</code>, otherwise it returns <code>Err(E)</code>, indicating that an error occurred along with the details about the error</p> Example <pre><code>let fee = ctx.accounts.wormhole_bridge.fee();\n// ... Check fee and send parameters\n\nlet config = &amp;ctx.accounts.config;\nlet payload: Vec&lt;u8&gt; = HelloWorldMessage::Hello { message }.try_to_vec()?;\n\n// Invoke `wormhole::post_message`.\nwormhole::post_message(\n    CpiContext::new_with_signer(\n        ctx.accounts.wormhole_program.to_account_info(),\n        wormhole::PostMessage {\n            // ... Set fields\n        },\n        &amp;[\n            // ... Set seeds\n        ],\n    ),\n    config.batch_id,\n    payload,\n    config.finality.into(),\n)?;\n</code></pre> <p>View the complete Hello World example in the Wormhole Scaffolding repository on GitHub.</p> <p>Once the message is emitted from the Core Contract, the Guardian Network will observe the message and sign the digest of an Attestation VAA. On EVM chains, the body of the VAA is hashed twice with keccak256 to produce the signed digest message. On Solana, the Solana secp256k1 program will hash the message passed. In this case, the argument for the message should be a single hash of the body, not the twice-hashed body.</p> <p>VAAs are multicast by default. This means there is no default target chain for a given message. The application developer decides on the format of the message and its treatment upon receipt.</p>"},{"location":"build/contract-integrations/core-contracts/#receiving-messages","title":"Receiving Messages","text":"<p>The way a message is received and handled depends on the environment.</p> EVMSolana <p>On EVM chains, the message passed is the raw VAA encoded as binary. The <code>IWormhole.sol</code> interface provides the <code>parseAndVerifyVM</code> function, which can be used to parse and verify the received message.</p> <pre><code>function parseAndVerifyVM(\n    bytes calldata encodedVM\n) external view returns (VM memory vm, bool valid, string memory reason);\n</code></pre> Parameters <p><code>encodedVM</code> bytes calldata</p> <p>The encoded message as a Verified Action Approval (VAA), which contains all necessary information for verification and processing.</p> Returns <p><code>vm</code> VM memory</p> <p>The valid parsed VAA, which will include the original <code>emitterAddress</code>, <code>sequenceNumber</code>, and <code>consistencyLevel</code>, among other fields outlined on the VAAs page.</p> Struct <code>VM</code> <pre><code>struct VM {\n    uint8 version;\n    uint32 timestamp;\n    uint32 nonce;\n    uint16 emitterChainId;\n    bytes32 emitterAddress;\n    uint64 sequence;\n    uint8 consistencyLevel;\n    bytes payload;\n    uint32 guardianSetIndex;\n    Signature[] signatures;\n    bytes32 hash;\n}\n</code></pre> <p>For more information, refer to the <code>IWormhole.sol</code> interface.</p> <p><code>valid</code> bool</p> <p>A boolean indicating whether the VAA is valid or not.</p> <p><code>reason</code> string</p> <p>If the VAA is not valid, a reason will be provided</p> Example <pre><code>function receiveMessage(bytes memory encodedMessage) public {\n    // Call the Wormhole core contract to parse and verify the encodedMessage\n    (\n        IWormhole.VM memory wormholeMessage,\n        bool valid,\n        string memory reason\n    ) = wormhole().parseAndVerifyVM(encodedMessage);\n\n    // Perform safety checks here\n\n    // Decode the message payload into the HelloWorldMessage struct\n    HelloWorldMessage memory parsedMessage = decodeMessage(\n        wormholeMessage.payload\n    );\n\n    // Your custom application logic here\n}\n</code></pre> <p>View the complete Hello World example in the Wormhole Scaffolding repository on GitHub.</p> <p>On Solana, the VAA is first posted and verified by the Core Contract, after which it can be read by the receiving contract and action taken.</p> <p>Retrieve the raw message data:</p> <pre><code>let posted_message = &amp;ctx.accounts.posted;\nposted_message.data()\n</code></pre> Example <pre><code>pub fn receive_message(ctx: Context&lt;ReceiveMessage&gt;, vaa_hash: [u8; 32]) -&gt; Result&lt;()&gt; {\n    let posted_message = &amp;ctx.accounts.posted;\n\n    if let HelloWorldMessage::Hello { message } = posted_message.data() {\n        // Check message\n        // Your custom application logic here\n        Ok(())\n    } else {\n        Err(HelloWorldError::InvalidMessage.into())\n    }\n}\n</code></pre> <p>View the complete Hello World example in the Wormhole Scaffolding repository on GitHub.</p> <p>In addition to environment-specific checks that should be performed, a contract should take care to check other fields in the body, including:</p> <ul> <li>Emitter - is this coming from an expected emitter address and chain ID? Typically, contracts will provide a method to register a new emitter and check the incoming message against the set of emitters it trusts</li> <li>Sequence - is this the expected sequence number? How should out-of-order deliveries be handled?</li> <li>Consistency level - for the chain this message came from, is the consistency level enough to guarantee the transaction won't be reverted after taking some action?</li> </ul> <p>The VAA digest is separate from the VAA body but is also relevant. It can be used for replay protection by checking if the digest has already been seen. Since the payload itself is application-specific, there may be other elements to check to ensure safety.</p>"},{"location":"build/contract-integrations/core-contracts/#source-code-references","title":"Source Code References","text":"<p>For a deeper understanding of the Core Contract implementation for a specific blockchain environment and to review the actual source code, please refer to the following links:</p> <ul> <li>Algorand Core Contract source code</li> <li>Aptos Core Contract source code</li> <li>EVM Core Contract source code (<code>IWormhole.sol</code> interface)</li> <li>NEAR Core Contract source code</li> <li>Solana Core Contract source code</li> <li>Sui Core Contract source code</li> <li>Terra Core Contract source code</li> </ul>"},{"location":"build/contract-integrations/dev-env/","title":"Development Environment","text":"<p>Developers building for smart contract integration will want to set up a development environment to allow testing the full integration, possibly including VAA generation and relaying.</p>"},{"location":"build/contract-integrations/dev-env/#tooling-installation","title":"Tooling Installation","text":"<p>The Wormhole CLI Tool should be installed regardless of the environments chosen. Each environment has its own set of recommended tools. To begin working with a specific environment, see the recommended tools on the respective environment page.</p>"},{"location":"build/contract-integrations/dev-env/#development-stages","title":"Development Stages","text":"<p>Different approaches to development and testing are recommended at various stages of application development.</p>"},{"location":"build/contract-integrations/dev-env/#initial-development","title":"Initial Development","text":"<p>During the initial development of an on-chain application, the best option is to use the native tools available in the environment. You can visit the following resources for more information:</p> <ul> <li>Environment - select the folder for the desired network to learn about the recommended native toolset  </li> <li>Mock Guardian - it's recommended to set up a mock Guardian or Emitter to provide signed VAAsFor any program methods that require some message be sent or received. </li> <li>Wormhole Scaffolding repository - example mock Guardian test</li> </ul> <p>Relying on native tools when possible allows for more rapid prototyping and iteration.  </p>"},{"location":"build/contract-integrations/dev-env/#integration","title":"Integration","text":"<p>For integration to Wormhole and with multiple chains, the simplest option is to use the chains' TestNets. In choosing which chains to use for integration testing, consider which chains in a given environment provide easy access to TestNet tokens and where block times are fast. Find links for TestNet faucets in the blockchain details section. A developer may prefer standing up a set of local validators instead of using the TestNet. For this option, Tilt is available to run local instances of all the chains Wormhole supports.</p> <p>Note</p> <p>Variation in host environments causes unique issues, and the computational intensity of multiple simultaneous local validators can make setting them up difficult or time-consuming. You may prefer TestNets for the simplest integration testing.</p>"},{"location":"build/contract-integrations/dev-env/#prepare-for-deployment","title":"Prepare for Deployment","text":"<p>Once you've finished the application's initial development and performed integration testing, you should set up a CI test environment. The best option for that is likely to be Tilt since it allows you to spin up any chains supported by Wormhole in a consistent environment.</p>"},{"location":"build/contract-integrations/dev-env/#validator-setup-with-tilt","title":"Validator Setup with Tilt","text":""},{"location":"build/contract-integrations/dev-env/#tilt","title":"Tilt","text":"<p>If you'd like to set up a local validator environment, follow the setup guide for Tilt. Tilt is a full-fledged Kubernetes deployment of every chain connected to Wormhole, along with a Guardian node. It usually takes 30 minutes to spin up fully, but it comes with all chains running out of the box. Refer to the Tilt page for a complete guide to setting up and configuring Tilt.</p>"},{"location":"build/contract-integrations/dev-env/#deploying-to-public-networks","title":"Deploying to Public Networks","text":""},{"location":"build/contract-integrations/dev-env/#testnet","title":"TestNet","text":"<p>When doing integration testing on TestNets, remember that a single Guardian node is watching for transactions on various test networks. Because TestNets only have a single Guardian, there's a slight chance that your VAAs won't be processed. This rate doesn't indicate performance on MainNet, where 19 Guardians are watching for transactions. The TestNet contract addresses are available on the page for each environment. The Wormholescan API offers the following Guardian equivalent TestNet endpoint:</p> <pre><code>https://api.testnet.wormholescan.io\n</code></pre>"},{"location":"build/contract-integrations/dev-env/#mainnet","title":"MainNet","text":"<p>The MainNet contract addresses are available on the page for each environment. The Wormholescan API offers the following Guardian equivalent MainNet endpoint:</p> <pre><code>https://api.wormholescan.io\n</code></pre>"},{"location":"build/contract-integrations/gateway/","title":"Get Started with Gateway","text":""},{"location":"build/contract-integrations/gateway/#overview","title":"Overview","text":"<p>Wormhole Gateway is a Cosmos SDK chain that provides a way to bridge non-native assets into the Cosmos ecosystem and serves as a source for unified liquidity across Cosmos chains. Because IBC is used to bridge assets from Gateway to Cosmos chains, liquidity fragmentation is avoided, and liquidity for foreign assets bridged via Wormhole into Cosmos is unified across Cosmos chains. In addition to facilitating asset transfers, Wormhole Gateway allows Wormhole to ensure proper accounting with the Global Accountant.</p>"},{"location":"build/contract-integrations/gateway/#integration","title":"Integration","text":"<p>Integrating with Wormhole Gateway is straightforward and can be achieved with just a few lines of code as follows:</p> <ul> <li>For Transfers from an external chain to any supported Cosmos Chain, see Into Cosmos</li> <li>For Transfers from any supported Cosmos Chain to an external chain, see Out of Comsos</li> <li>For Transfers between any supported Cosmos Chains, see between Cosmos chains</li> </ul>"},{"location":"build/contract-integrations/gateway/#into-cosmos","title":"Into Cosmos","text":"<p>To bridge assets into a Cosmos chain, an asset transfer is initiated on the foreign chain with a payload that is understood by the Gateway, or more specifically, the IBC Shim Contract. Once received on the Gateway, the asset's CW20 representation is sent to the destination chain through IBC using the well-established ICS20 protocol.</p> <p>The following example uses the Wormhole SDK to prepare a bridge transfer from an external chain into Cosmos.</p> <pre><code>import * as wh from '@certusone/wormhole-sdk';\n\nconst transferDetails = {\n  gateway_transfer: {\n    // This is a simple transfer with no additional payload\n    chain: 4000, // Chain ID of the Cosmos destination chain\n    recipient: 'INSERT_COSMOS_RECIPIENT_ADDRESS', // Base64 encoded bech32\n    fee: 0, // Fee for transfer (0 for now)\n    nonce: 0,\n  },\n};\n\n// The address of the ibc-translator contract on the Gateway\nconst ibcTranslatorAddress =\n  'wormhole14ejqjyq8um4p3xfqj74yld5waqljf88fz25yxnma0cngspxe3les00fpjx';\n\n// Convert the transfer details to a Uint8Array for sending\nconst payload = new Uint8Array(Buffer.from(JSON.stringify(transferDetails)));\n\n// Send transfer transaction on Ethereum\nconst txReceipt = await wh.transferFromEth(\n  wh.consts.TESTNET.eth.token_bridge, // Source chain token bridge address\n  wallet, // Signer for eth tx\n  'INSERT_TOKEN_ADDRESS', // Address of token being transferred\n  10000000n, // Amount of token in its base units\n  wh.consts.CHAINS.wormchain, // Chain ID of destimation chain\n  ibcTranslatorAddress, \n  0, // Relayer fee, 0 for now\n  {}, // Transaction overrides (gas fees, etc...)\n  payload // The payload Gateway uses to route transfers\n);\n</code></pre>"},{"location":"build/contract-integrations/gateway/#out-of-cosmos","title":"Out of Cosmos","text":"<p>To bridge assets out of the Cosmos ecosystem or between Cosmos chains, an IBC transfer is initiated on the source chain to the Gateway with a payload containing details about the transfer in the <code>memo</code> field.</p> <p>The following example demonstrates using CosmJS to create an IBC transfer:</p> <pre><code>const wallet = await DirectSecp256k1HdWallet.fromMnemonic(faucet.mnemonic);\nconst client = await SigningStargateClient.connectWithSigner(\n  simapp.tendermintUrl,\n  wallet,\n  defaultSigningClientOptions\n);\n\nconst memo = JSON.stringify({\n  gateway_ibc_token_bridge_payload: {\n    gateway_transfer: {\n      chain: 0, // Chain ID of receiver\n      recipient: 'INSERT_RECEIVER_ADDRESS',\n      fee: 0, // Fee to cover transfer\n      nonce: 0,\n    },\n  },\n});\nconst ibcTranslatorAddress =\n  'wormhole14ejqjyq8um4p3xfqj74yld5waqljf88fz25yxnma0cngspxe3les00fpjx';\nconst result = await client.sendIbcTokens(\n  faucet.address0, // Sender address\n  ibcTranslatorAddress, // Receiver address\n  coin(INSERT_AMOUNT, 'INSERT_COIN'), // Amount and coin\n  'transfer', // Source port\n  'channel-2186', // Source channel\n  timeoutHeight, \n  timeoutTimestamp,\n  0, // Fee to cover transaction\n  memo // Formatted payload with details about transfer\n);\n</code></pre>"},{"location":"build/contract-integrations/gateway/#between-cosmos-chains","title":"Between Cosmos Chains","text":"<p>From an implementation perspective, transfers between Cosmos chains behave exactly the same as bridging out of Cosmos. The exception is that the chain ID passed is a Cosmos chain.</p>"},{"location":"build/contract-integrations/gateway/#data-structures","title":"Data Structures","text":""},{"location":"build/contract-integrations/gateway/#gatewayibctokenbridgepayload","title":"GatewayIbcTokenBridgePayload","text":"<p>The core data structure of Gateway token transfers is the <code>GatewayIbcTokenBridgePayload,</code> which contains details about the transfer that the Gateway uses to perform the transfer.</p> <pre><code>pub enum GatewayIbcTokenBridgePayload {\n    GatewayTransfer {\n        chain: u16,\n        recipient: Binary,\n        fee: u128,\n        nonce: u32,\n    },\n    GatewayTransferWithPayload {\n        chain: u16,\n        contract: Binary,\n        payload: Binary,\n        nonce: u32,\n    },\n}\n</code></pre> <p>When sending a <code>GatewayIbcTokenBridge</code> payload, it must be serialized as JSON. The binary values are <code>base64</code> encoded for proper JSON encoding. The <code>recipient</code> for Cosmos chains are <code>base64</code> encoded <code>bech32</code> addresses. For example, if the <code>recipient</code> is <code>wormhole1f3jshdsmzl03v03w2hswqcfmwqf2j5csw223ls</code>, the encoding will be the direct <code>base64</code> encoding of <code>d29ybWhvbGUxZjNqc2hkc216bDAzdjAzdzJoc3dxY2Ztd3FmMmo1Y3N3MjIzbHM=</code>.</p> <p>The <code>chain</code> values map to Wormhole chain IDs. The <code>fee</code> and <code>nonce</code> are Wormhole-specific parameters, both unused today. For incoming IBC messages from Cosmos chains, the <code>receiver</code> field will be base64 encoded in the <code>Simple.recipient</code>  field, and the <code>channel-id</code> will be included as the equivalent Wormhole chain ID.</p>"},{"location":"build/contract-integrations/wormhole-relayers/","title":"Wormhole Relayer","text":""},{"location":"build/contract-integrations/wormhole-relayers/#introduction","title":"Introduction","text":"<p>The Wormhole-deployed relayers provide a mechanism for contracts on one blockchain to send messages to contracts on another without requiring off-chain infrastructure. Through the Wormhole relayer module, developers can use an untrusted delivery provider to transport VAAs, saving the need to build and maintain custom relaying solutions. The option to run a custom relayer is available for more complex needs.</p> <p>This section covers the components and interfaces involved in using the Wormhole relayer module, such as message sending and receiving, delivery guarantees, and considerations for building reliable and efficient cross-chain applications. Additionally, you'll find details on how to handle specific implementation scenarios and track message delivery progress using the Wormhole CLI tool.</p>"},{"location":"build/contract-integrations/wormhole-relayers/#get-started-with-the-wormhole-relayer","title":"Get Started with the Wormhole Relayer","text":"<p>Before getting started, it's important to note that the Wormhole-deployed relayer configuration is currently limited to EVM environments. The complete list of EVM environment blockchains is on the Supported Networks page.</p> <p>To interact with the Wormhole relayer, you'll need to create contracts on the source and target chains to handle the sending and receiving of messages. No off-chain logic needs to be implemented to take advantage of Wormhole-powered relaying.</p> The components outlined in blue must be implemented."},{"location":"build/contract-integrations/wormhole-relayers/#wormhole-relayer-interfaces","title":"Wormhole Relayer Interfaces","text":"<p>There are three relevant interfaces to discuss when utilizing the Wormhole relayer module:</p> <ul> <li><code>IWormholeRelayer</code> - the primary interface by which you send and receive messages. It allows you to request the sending of messages and VAAs</li> <li><code>IWormholeReceiver</code> - this is the interface you are responsible for implementing. It allows the selected delivery provider to deliver messages/VAAs to your contract</li> <li><code>IDeliveryProvider</code> - this interface represents the delivery pricing information for a given relayer network. Each delivery provider implements this on every blockchain they support delivering from</li> </ul>"},{"location":"build/contract-integrations/wormhole-relayers/#interact-with-the-wormhole-relayer","title":"Interact with the Wormhole Relayer","text":"<p>To start interacting with the Wormhole relayer in your contracts, you'll need to import the <code>IWormholeRelayer</code> interface and set up a reference using the contract address to the Wormhole-deployed relayer on the supported network of your choice.</p> <p>To easily integrate with the Wormhole relayer interface, you can use the Wormhole Solidity SDK.</p> <p>To retrieve the contract address of the Wormhole relayer, refer to the Wormhole relayer section on the Contract Addresses reference page.</p> <p>Your initial set up should resemble the following:</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport \"wormhole-solidity-sdk/interfaces/IWormholeRelayer.sol\";\n\ncontract Example {\n    IWormholeRelayer public wormholeRelayer;\n\n    constructor(address _wormholeRelayer) {\n        wormholeRelayer = IWormholeRelayer(_wormholeRelayer);\n    }\n}\n</code></pre> <p>The code provided sets up the basic structure for your contract to interact with the Wormhole relayer using the address supplied to the constructor. By leveraging methods from the <code>IWormholeRelayer</code> interface, you can implement message sending and receiving functionalities. The following sections will detail the specific methods you need to use for these tasks.</p>"},{"location":"build/contract-integrations/wormhole-relayers/#send-a-message","title":"Send a Message","text":"<p>To send a message to a contract on another EVM chain, you can call the <code>sendPayloadToEvm</code> method provided by the <code>IWormholeRelayer</code> interface.</p> <pre><code>function sendPayloadToEvm(\n    // Chain ID in Wormhole format\n    uint16 targetChain,     \n    // Contract Address on target chain we're sending a message to\n    address targetAddress,  \n    // The payload, encoded as bytes\n    bytes memory payload,   \n    // How much value to attach to the delivery transaction \n    uint256 receiverValue,  \n    // The gas limit to set on the delivery transaction\n    uint256 gasLimit        \n) external payable returns (\n    // Unique, incrementing ID, used to identify a message\n    uint64 sequence\n);\n</code></pre> <p>The <code>sendPayloadToEvm</code> method is marked <code>payable</code> to receive fee payment for the transaction. The value to attach to the invocation is determined by calling the <code>quoteEVMDeliveryPrice</code>, which provides an estimate of the cost of gas on the target chain.</p> <pre><code>function quoteEVMDeliveryPrice(\n    // Chain ID in Wormhole format\n    uint16 targetChain,\n    // How much value to attach to delivery transaction \n    uint256 receiverValue,\n    // The gas limit to attach to the delivery transaction\n    uint256 gasLimit\n) external view returns (\n    // How much value to attach to the send call\n    uint256 nativePriceQuote, \n    uint256 targetChainRefundPerGasUnused\n);\n</code></pre> <p>This method should be called before sending a message, and the value returned for <code>nativePriceQuote</code> should be attached to the call to send the payload to cover the transaction's cost on the target chain.</p> <p>In total, sending a message across EVM chains can be as simple as getting a fee quote and sending the message as follows:</p> <pre><code>// Get a quote for the cost of gas for delivery\n(cost, ) = wormholeRelayer.quoteEVMDeliveryPrice(\n    targetChain,\n    valueToSend,\n    GAS_LIMIT\n);\n\n// Send the message\nwormholeRelayer.sendPayloadToEvm{value: cost}(\n    targetChain,\n    targetAddress,\n    abi.encode(payload),\n    valueToSend, \n    GAS_LIMIT\n);\n</code></pre>"},{"location":"build/contract-integrations/wormhole-relayers/#receive-a-message","title":"Receive a Message","text":"<p>To receive a message using a Wormhole relayer, the target contract must implement the <code>IWormholeReceiver</code> interface, as shown in the previous section.</p> <pre><code>function receiveWormholeMessages(\n    bytes memory payload,           // Message passed by source contract \n    bytes[] memory additionalVaas,  // Any additional VAAs that are needed (Note: these are unverified) \n    bytes32 sourceAddress,          // The address of the source contract\n    uint16 sourceChain,             // The Wormhole chain ID\n    bytes32 deliveryHash            // A hash of contents, useful for replay protection\n) external payable;\n</code></pre> <p>The logic inside the function body may be whatever business logic is required to take action on the specific payload.</p>"},{"location":"build/contract-integrations/wormhole-relayers/#delivery-guarantees","title":"Delivery Guarantees","text":"<p>The Wormhole relayer protocol is intended to create a service interface whereby mutually distrustful integrators and delivery providers can work together to provide a seamless dApp experience. You don't trust the delivery providers with your data, and the delivery providers don't trust your smart contract. The primary agreement between integrators and delivery providers is that when a delivery is requested, the provider will attempt to deliver the VAA within the provider's stated delivery timeframe.</p> <p>This creates a marketplace whereby providers can set different price levels and service guarantees. Delivery providers effectively accept the slippage risk premium of delivering your VAAs in exchange for a set fee rate. Thus, the providers agree to deliver your messages even if they do so at a loss.</p> <p>Delivery providers should set their prices such that they turn a profit on average but not necessarily on every single transfer. Thus, some providers may choose to set higher rates for tighter guarantees or lower rates for less stringent guarantees.</p>"},{"location":"build/contract-integrations/wormhole-relayers/#delivery-statuses","title":"Delivery Statuses","text":"<p>All deliveries result in one of the following four outcomes before the delivery provider's delivery timeframe. When they occur, these outcomes are emitted as EVM events from the Wormhole relayer contract. The four possible outcomes are:</p> <ul> <li>(0) Delivery Success</li> <li>(1) Receiver Failure</li> <li>(2) Forward Request Success</li> <li>(3) Forward Request Failure</li> </ul> <p>A receiver failure is a scenario in which the selected provider attempted the delivery but it could not be completely successfully. The three possible causes for a delivery failure are:</p> <ul> <li>The target contract does not implement the <code>IWormholeReceiver</code> interface</li> <li>The target contract threw an exception or reverted during the execution of <code>receiveWormholeMessages</code></li> <li>The target contract exceeded the specified <code>gasLimit</code> while executing <code>receiveWormholeMessages</code></li> </ul> <p>All three of these scenarios can be avoided with correct design by the integrator, and thus, it is up to the integrator to resolve them. Any other scenario that causes a delivery to not be performed should be considered an outage by some component of the system, including potentially the blockchains themselves.</p> <p><code>Forward Request Success</code> and <code>Forward Failure</code> represent when the delivery succeeded and the user requested a forward during the delivery. If the user has enough funds left over as a refund to complete the forward, the forward will be executed, and the status will be <code>Forward Request Success</code>. Otherwise, it will be <code>Forward Request Failure</code>.</p>"},{"location":"build/contract-integrations/wormhole-relayers/#other-considerations","title":"Other Considerations","text":"<p>Some implementation details should be considered during development to ensure safety and a pleasant UX. Ensure that your engineering efforts have appropriately considered each of the following areas:</p> <ul> <li>Receiving a message from a relayer</li> <li>Checking for expected emitter</li> <li>Calling <code>parseAndVerify</code> on any additional VAAs</li> <li>Replay protection</li> <li>Message ordering (no guarantees on order of messages delivered)</li> <li>Forwarding and call chaining</li> <li>Refunding overpayment of <code>gasLimit</code></li> <li>Refunding overpayment of value sent</li> </ul>"},{"location":"build/contract-integrations/wormhole-relayers/#track-the-progress-of-messages-with-the-wormhole-cli","title":"Track the Progress of Messages with the Wormhole CLI","text":"<p>While no off-chain programs are required, a developer may want to track the progress of messages in flight. To track the progress of messages in flight, use the Wormhole CLI tool's <code>status</code> subcommand. As an example, you can use the following commands to track the status of a transfer by providing the environment, origin network, and transaction hash to the <code>worm status</code> command:</p> MainNetTestNet <pre><code>worm status mainnet ethereum INSERT_TRANSACTION_HASH\n</code></pre> <pre><code>worm status testnet ethereum INSERT_TRANSACTION_HASH\n</code></pre> <p>See the Wormhole CLI tool docs for installation and usage.</p>"},{"location":"build/contract-integrations/wormhole-relayers/#step-by-step-tutorial","title":"Step-by-Step Tutorial","text":"<p>For detailed, step-by-step guidance on creating cross-chain contracts that interact with the Wormhole relayer, refer to the Create Cross-Chain Contracts tutorial.</p>"},{"location":"build/contract-integrations/fast-transfers/","title":"Get Started with Fast Transfers","text":""},{"location":"build/contract-integrations/fast-transfers/#get-started","title":"Get Started","text":"<p>This section will guide you through interacting with the Fast Transfers protocol, including engaging with its aggregated auction mechanism, where solvers compete to offer the best rates for cross-chain transactions, and exploring the smart contracts that power the protocol.</p> <ul> <li> <p> How to Be a Solver</p> <p>Learn how to initiate and participate in cross-chain transfer auctions, submit and verify transactions, and settle auctions efficiently as a solver in the Fast Transfers protocol.</p> <p> Learn how to be a solver</p> </li> <li> <p> Smart Contract Components</p> <p>Take a look at the key components and processes behind the smart contracts that power the Fast Transfers protocol and how they facilitate efficient transfers across blockchain networks.</p> <p> See the smart contract components</p> </li> </ul>"},{"location":"build/contract-integrations/fast-transfers/#additional-resources","title":"Additional Resources","text":"<ul> <li> <p> What is Fast Transfers?</p> <p>Not familiar with the Fast Transfers protocol? Learn all about it, including its key components and how it works to provide efficient liquidity movement while addressing fragmentation and finality.</p> <p> Learn about Fast Transfers</p> </li> <li> <p> What is a Solver?</p> <p>Solvers play a critical role in the Fast Transfers protocol, facilitating seamless and efficient liquidity transfers across blockchain networks. Discover their role and the benefits of becoming a solver.</p> <p> Learn about solvers</p> </li> </ul>"},{"location":"build/contract-integrations/fast-transfers/how-to-solver/","title":"How to be a Solver","text":""},{"location":"build/contract-integrations/fast-transfers/how-to-solver/#overview","title":"Overview","text":"<p>In Fast Transfers, solvers ensure efficient cross-chain transfers through a competitive auction process on the Matching Engine. The auction consists of four key steps:</p> <ol> <li>Starting an auction - users initiate a transfer, and solvers begin bidding to fulfill it by offering the best rates</li> <li>Participating in an auction - solvers compete in a reverse Dutch auction to provide the most cost-effective solution</li> <li>Execute fast order to complete auction - the winning solver completes the transfer by sending assets to the destination chain within a set time frame</li> <li>Settling an auction - once the transfer is finalized, the solver retrieves their funds and earns the fee for the completed transaction</li> </ol>"},{"location":"build/contract-integrations/fast-transfers/how-to-solver/#starting-an-auction","title":"Starting an Auction","text":"<p>When users interact with Token Routers to transfer assets faster than finality to another chain, they place an order that is processed by the Matching Engine.</p> <p>To initiate an auction with this message, complete the steps in the following sections on Solana.</p>"},{"location":"build/contract-integrations/fast-transfers/how-to-solver/#send-transactions-to-verify-signatures-and-post-vaa","title":"Send Transactions to Verify Signatures and Post VAA","text":"<p>The VAA (Verified Action Approval) is a message that acts as an I owe you (IOU) for the solver when the auction is settled. The Wormhole Spy or a custom relayer listens to the Wormhole gossip network to observe the fast VAA.</p> <p>To read VAAs on Solana, someone must verify the signatures and post the VAA to a Solana account using the Wormhole Core Bridge. This is done through the Wormhole TS SDK.</p> <pre><code>import * as wormholeSdk from '@certusone/wormhole-sdk';\nimport { Keypair } from '@solana/web3.js';\n\n// This is only for example purposes, it is not recommended to store your secret key in a js file\nconst payer = Keypair.fromSecretKey('INSERT_PRIVATE_KEY') \n\nawait wormholeSdk.postVaaSolanaWithRetry(\n    solanaConnection, // Connection in @solana/web3.js\n    new wormholeSdk.solana.NodeWallet(payer).signTransaction,\n    // worm2ZoG2kUd4vFXhvjh93UUH596ayRfgQ2MgjNMTth on mainnet\n    CORE_BRIDGE_PROGRAM_ID, \n    payer.publicKey,\n    fastVaaBytes // Buffer type JL\n);\n</code></pre> <ul> <li><code>postVaaSolanaWithRetry</code> - function that posts the VAA to Solana by verifying its signatures and linking it to the appropriate Solana account</li> <li><code>payer</code> - the entity paying the transaction fees, defined by a secret key using the Solana Keypair</li> <li><code>fastVaaBytes</code> - the VAA message that acts as an IOU for the auction settlement</li> </ul>"},{"location":"build/contract-integrations/fast-transfers/how-to-solver/#send-transaction-to-place-initial-offer","title":"Send Transaction to Place Initial Offer","text":"<p>After the VAA is posted, the next step is to place an initial offer in the auction. This involves setting the offer price and priority fees.</p> <pre><code>import { Connection, Keypair } from '@solana/web3.js';\nimport * as wormholeSdk from '@certusone/wormhole-sdk';\n\nconst rpcUrl = 'INSERT_RPC_URL';\nconst matchingEngineProgramId = 'INSERT_MATCHING_ENGINE_PROGRAM_ID';\nconst usdcMintAddress = 'INSERT_USDC_MINT_ADDRESS';\n\nconst connection = new Connection(rpcUrl, \"confirmed\");\n// You will need to create your own logic for the following method\nconst feeMicroLamports =  INSERT_METHOD_TO_FIND_AUCTION; \n// This is only for example purposes, it is not recommended to store your secret key in a js file\nconst payer = Keypair.fromSecretKey('INSERT_PRIVATE_KEY'); \n\nconst matchingEngine = new MatchingEngineProgram(\n  connection,\n  matchingEngineProgramId,\n  // EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v on mainnet\n  usdcMintAddress \n);\n\nconst tx = await matchingEngine.placeInitialOfferTx(\n    {\n        payer,\n    },\n    {\n        fastVaaBytes,\n        offerPrice,\n        feeMicroLamports,\n        nonceAccount, // optional PublicKey (if durable nonce is used)\n        addressLookupTableAccounts, // optional AddressLookupTableAccount[];\n    }\n);\n\n// Send the transaction to Solana\nconst txSig = await connection.sendTransaction(tx);\n</code></pre> <ul> <li><code>MatchingEngineProgram</code>- handles interactions with the auction system on Solana</li> <li><code>placeInitialOfferTx</code> - function that submits the solver's initial offer to the Matching Engine with details like the offer price and the fee (in micro-lamports)</li> <li><code>feeMicroLamports</code> - the priority fee for processing this transaction</li> <li><code>fastVaaBytes</code> - the VAA message that represents the auction</li> </ul>"},{"location":"build/contract-integrations/fast-transfers/how-to-solver/#participating-in-an-auction","title":"Participating in an Auction","text":"<p>To participate in an already initialized auction, a relayer must place an offer at a price better than the current auction price. The auction data is stored in an account created by the Matching Engine, and the fast VAA hash determines this auction account address.  </p> <p>The auction account pubkey can be determined by either:</p> <ul> <li>Listening to a Solana web socket connection to find the account when the initial offer is placed:<ul> <li>Subscribe to a WebSocket service that monitors Solana for new transactions</li> <li>Filter the transactions to identify those related to the initial offer by checking for interaction with the Matching Engine\u2019s program ID</li> <li>Extract the auction account public key from the transaction where the initial offer was placed</li> </ul> </li> <li>Using the fast VAA bytes to compute its hash and derive its auction account address<ul> <li>Convert the fast VAA bytes into a hash using a cryptographic hash function </li> <li>Derive the auction account public key by using the hash as an input to a deterministic function that maps the hash to a public key within the Matching Engine's account space</li> </ul> </li> </ul> <p>Once the auction account is found, the relayer can submit an improved offer.</p> <pre><code>import { Connection, Keypair } from '@solana/web3.js';\nimport * as wormholeSdk from '@certusone/wormhole-sdk';\n\nconst matchingEngineProgramId = 'INSERT_MATCHING_ENGINE_PROGRAM_ID';\nconst usdcMintAddress = 'INSERT_USDC_MINT_ADDRESS';\nconst connection = new Connection('INSERT_RPC_URL', 'confirmed');\n// This is only for example purposes, it is not recommended to store your secret key in a js file\nconst payer = Keypair.fromSecretKey('INSERT_PRIVATE_KEY');\n\nconst matchingEngine = new MatchingEngineProgram(\n  connection,\n  matchingEngineProgramId,\n  // EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v on MainNet\n  usdcMintAddress \n);\n\n// You will need to create your own logic for the following methods\nconst auction = INSERT_METHOD_TO_FIND_AUCTION;\nconst feeMicroLamports = INSERT_METHOD_TO_FIND_AUCTION;\n\nconst tx = await matchingEngine.improveOfferTx(\n  {\n      payer, // Transaction payer\n      auction, // Auction account public key\n  },\n  {\n    offerPrice, // New improved offer price\n    feeMicroLamports, // Priority fee for the transaction\n    nonceAccount, // optional PublicKey (if durable nonce is used)\n    addressLookupTableAccounts, // optional AddressLookupTableAccount[];\n  }\n);\n\nconst txSig = await connection.sendTransaction(tx);\n</code></pre> <ul> <li><code>improveOfferTx</code> - function  that allows the solver to place a better offer by submitting a lower bid (improved offer price) than the current one</li> <li><code>auction</code> - the public key of the auction account derived from the fast VAA hash or detected through the WebSocket</li> <li><code>feeLamports</code> - the priority fee for processing the improved offer</li> </ul>"},{"location":"build/contract-integrations/fast-transfers/how-to-solver/#execute-fast-order-to-complete-auction","title":"Execute Fast Order to Complete Auction","text":"<p>To complete the auction, the relayer must execute the fast order before the grace period ends. This step releases the funds to the user on the target chain. To execute the fast order, the relayer must interact with the Matching Engine on Solana, using the auction account derived from the fast VAA.</p> <pre><code>import { Connection, Keypair } from '@solana/web3.js';\nimport * as wormholeSdk from '@certusone/wormhole-sdk';\n\nconst matchingEngineProgramId = 'INSERT_MATCHING_ENGINE_PROGRAM_ID';\nconst usdcMintAddress = 'INSERT_USDC_MINT_ADDRESS';\nconst connection = new Connection('INSERT_RPC_URL', 'confirmed');\n// This is only for example purposes, it is not recommended to store your secret key in a js file\nconst payer = Keypair.fromSecretKey('INSERT_PRIVATE_KEY');\n\nconst matchingEngine = new MatchingEngineProgram(\n  connection,\n  matchingEngineProgramId,\n  // EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v on MainNet\n  usdcMintAddress \n);\n\n// You will need to create your own logic for the following methods\nconst auction = INSERT_METHOD_TO_FIND_AUCTION;\nconst feeMicroLamports = INSERT_METHOD_TO_FIND_AUCTION;\n\nconst tx = await matchingEngine.executeFastOrderTx(\n  {\n    payer, // Transaction payer\n    auction, // Auction account public key\n  },\n  {\n    feeMicroLamports, // Priority fee for the transaction\n    nonceAccount, // optional PublicKey (if durable nonce is used)\n    addressLookupTableAccounts, // optional AddressLookupTableAccount[];\n  }\n);\n\nconst txSig = await connection.sendTransaction(tx);\n</code></pre> <ul> <li><code>executeFastOrderTx</code> - function that executes the fast order, which releases the intended funds to the user on the target chain, finalizing the auction</li> </ul> <p>Participating in an auction is part of the bidding process, where the solver improves their offer to provide the most cost-effective solution and win the right to fulfill the transfer. In comparison, executing a fast order to complete an auction does not involve submitting a new offer price but ensuring the auction winner appropriately processes the transfer. Funds are transferred within the set time frame to finalize the auction and release funds to the user on the target chain.</p>"},{"location":"build/contract-integrations/fast-transfers/how-to-solver/#settle-auction-with-finalized-vaa","title":"Settle Auction with Finalized VAA","text":""},{"location":"build/contract-integrations/fast-transfers/how-to-solver/#send-transactions-to-verify-signatures-and-post-vaa_1","title":"Send Transactions to Verify Signatures and Post VAA","text":"<p>Once the auction is completed, the finalized VAA must be posted to Solana to officially settle the auction. The finalized VAA can be observed using Wormhole Spy or similar processes, such as the relayer engine that listens to the Wormhole Spy network.</p> <p>Anyone can post the VAAs on Solana to read and verify VAAs using Wormhole Core Bridge instructions. This is typically done using the Wormhole TS SDK, as shown below:</p> <pre><code>import * as wormholeSdk from '@certusone/wormhole-sdk';\nimport { Keypair } from '@solana/web3.js';\n\n// This is only for example purposes, it is not recommended to store your secret key in a js file\nconst payer = Keypair.fromSecretKey('INSERT_PRIVATE_KEY') \n\nawait wormholeSdk.postVaaSolanaWithRetry(\n    solanaConnection, // Connection in @solana/web3.js\n    new wormholeSdk.solana.NodeWallet(payer).signTransaction,\n    // worm2ZoG2kUd4vFXhvjh93UUH596ayRfgQ2MgjNMTth on mainnet\n    CORE_BRIDGE_PROGRAM_ID, \n    payer.publicKey,\n    finalizedVaaBytes // Buffer type\n);\n</code></pre> <ul> <li><code>postVaaSolanaWithRetry</code> - posts the finalized VAA to the Solana blockchain by verifying the signatures and associating the VAA with a Solana account</li> <li><code>payer</code> - the entity responsible for covering transaction fees</li> <li><code>finalizedVaaBytes</code> - the VAA message confirming the auction's settlement</li> </ul>"},{"location":"build/contract-integrations/fast-transfers/how-to-solver/#send-transaction-to-settle-complete-auction","title":"Send Transaction to Settle Complete Auction","text":"<p>After posting the finalized VAA, the final step is to settle the auction on Solana. This confirms the auction and ensures the winning solver is paid out accordingly. The following code sends a transaction to the Matching Engine to settle the auction:</p> <pre><code>import { Connection, Keypair } from '@solana/web3.js';\nimport * as wormholeSdk from '@certusone/wormhole-sdk';\n\nconst rpcUrl = 'INSERT_RPC_URL';\nconst matchingEngineProgramId = 'INSERT_MATCHING_ENGINE_PROGRAM_ID';\nconst usdcMintAddress = 'INSERT_USDC_MINT_ADDRESS';\n\nconst connection = new Connection(rpcUrl, \"confirmed\");\n// You will need to create your own logic for the following method\nconst feeMicroLamports =  INSERT_METHOD_TO_FIND_AUCTION; \n// This is only for example purposes, it is not recommended to store your secret key in a js file\nconst payer = Keypair.fromSecretKey('INSERT_PRIVATE_KEY'); \n\nconst matchingEngine = new MatchingEngineProgram(\n  connection,\n  matchingEngineProgramId,\n  // EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v on mainnet\n  usdcMintAddress \n);\n\nconst tx = await matchingEngine.settleAuctionTx(\n    connection,\n    payer,\n    sourceRpc, // For fetching information from the source chain.\n    fastVaaBytes, // The initial fast VAA bytes\n    finalizedVaaBytes, // The finalized VAA bytes to confirm the auction\n    {\n        feeMicroLamports, // Priority fee for the transaction\n        nonceAccount, // optional PublicKey (if durable nonce is used)\n        addressLookupTableAccounts, // optional AddressLookupTableAccount[];\n    }\n);\n\n// Send the transaction to Solana\nconst txSig = await connection.sendTransaction(tx);\n</code></pre> <ul> <li><code>settleAuctionTx</code> - settles the auction by confirming the transfer using both the fast VAA and the finalized VAA</li> <li><code>sourceRpc</code> - the RPC connection to the source chain, used for fetching required information during settlement</li> <li><code>fastVaaBytes</code> - the initial VAA from the fast transfer process</li> <li><code>finalizedVaaBytes</code> - the finalized VAA confirming the completion of the auction and transfer</li> </ul>"},{"location":"build/contract-integrations/fast-transfers/how-to-solver/#mainnet-contract-addresses","title":"MainNet Contract Addresses","text":"<p>For MainNet contract addresses for various components of the Fast Transfers protocol, including the Matching Engine, Token Router, and Upgrade Manager, refer to the Contract Addresses page.</p>"},{"location":"build/contract-integrations/fast-transfers/smart-components/","title":"Smart Contract Components","text":"<p>Transferring USDC between different blockchains can be slow, costly, and complex, especially when moving between chains that do not support Circle's Cross-Chain Transfer Protocol (CCTP). Managing liquidity and ensuring compatibility across networks is a significant challenge.</p> <p>The Token Router and Matching Engine smart contracts solve this by enabling fast and efficient cross-chain transfers. The Token Router determines the type of USDC required on the destination chain, while the Matching Engine handles liquidity management and fast transfer auctions, ensuring low fees and quick delivery. They provide seamless token transfers, even between CCTP-enabled and non-CCTP chains.</p> <p>This page explains the key components and processes behind the Token Router and Matching Engine smart contracts and how they facilitate efficient Fast Transfers across blockchain networks.</p>"},{"location":"build/contract-integrations/fast-transfers/smart-components/#token-router-contracts","title":"Token Router Contracts","text":"<p>The Token Router smart contract is the entry point for sending USDC and other supported tokens across different blockchain networks. It allows users to transfer tokens from one blockchain to another, handling all interactions with the Matching Engine and determining the appropriate routing method depending on whether the destination chain is CCTP-enabled or not.</p> <p>The Token Router provides two main order types for token transfers: place market order and place fast market order.</p>"},{"location":"build/contract-integrations/fast-transfers/smart-components/#place-market-order","title":"Place Market Order","text":"<p>The <code>placeMarketOrder</code> function allows users to send USDC (with an optional message payload) to any CCTP-enabled blockchain network registered with the Token Router. This function is designed to future-proof the contract by including parameters that, while unused now, can be leveraged in future versions to improve functionality.</p> <pre><code>function placeMarketOrder(\n    uint128 amountIn,\n    uint128 minAmountOut,\n    uint16 targetChain,\n    bytes32 redeemer,\n    bytes calldata redeemerMessage,\n    address refundAddress\n) external payable returns (uint64 sequence);\n</code></pre> Parameters <p><code>amountIn</code> uint128</p> <p>The amount of USDC being transferred.</p> <p><code>minAmountOut</code> uint128</p> <p>The minimum amount of tokens expected on the destination chain.</p> <p><code>targetChain</code> uint16</p> <p>The chain ID of the blockchain where the tokens will be transferred.</p> <p><code>redeemer</code> bytes32</p> <p>The address of the contract that will handle the redemption of tokens on the target chain.</p> <p><code>redeemerMessage</code> bytes calldata</p> <p>Optional message payload to be delivered along with the tokens.</p> <p><code>refundAddress</code> address</p> <p>The address that will receive a refund if the transaction fails.</p> Returns <p><code>sequence</code> uint64</p> <p>The sequence number of the <code>Fill</code> Wormhole message.</p> <p>The <code>minAmountOut</code> and <code>refundAddress</code> parameters are currently unused but are included for future compatibility. The contract is designed to handle future upgrades that could support non-CCTP-enabled chains by swapping CCTP USDC for a wrapped alternative through the Matching Engine.</p>"},{"location":"build/contract-integrations/fast-transfers/smart-components/#place-fast-market-order","title":"Place Fast Market Order","text":"<p>The <code>placeFastMarketOrder</code> function allows users to initiate a faster-than-finality USDC transfer by specifying a maxFee and a deadline. This type of order does not wait for finality, enabling faster delivery through market participants who compete for the lowest fee in an auction on the Matching Engine.</p> <pre><code>function placeFastMarketOrder(\n    uint128 amountIn,\n    uint128 minAmountOut,\n    uint16 targetChain,\n    bytes32 redeemer,\n    bytes calldata redeemerMessage,\n    address refundAddress,\n    uint128 maxFee,\n    uint32 deadline\n) external payable returns (uint64 sequence, uint64 fastSequence);\n</code></pre> Parameters <p><code>amountIn</code> uint128</p> <p>The amount of USDC being transferred.</p> <p><code>minAmountOut</code> uint128</p> <p>The minimum expected amount of tokens on the destination chain.</p> <p><code>targetChain</code> uint16</p> <p>The chain ID of the blockchain where tokens will be sent.</p> <p><code>redeemer</code> bytes32</p> <p>The address on the target chain that will redeem the tokens.</p> <p><code>maxFee</code> uint128</p> <p>The maximum fee the user is willing to pay to expedite the transaction.</p> <p><code>deadline</code> uint32</p> <p>The deadline for the fast transfer auction to start. A value of 0 opts out of using a deadline.</p> Returns <p><code>sequence</code> uint64</p> <p>The sequence number of the <code>SlowOrderResponse</code> Wormhole message.</p> <p><code>fastSequence</code> uint64</p> <p>The sequence number of the <code>FastMarketOrder</code> Wormhole message.</p> <p>The <code>placeFastMarketOrder</code> function allows market participants to engage in a fee-based auction, ensuring the user's transfer is completed as fast as possible based on available liquidity.</p>"},{"location":"build/contract-integrations/fast-transfers/smart-components/#usdc-routing-and-canonical-usdc","title":"USDC Routing and Canonical USDC","text":"<p>The type of USDC received on the destination chain depends on whether the chain supports CCTP:</p> <ul> <li>CCTP-enabled chains - the user receives native USDC</li> <li>Non-CCTP chains - the user receives ethUSDC (Ethereum-based USDC)</li> </ul> <p>If the source and destination chains use different types of USDC, the Token Router interacts with the Matching Engine to facilitate a token swap to ensure the correct form of USDC is delivered. If both chains use the same type of USDC, the transfer occurs directly, bypassing the Matching Engine.</p> <p>In cases where a swap is required, the <code>minAmountOut</code> parameter ensures that the user receives a minimum amount of USDC, and any excess USDC is refunded to the specified <code>refundAddress</code>.</p>"},{"location":"build/contract-integrations/fast-transfers/smart-components/#additional-features","title":"Additional Features","text":"<p>The Token Router contract is designed to handle future upgrades and different blockchain configurations. It supports cross-chain USDC transfers by managing liquidity and routing logic and ensuring that the right type of USDC is delivered based on the destination chain's compatibility.</p> <p>For more detailed implementation, you can explore the Matching Engine smart contract in the Wormhole Foundation GitHub repository.</p>"},{"location":"build/contract-integrations/fast-transfers/smart-components/#matching-engine","title":"Matching Engine","text":"<p>The Matching Engine handles auctions, determines fees for fast transfers, and facilitates token swaps when required. It operates on Solana and works with the Token Router to ensure liquidity and optimal pricing for cross-chain USDC transfers. By managing liquidity and conducting auctions for fast orders, the Matching Engine ensures that fast transfers occur efficiently with minimal fees. It plays a critical role in matching market participants with transfer requests while operating mainly in the background.</p> <p>The Matching Engine smart contract includes several important functionalities that ensure efficient and secure cross-chain transfers:</p> <ul> <li>Auction management - the Matching Engine handles fast order auctions, determining fees based on market conditions to provide the most cost-effective cross-chain transfers</li> <li>User penalty and reward system - the contract includes a system for managing penalties and rewards, ensuring fair participation in fast transfers. The user penalty and reward percentages are customizable during initialization</li> <li>Contract initialization - the contract is initialized with essential addresses, including the owner, assistant, and fee recipient. The addresses are checked to ensure they are valid before the contract can proceed</li> <li>Immutability checks - the contract includes safeguards to ensure critical parameters such as token addresses and auction settings are not changed unexpectedly</li> </ul> <p>Some of the key functions and mechanisms within the Matching Engine smart contract include the following:</p> <ul> <li> <p>Initialization - the Matching Engine is initialized with key addresses and configurations (e.g., <code>ownerAssistant</code>, <code>feeRecipient</code>) to ensure proper contract setup. The function <code>_parseInitData</code> decodes initialization data and verifies that the addresses are not zero addresses</p> <pre><code>function _parseInitData(bytes memory initData)\n    internal\n    pure\n    returns (address ownerAssistant, address feeRecipient)\n{\n    uint256 offset = 0;\n    (ownerAssistant, offset) = initData.asAddressUnchecked(offset);\n    (feeRecipient, offset) = initData.asAddressUnchecked(offset);\n    initData.checkLength(offset);\n}\n</code></pre> </li> <li> <p>Penalty and auction settings - the Matching Engine sets parameters like auction duration, grace period, and penalties for non-compliance during fast transfers. These parameters help manage the auction process and ensure reliability in the system</p> <pre><code>assert(this.getUserPenaltyRewardBps() == _userPenaltyRewardBps);\nassert(this.getInitialPenaltyBps() == _initialPenaltyBps);\nassert(this.getAuctionDuration() == _auctionDuration);\n</code></pre> </li> <li> <p>Auction execution - the contract ensures that auctions are executed within the defined auctionDuration and gracePeriod, preventing delays and ensuring efficient processing of fast orders</p> </li> </ul> <p>For more detailed implementation, you can explore the Matching Engine smart contract in the Wormhole Foundation GitHub repository.</p>"},{"location":"build/contract-integrations/native-token-transfers/","title":"Native Token Transfers","text":""},{"location":"build/contract-integrations/native-token-transfers/#get-started","title":"Get Started","text":"<p>This section provides comprehensive guidance on configuring, deploying, and managing your Native Token Transfers (NTT) integration. It includes information relevant to both new token deployments and existing token management.</p> <ul> <li> <p> Deployment Process</p> <p>Guidance on installation, deployment to EVM and Solana, and maintaining your NTT after deployment.</p> <p> Start the deployment process</p> </li> <li> <p> Configure NTT</p> <p>Find information on configuring NTT, including guidance on setting Owner and Pauser access control roles and management of rate-limiting.</p> <p> Configure your NTT deployment</p> </li> </ul>"},{"location":"build/contract-integrations/native-token-transfers/configuration/","title":"Configure Native Token Transfers (NTT)","text":""},{"location":"build/contract-integrations/native-token-transfers/configuration/#get-started","title":"Get Started","text":"<p>This section contains information on configuring Native Token Transfers (NTT), including guidance on setting Owner and Pauser access control roles and management of rate-limiting.</p> <ul> <li> <p> Rate Limiting</p> <p>Discover options for configuring rate limits and how queueing effects transaction flow.</p> <p> Explore rate limit options</p> </li> <li> <p> Access Control</p> <p>Learn more about access control, including why you should consider setting a separate Pauser address as part of your development security plan.</p> <p> Explore access control roles</p> </li> </ul>"},{"location":"build/contract-integrations/native-token-transfers/configuration/access-control/","title":"Native Token Transfers Access Control","text":""},{"location":"build/contract-integrations/native-token-transfers/configuration/access-control/#owner-and-pauser-roles","title":"Owner and Pauser Roles","text":"<p>Pausing the Native Toke Transfer (NTT) Manager Contract will disallow initiating new token transfers. While the contract is paused, in-flight transfers can still be redeemed (subject to rate limits if configured).</p> <p>NTT can be paused on a particular chain by updating the <code>paused</code> parameter on the deployment to <code>true</code> via the NTT CLI, then performing <code>ntt push</code> to sync the local configuration with the on-chain deployment.</p> <ul> <li>Owner - full control over NTT contracts, can perform administrative functions. Has the ability to un-pause contracts if they have been paused</li> <li>Pauser - can pause NTT contracts to halt token transfers temporarily. This role is crucial for responding quickly to adverse events without a prolonged governance process. Cannot un-pause contracts</li> </ul> <p>Note</p> <p>While the <code>Pauser</code> can pause contracts, the ability to un-pause contracts is callable only by the <code>Owner</code>.</p> <p>The <code>Owner</code> and the <code>Pauser</code> addresses can each pause the contract. Since the contract <code>Owner</code> address is typically a multisig or a more complex DAO governance contract, and pausing the contract only affects the availability of token transfers, protocols can choose to set the <code>Pauser</code> address to be a different address. Creating a separate <code>Pauser</code> helps protocols respond quickly to potential risks without going through a drawn-out process.</p> <p>Consider separating <code>Owner</code> and <code>Pauser</code> roles for your multichain deployment. <code>Owner</code> and <code>Pauser</code> roles are defined directly on the <code>NttManager</code> contract.</p>"},{"location":"build/contract-integrations/native-token-transfers/configuration/rate-limiting/","title":"Native Token Transfers Rate Limiting","text":""},{"location":"build/contract-integrations/native-token-transfers/configuration/rate-limiting/#introduction","title":"Introduction","text":"<p>The Native Token Transfer (NTT) framework provides configurable per-chain rate limits for sending and receiving token transfers. Integrators can manage these limits via their own governance processes to quickly adapt to on-chain activity.</p> <p>If a transfer is rate-limited on the source chain and queueing is enabled via <code>shouldQueue = true</code>, the transfer is placed into an outbound queue and can be released after the duration of the rate limit expires.</p> <p>You can configure the following limits on every chain where NTT is deployed directly using the manager:</p> <ul> <li>Sending limit - a single outbound limit for sending tokens from the chain</li> <li>Per-chain receiving limits - the maximum receiving limit, which can be configured on a per-chain basis. For example, allowing <code>100</code> tokens to be received from Ethereum, but only 50 tokens to be received from Arbitrum</li> </ul> <p>Rate limits are replenished every second over a fixed duration. While the default duration is 24 hours, the value is configurable at contract creation. Rate-limited transfers on the destination chain are added to an inbound queue with a similar release delay.</p>"},{"location":"build/contract-integrations/native-token-transfers/configuration/rate-limiting/#queuing-mechanism","title":"Queuing Mechanism","text":"<p>When a transfer exceeds the rate limit, it is held in a queue and can be released after the set rate limit duration has expired. The sending and receiving queuing behavior is as follows:</p> <ul> <li>Sending - if an outbound transfer violates rate limits, users can either revert and try again later or queue their transfer. Users must return after the queue duration has expired to complete sending their transfer</li> <li>Receiving - if an inbound transfer violates rate limits, it is held in a queue. Users or relayers must return after the queue duration has expired to complete receiving their transfer on the destination chain</li> </ul>"},{"location":"build/contract-integrations/native-token-transfers/configuration/rate-limiting/#cancel-flows","title":"Cancel Flows","text":"<p>If users bridge frequently between a given source chain and destination chain, the capacity could be exhausted quickly. Loss of capacity can leave other users rate-limited, potentially delaying their transfers.  The outbound transfer cancels the inbound rate limit on the source chain to avoid unintentional delays. This allows for refilling the inbound rate limit by an amount equal to the outbound transfer amount and vice-versa, with the inbound transfer canceling the outbound rate limit on the destination chain and refilling the outbound rate limit with an amount.</p>"},{"location":"build/contract-integrations/native-token-transfers/deployment-process/","title":"Deploy Native Token Transfers (NTT)","text":""},{"location":"build/contract-integrations/native-token-transfers/deployment-process/#get-started","title":"Get Started","text":"<p>This section provides information on installing Wormhole's Native Token Transfer framework, deployment to EVM and Solana, and post deployment NTT maintenance.</p> <ul> <li> <p> Installation</p> <p>Prerequisites and commands for installing the NTT CLI and working with the NTT framework.</p> <p> Install the NTT CLI</p> </li> <li> <p> Deploy to EVM</p> <p>Find information on preparing for NTT deployment to EVM, including an example NTT token repository.</p> <p> Deploy token and NTT contracts</p> </li> <li> <p> Deploy to Solana</p> <p>Your guide to NTT deployment to Solana, including setup, token compatibility, mint/burn modes, and CLI usage.</p> <p> Deploy token and NTT contracts</p> </li> <li> <p> Post Deployment</p> <p>Learn how to best monitor and maintain your NTT deployment to get the most out of your Wormhole integration while providing security for users.</p> <p> Explore next steps</p> </li> </ul>"},{"location":"build/contract-integrations/native-token-transfers/deployment-process/deploy-to-evm/","title":"Native Token Transfers (NTT) EVM Development","text":""},{"location":"build/contract-integrations/native-token-transfers/deployment-process/deploy-to-evm/#deploy-your-token-and-ensure-compatibility","title":"Deploy Your Token and Ensure Compatibility","text":"<p>If you still need to do so, deploy the token contract to the destination or spoke chains.</p> <p>Tokens integrated with <code>NttManager</code> in <code>burning</code> mode require the following two functions to be present:</p> <ul> <li><code>burn(uint256 amount)</code></li> <li><code>mint(address account, uint256 amount)</code></li> </ul> <p>These functions aren't part of the standard ERC-20 interface. The <code>INttToken</code> interface documents the required functions and convenience methods, errors, and events.</p> View the complete <code>INttToken</code> Interface` <pre><code>// SPDX-License-Identifier: Apache 2\npragma solidity &gt;=0.8.8 &lt;0.9.0;\n\ninterface INttToken {\n    /// @notice Error when the caller is not the minter.\n    /// @dev Selector 0x5fb5729e.\n    /// @param caller The caller of the function.\n    error CallerNotMinter(address caller);\n\n    /// @notice Error when the minter is the zero address.\n    /// @dev Selector 0x04a208c7.\n    error InvalidMinterZeroAddress();\n\n    /// @notice Error when insufficient balance to burn the amount.\n    /// @dev Selector 0xcf479181.\n    /// @param balance The balance of the account.\n    /// @param amount The amount to burn.\n    error InsufficientBalance(uint256 balance, uint256 amount);\n\n    /// @notice The minter has been changed.\n    /// @dev Topic0\n    ///      0x0b5e7be615a67a819aff3f47c967d1535cead1b98db60fafdcbf22dcaa8fa5a9.\n    /// @param newMinter The new minter.\n    event NewMinter(address previousMinter, address newMinter);\n\n    // NOTE: the `mint` method is not present in the standard ERC20 interface.\n    function mint(address account, uint256 amount) external;\n\n    // NOTE: the `setMinter` method is not present in the standard ERC20 interface.\n    function setMinter(address newMinter) external;\n\n    // NOTE: NttTokens in `burn` mode require the `burn` method to be present.\n    //       This method is not present in the standard ERC20 interface, but is\n    //       found in the `ERC20Burnable` interface.\n    function burn(uint256 amount) external;\n}\n</code></pre> <p>Later, you set mint authority to the corresponding <code>NttManager</code> contract. You can also follow the scripts in the example NTT token repository to deploy a token contract.</p>"},{"location":"build/contract-integrations/native-token-transfers/deployment-process/deploy-to-evm/#deploy-ntt","title":"Deploy NTT","text":"<p>Create a new NTT project:</p> <pre><code>ntt new my-ntt-deployment\ncd my-ntt-deployment\n</code></pre> <p>Initialize a new <code>deployment.json</code> file, specifying the network:</p> TestNetMainNet <pre><code>ntt init Testnet\n</code></pre> <pre><code>ntt init Mainnet\n</code></pre> <p>Ensure you have set up your environment correctly: </p> <pre><code>export ETH_PRIVATE_KEY=INSERT_PRIVATE_KEY\n</code></pre> <p>Add each chain you'll be deploying to. The following example demonstrates configuring NTT in burn-and-mint mode on Ethereum Sepolia and Arbitrum Sepolia:</p> <pre><code># Set scanner API Keys as environment variables\nexport SEPOLIA_SCAN_API_KEY=INSERT_ETHERSCAN_SEPOLIA_API_KEY\nexport ARBITRUMSEPOLIA_SCAN_API_KEY=INSERT_ARBISCAN_SEPOLIA_API_KEY\n\n# Add each chain\n# The contracts will be automatically verified using the scanner API keys above\nntt add-chain Sepolia --latest --mode burning --token INSERT_YOUR_TOKEN_ADDRESS\nntt add-chain ArbitrumSepolia --latest --mode burning --token INSERT_YOUR_TOKEN_ADDRESS\n</code></pre> <p>While not recommended, you can pass the <code>-skip-verify</code> flag to the <code>ntt add-chain</code> command if you want to skip contract verification.</p> <p>The <code>ntt add-chain</code> command takes the following parameters:</p> <ul> <li>Name of each chain</li> <li>Version of NTT to deploy (use <code>--latest</code> for the latest contract versions)</li> <li>Mode (either <code>burning</code> or <code>locking</code>)</li> <li>Your token contract address</li> </ul> <p>The NTT CLI prints detailed logs and transaction hashes, so you can see exactly what's happening under the hood.</p>"},{"location":"build/contract-integrations/native-token-transfers/deployment-process/deploy-to-evm/#configure-ntt","title":"Configure NTT","text":"<p>The NTT CLI takes inspiration from git. You can run:</p> <ul> <li><code>ntt status</code> to check whether your <code>deployment.json</code> file is consistent with what is on-chain</li> <li><code>ntt pull</code> to sync your <code>deployment.json</code> file with the on-chain configuration</li> <li><code>ntt push</code> to sync the on-chain configuration with local changes made to your <code>deployment.json</code> file</li> </ul> <p>After you deploy the NTT contracts, ensure that the deployment is properly configured and your local representation is consistent with the actual on-chain state by running <code>ntt status</code> and following the instructions shown on the screen.</p>"},{"location":"build/contract-integrations/native-token-transfers/deployment-process/deploy-to-evm/#set-token-minter-to-ntt-manager","title":"Set Token Minter to NTT Manager","text":"<p>The final step in the deployment process is to set the NTT Manager as a minter of your token on all chains you have deployed to in <code>burning</code> mode. When performing a hub-and-spoke deployment, it is only necessary to set the NTT Manager as a minter of the token on each spoke chain.</p> <ul> <li>If you followed the <code>INttToken</code> interface, you can execute the <code>setMinter(address newMinter)</code> function</li> <li>If you have a custom process to manage token minters, you should now follow that process to add the corresponding NTT Manager as a minter</li> </ul> <p>By default, NTT transfers to EVM blockchains support automatic relaying via the Wormhole relayer, which doesn't require the user to perform a transaction on the destination chain to complete the transfer.</p>"},{"location":"build/contract-integrations/native-token-transfers/deployment-process/deploy-to-solana/","title":"Native Token Transfers (NTT) Solana Deployment","text":""},{"location":"build/contract-integrations/native-token-transfers/deployment-process/deploy-to-solana/#install-dependencies","title":"Install Dependencies","text":"<p>Ensure you have the following dependencies installed:</p> <ul> <li>Rust </li> <li>Solana v1.18.10</li> <li>Anchor v0.29.0</li> </ul>"},{"location":"build/contract-integrations/native-token-transfers/deployment-process/deploy-to-solana/#deploy-ntt","title":"Deploy NTT","text":"<p>Create a new NTT project (or use an existing NTT project):</p> <pre><code>ntt new my-ntt-deployment\ncd my-ntt-deployment\n</code></pre> <p>Initialize a new <code>deployment.json</code> file, specifying the network:</p> TestNetMainNet <pre><code>ntt init Testnet\n</code></pre> <pre><code>ntt init Mainnet\n</code></pre>"},{"location":"build/contract-integrations/native-token-transfers/deployment-process/deploy-to-solana/#deploy-your-spl-token","title":"Deploy your SPL Token","text":"<p>If you haven't already, deploy your SPL token to Solana.</p> <ol> <li> <p>Generate a new Solana key pair to create a wallet: <pre><code>solana-keygen grind --starts-with w:1 --ignore-case\n</code></pre></p> </li> <li> <p>Set Solana configuration to use the new key pair: <pre><code>solana config set --keypair INSERT_PATH_TO_KEYPAIR_CREATED_IN_STEP1\n</code></pre></p> </li> <li> <p>Set the Solana configuration to use the default RPC URL for DevNet: <pre><code>solana config set -ud\n</code></pre></p> </li> <li> <p>Request an airdrop of two SOL and check the balance: <pre><code>solana airdrop 2 &amp; solana balance\n</code></pre></p> </li> <li> <p>Install or update the SPL Token CLI: <pre><code>cargo install spl-token-cli\n</code></pre></p> </li> <li> <p>Create a new token with the SPL Token CLI using the <code>token-2022</code> program: <pre><code>spl-token create-token --program-id TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb \n</code></pre></p> </li> <li> <p>Create a new account for the token: <pre><code>spl-token create-account INSERT_ADDRESS_OF_TOKEN_CREATED_IN_STEP6 --program-id TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb\n</code></pre></p> </li> <li> <p>Mint <code>1000</code> tokens to the created account: <pre><code>spl-token mint INSERT_ADDRESS_OF_TOKEN_CREATED_IN_STEP6 1000\n</code></pre></p> </li> </ol> <p>NTT versions <code>&gt;=v2.0.0+solana</code> support SPL tokens with transfer hooks.</p>"},{"location":"build/contract-integrations/native-token-transfers/deployment-process/deploy-to-solana/#configuration-and-deployment","title":"Configuration and Deployment","text":""},{"location":"build/contract-integrations/native-token-transfers/deployment-process/deploy-to-solana/#generate-ntt-program-key-pair","title":"Generate NTT Program Key Pair","text":"<p>When you deploy a Solana program, you need to hardcode the program ID (a Pubkey) into the program code. The NTT CLI allows you to do this seamlessly.</p> <p>Generate a new NTT program key pair using:</p> <pre><code>solana-keygen grind --starts-with ntt:1 --ignore-case\n</code></pre>"},{"location":"build/contract-integrations/native-token-transfers/deployment-process/deploy-to-solana/#derive-token-authority","title":"Derive Token Authority","text":"<p>In this step, you'll derive the token authority Program Derived Address (PDA) of the newly generated NTT program ID:</p> <pre><code>ntt solana token-authority INSERT_YOUR_NTT_PROGRAM_KEY_PAIR\n</code></pre>"},{"location":"build/contract-integrations/native-token-transfers/deployment-process/deploy-to-solana/#set-spl-token-mint-authority","title":"Set SPL Token Mint Authority","text":"<p>In this step, you'll set SPL token mint authority to the newly generated token authority PDA:</p> <pre><code>spl-token authorize INSERT_TOKEN_ADDRESS mint INSERT_DERIVED_PDA\n</code></pre> <p>If deploying to Solana in <code>burning</code> mode, set the mint authority for your SPL token to the NTT program ID you generated in the previous step.</p>"},{"location":"build/contract-integrations/native-token-transfers/deployment-process/deploy-to-solana/#deploy-ntt_1","title":"Deploy NTT","text":"<p>Generate or export your payer key pair, then run:</p> <pre><code>ntt add-chain Solana --latest --mode burning --token INSERT_YOUR_SPL_TOKEN --payer INSERT_YOUR_KEYPAIR_JSON --program-key INSERT_YOUR_NTT_PROGRAM_KEYPAIR_JSON\n</code></pre> <p>The NTT Solana program will then compile and deploy.</p>"},{"location":"build/contract-integrations/native-token-transfers/deployment-process/deploy-to-solana/#configure-ntt","title":"Configure NTT","text":"<p>As with other deployments, run the following commands to ensure that the on-chain configuration is correct and your local <code>deployment.json</code> file is synced with the on-chain state:</p> <pre><code>ntt status\n</code></pre> <pre><code>ntt pull\n</code></pre>"},{"location":"build/contract-integrations/native-token-transfers/deployment-process/deploy-to-solana/#deploy","title":"Deploy","text":"<p>You can now push the deployment to the Solana network, specifying the key pair that will cover the gas fees:</p> <pre><code>ntt push --payer INSERT_YOUR_KEYPAIR_JSON\n</code></pre> <p>By default, NTT transfers to Solana support manual relaying, which requires the user to perform a transaction on Solana to complete the transfer. UI components such as Wormhole Connect support this out of the box. For automatic Wormhole relaying support on Solana, contact Wormhole contributors.</p>"},{"location":"build/contract-integrations/native-token-transfers/deployment-process/installation/","title":"Native Token Transfers Installation","text":""},{"location":"build/contract-integrations/native-token-transfers/deployment-process/installation/#installation","title":"Installation","text":"<p>The fastest way to deploy Native Token Transfer (NTT) is using the NTT CLI. As prerequisites, ensure you have the following installed:</p> <ul> <li>Install Foundry</li> <li>Install Bun</li> </ul> <p>Install the NTT CLI:</p> <pre><code>curl -fsSL https://raw.githubusercontent.com/wormhole-foundation/example-native-token-transfers/cli/cli/install.sh | bash\n</code></pre> <p>Verify the NTT CLI is installed:</p> <pre><code>ntt --version\n</code></pre>"},{"location":"build/contract-integrations/native-token-transfers/deployment-process/post-deployment/","title":"Native Token Transfers (NTT) Post Deployment","text":""},{"location":"build/contract-integrations/native-token-transfers/deployment-process/post-deployment/#post-deployment","title":"Post Deployment","text":"<p>To offer the best user experience and ensure the most robust deployment, Wormhole contributors recommend the following after you have deployed NTT:</p> <ul> <li>Implement a robust testing plan for your multichain token before launching</li> <li>Ensure comprehensive, documented security measures are followed regarding custody of contract ownership, control of keys, and access control roles</li> <li>Consider a streamlined, customizable frontend such as Wormhole Connect for an optimized user experience</li> <li>Alternatively the Wormhole SDK allows for a direct integration into your infrastructure</li> <li>Ensure ecosystem actors such as block explorers, automated security tools (such as BlockAid and Blowfish), wallets (such as MetaMask, Backpack, and Phantom) are aware of your multichain deployment and that it is labeled appropriately</li> <li>Monitor and maintain your multichain deployment</li> </ul>"},{"location":"build/reference/","title":"Reference","text":""},{"location":"build/reference/#get-started","title":"Get Started","text":"<p>In this section, you'll find reference information that is essential for development. This includes Wormhole chain IDs, canonical contract addresses, and consistency levels for Guardians for each of the supported blockchains in the Wormhole ecosystem.</p> <ul> <li> <p> Chain IDs</p> <p>Find a mapping of Wormhole chain IDs to the names and network IDs of the supported blockchains.</p> <p> View list of chain IDs</p> </li> <li> <p> Consistency Levels</p> <p>See the levels of finality (consistency) a transaction should meet before being signed by a Guardian for each network.</p> <p> View list of consistency levels</p> </li> <li> <p> Contract Addresses</p> <p>Discover the contract addresses for Wormhole-deployed contracts on each of the supported blockchains.</p> <p>This includes the following protocol contracts:</p> <ul> <li>Core Contract</li> <li>Token Bridge</li> <li>NFT Bridge</li> <li>Wormhole relayer</li> <li>CCTP</li> <li>Gateway</li> </ul> <p> View list of contract addresses</p> </li> </ul>"},{"location":"build/reference/chain-ids/","title":"Chain IDs","text":"<p>The following table documents the chain IDs used by Wormhole and places them alongside the more commonly referenced EVM Chain IDs.</p> <p>Note</p> <p>Please note, Wormhole chain IDs are different than the more commonly referenced EVM chain IDs, specified in the MainNet and TestNet ID columns.</p> MainNetTestNet <p>Chain NameWormhole Chain IDNetwork IDEthereum<code>2</code><code>1</code>Solana<code>1</code><code>Mainnet Beta</code> - <code>5eykt4UsFv8P8NJdTREpY1vzqKqZKvdpKuc147dw2N9d</code>Acala<code>12</code><code>787</code>Algorand<code>8</code><code>mainnet-v1.0</code>Aptos<code>22</code><code>1</code>Arbitrum<code>23</code><code>Arbitrum One</code> - <code>42161</code>Avalanche<code>6</code><code>C-Chain</code> - <code>43114</code>Base<code>30</code><code>Base</code> - <code>8453</code>Berachain<code>39</code>Blast<code>36</code><code>81457</code>BNB Smart Chain<code>4</code><code>56</code>Celestia<code>4004</code><code>celestia</code>Celo<code>14</code><code>42220</code>Cosmoshub<code>4000</code><code>cosmoshub-4</code>Dymension<code>4007</code><code>dymension_1100-1</code>Evmos<code>4001</code><code>evmos_9001-2</code>Fantom<code>10</code><code>250</code>Gnosis<code>25</code><code>100</code>Injective<code>19</code><code>injective-1</code>Karura<code>11</code><code>686</code>Klaytn<code>13</code><code>8217</code>Kujira<code>4002</code><code>kaiyo-1</code>Linea<code>38</code><code>59144</code>Mantle<code>35</code><code>5000</code>Moonbeam<code>16</code><code>1284</code>NEAR<code>15</code><code>mainnet</code>Neon<code>17</code><code>245022934</code>Neutron<code>4003</code><code>neutron-1</code>Oasis<code>7</code><code>42262</code>Optimism<code>24</code><code>10</code>Osmosis<code>20</code><code>osmosis-1</code>Polygon<code>5</code><code>137</code>Provenance<code>4008</code><code>pio-mainnet-1</code>Pythnet<code>26</code>Rootstock<code>33</code><code>30</code>Scroll<code>34</code><code>534352</code>Seda<code>4006</code>Sei<code>32</code><code>pacific-1</code>Seievm<code>40</code>Stargaze<code>4005</code><code>stargaze-1</code>Sui<code>21</code><code>35834a8a</code>Terra<code>3</code><code>columbus-5</code>Terra2<code>18</code><code>phoenix-1</code>Xlayer<code>37</code><code>196</code>Xpla<code>28</code><code>dimension_37-1</code></p> <p>Chain NameWormhole Chain IDNetwork IDEthereum<code>2</code><code>Goerli</code> - <code>5</code>Ethereum Holesky<code>10006</code><code>Holesky</code> - <code>17000</code>Ethereum Sepolia<code>10002</code><code>Sepolia</code> - <code>11155111</code>Solana<code>1</code><code>Devnet</code> - <code>EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG</code>Acala<code>12</code><code>597</code>Algorand<code>8</code><code>testnet-v1.0</code>Aptos<code>22</code><code>2</code>Arbitrum<code>23</code><code>Goerli</code> - <code>421613</code>Arbitrum Sepolia<code>10003</code><code>Sepolia</code> - <code>421614</code>Avalanche<code>6</code><code>Fuji</code> - <code>43113</code>Base<code>30</code><code>Base Goerli</code> - <code>84531</code>Base Sepolia<code>10004</code><code>Base Sepolia</code> - <code>84532</code>Berachain<code>39</code><code>80084</code>Blast<code>36</code><code>168587773</code>BNB Smart Chain<code>4</code><code>97</code>Celestia<code>4004</code><code>mocha-4</code>Celo<code>14</code><code>Alfajores</code> - <code>44787</code>Cosmoshub<code>4000</code><code>theta-testnet-001</code>Dymension<code>4007</code>Evmos<code>4001</code><code>evmos_9000-4</code>Fantom<code>10</code><code>4002</code>Gnosis<code>25</code><code>Chaido</code> - <code>10200</code>Injective<code>19</code><code>injective-888</code>Karura<code>11</code><code>596</code>Klaytn<code>13</code><code>Baobab</code> - <code>1001</code>Kujira<code>4002</code><code>harpoon-4</code>Linea<code>38</code><code>59141</code>Mantle<code>35</code><code>Sepolia</code> - <code>5003</code>Moonbeam<code>16</code><code>Moonbase-Alphanet</code> - <code>1287</code>NEAR<code>15</code><code>testnet</code>Neon<code>17</code><code>245022940</code>Neutron<code>4003</code><code>pion-1</code>Oasis<code>7</code><code>42261</code>Optimism<code>24</code><code>Optimism Goerli</code> - <code>420</code>Optimism Sepolia<code>10005</code><code>Optimism Sepolia</code> - <code>11155420</code>Osmosis<code>20</code><code>osmo-test-5</code>Polygon<code>5</code><code>Mumbai</code> - <code>80001</code>Polygon Sepolia<code>10007</code><code>Sepolia</code> - <code>80002</code>Provenance<code>4008</code>Pythnet<code>26</code>Rootstock<code>33</code><code>31</code>Scroll<code>34</code><code>Sepolia</code> - <code>534351</code>Seda<code>4006</code><code>seda-1-testnet</code>Sei<code>32</code><code>atlantic-2</code>Seievm<code>40</code>Stargaze<code>4005</code>Sui<code>21</code><code>4c78adac</code>Terra<code>3</code><code>bombay-12</code>Terra2<code>18</code><code>pisco-1</code>Xlayer<code>37</code><code>195</code>Xpla<code>28</code><code>cube_47-5</code></p>"},{"location":"build/reference/consistency-levels/","title":"Consistency Levels","text":"<p>The following table documents each chain's <code>consistencyLevel</code> values (i.e., finality reached before signing). The consistency level defines how long the Guardians should wait before signing a VAA. The finalization time depends on the specific chain's consensus mechanism. The consistency level is a <code>u8</code>, so any single byte may be used. However, a small subset has particular meanings. If the <code>consistencyLevel</code> isn't one of those specific values, the <code>Otherwise</code> column describes how it's interpreted.</p> ChainInstantSafeFinalizedOtherwiseTime to FinalizeDetailsEthereum200201finalized~ 975sDetailsSolana01~ 14sDetailsAcala200201finalized~ 24sAlgorand0~ 4sDetailsAptos0~ 4sDetailsArbitrum200201finalized~ 1066sDetailsAvalanche200finalized~ 2sDetailsBase200201finalized~ 1026sBNB Smart Chain200201finalized~ 48sDetailsCelestia0~ 5sCelo200finalized~ 10sCosmoshub0~ 5sDymension0~ 5sEvmos0~ 2sFantom200finalized~ 5sInjective0~ 3sKarura200201finalized~ 24sDetailsKlaytn200finalized~ 1sKujira0~ 3sMoonbeam200201finalized~ 24sDetailsNEAR0~ 2sDetailsNeutron0~ 5sOasis200finalized~ 12sOptimism200201finalized~ 1026sDetailsOsmosis0~ 6sPolygon200finalized~ 66sDetailsSei0~ 1sStargaze0~ 5sSui0~ 3sDetailsTerra0~ 6sTerra20~ 6sXpla0~ 5s"},{"location":"build/reference/contract-addresses/","title":"Contract Addresses","text":""},{"location":"build/reference/contract-addresses/#core-contracts","title":"Core Contracts","text":"MainNetTestNetDevNet <p>Chain NameContract AddressEthereum<code>0x98f3c9e6E3fAce36bAAd05FE09d375Ef1464288B</code>Solana<code>worm2ZoG2kUd4vFXhvjh93UUH596ayRfgQ2MgjNMTth</code>Acala<code>0xa321448d90d4e5b0A732867c18eA198e75CAC48E</code>Algorand<code>842125965</code>Aptos<code>0x5bc11445584a763c1fa7ed39081f1b920954da14e04b32440cba863d03e19625</code>Arbitrum<code>0xa5f208e072434bC67592E4C49C1B991BA79BCA46</code>Avalanche<code>0x54a8e5f9c4CbA08F9943965859F6c34eAF03E26c</code>Base<code>0xbebdb6C8ddC678FfA9f8748f85C815C556Dd8ac6</code>Berachain<code>-</code>Blast<code>0xbebdb6C8ddC678FfA9f8748f85C815C556Dd8ac6</code>BNB Smart Chain<code>0x98f3c9e6E3fAce36bAAd05FE09d375Ef1464288B</code>Celestia<code>-</code>Celo<code>0xa321448d90d4e5b0A732867c18eA198e75CAC48E</code>Cosmoshub<code>-</code>Dymension<code>-</code>Evmos<code>-</code>Fantom<code>0x126783A6Cb203a3E35344528B26ca3a0489a1485</code>Gnosis<code>0xa321448d90d4e5b0A732867c18eA198e75CAC48E</code>Injective<code>inj17p9rzwnnfxcjp32un9ug7yhhzgtkhvl9l2q74d</code>Karura<code>0xa321448d90d4e5b0A732867c18eA198e75CAC48E</code>Klaytn<code>0x0C21603c4f3a6387e241c0091A7EA39E43E90bb7</code>Kujira<code>-</code>Linea<code>-</code>Mantle<code>0xbebdb6C8ddC678FfA9f8748f85C815C556Dd8ac6</code>Moonbeam<code>0xC8e2b0cD52Cf01b0Ce87d389Daa3d414d4cE29f3</code>NEAR<code>contract.wormhole_crypto.near</code>Neon<code>-</code>Neutron<code>neutron16rerygcpahqcxx5t8vjla46ym8ccn7xz7rtc6ju5ujcd36cmc7zs9zrunh</code>Oasis<code>0xfE8cD454b4A1CA468B57D79c0cc77Ef5B6f64585</code>Optimism<code>0xEe91C335eab126dF5fDB3797EA9d6aD93aeC9722</code>Osmosis<code>-</code>Polygon<code>0x7A4B5a56256163F07b2C80A7cA55aBE66c4ec4d7</code>Provenance<code>-</code>Pythnet<code>H3fxXJ86ADW2PNuDDmZJg6mzTtPxkYCpNuQUTgmJ7AjU</code>Rootstock<code>0xbebdb6C8ddC678FfA9f8748f85C815C556Dd8ac6</code>Scroll<code>0xbebdb6C8ddC678FfA9f8748f85C815C556Dd8ac6</code>Seda<code>-</code>Sei<code>sei1gjrrme22cyha4ht2xapn3f08zzw6z3d4uxx6fyy9zd5dyr3yxgzqqncdqn</code>Seievm<code>-</code>Stargaze<code>-</code>Sui<code>0xaeab97f96cf9877fee2883315d459552b2b921edc16d7ceac6eab944dd88919c</code>Terra<code>terra1dq03ugtd40zu9hcgdzrsq6z2z4hwhc9tqk2uy5</code>Terra2<code>terra12mrnzvhx3rpej6843uge2yyfppfyd3u9c3uq223q8sl48huz9juqffcnhp</code>Xlayer<code>0x194B123c5E96B9b2E49763619985790Dc241CAC0</code>Xpla<code>xpla1jn8qmdda5m6f6fqu9qv46rt7ajhklg40ukpqchkejcvy8x7w26cqxamv3w</code></p> <p>Chain NameContract AddressEthereum<code>0x706abc4E45D419950511e474C7B9Ed348A4a716c</code>Ethereum Holesky<code>0xa10f2eF61dE1f19f586ab8B6F2EbA89bACE63F7a</code>Ethereum Sepolia<code>0x4a8bc80Ed5a4067f1CCf107057b8270E0cC11A78</code>Solana<code>3u8hJUVTA4jH1wYAyUur7FFZVQ8H635K3tSHHF4ssjQ5</code>Acala<code>0x4377B49d559c0a9466477195C6AdC3D433e265c0</code>Algorand<code>86525623</code>Aptos<code>0x5bc11445584a763c1fa7ed39081f1b920954da14e04b32440cba863d03e19625</code>Arbitrum<code>0xC7A204bDBFe983FCD8d8E61D02b475D4073fF97e</code>Arbitrum Sepolia<code>0x6b9C8671cdDC8dEab9c719bB87cBd3e782bA6a35</code>Avalanche<code>0x7bbcE28e64B3F8b84d876Ab298393c38ad7aac4C</code>Base<code>0x23908A62110e21C04F3A4e011d24F901F911744A</code>Base Sepolia<code>0x79A1027a6A159502049F10906D333EC57E95F083</code>Berachain<code>0xBB73cB66C26740F31d1FabDC6b7A46a038A300dd</code>Blast<code>0x473e002D7add6fB67a4964F13bFd61280Ca46886</code>BNB Smart Chain<code>0x68605AD7b15c732a30b1BbC62BE8F2A509D74b4D</code>Celestia<code>-</code>Celo<code>0x88505117CA88e7dd2eC6EA1E13f0948db2D50D56</code>Cosmoshub<code>-</code>Dymension<code>-</code>Evmos<code>-</code>Fantom<code>0x1BB3B4119b7BA9dfad76B0545fb3F531383c3bB7</code>Gnosis<code>0xE4eacc10990ba3308DdCC72d985f2a27D20c7d03</code>Injective<code>inj1xx3aupmgv3ce537c0yce8zzd3sz567syuyedpg</code>Karura<code>0xE4eacc10990ba3308DdCC72d985f2a27D20c7d03</code>Klaytn<code>0x1830CC6eE66c84D2F177B94D544967c774E624cA</code>Kujira<code>-</code>Linea<code>0x79A1027a6A159502049F10906D333EC57E95F083</code>Mantle<code>0x376428e7f26D5867e69201b275553C45B09EE090</code>Moonbeam<code>0xa5B7D85a8f27dd7907dc8FdC21FA5657D5E2F901</code>NEAR<code>wormhole.wormhole.testnet</code>Neon<code>-</code>Neutron<code>neutron1enf63k37nnv9cugggpm06mg70emcnxgj9p64v2s8yx7a2yhhzk2q6xesk4</code>Oasis<code>0xc1C338397ffA53a2Eb12A7038b4eeb34791F8aCb</code>Optimism<code>0x6b9C8671cdDC8dEab9c719bB87cBd3e782bA6a35</code>Optimism Sepolia<code>0x31377888146f3253211EFEf5c676D41ECe7D58Fe</code>Osmosis<code>osmo1hggkxr0hpw83f8vuft7ruvmmamsxmwk2hzz6nytdkzyup9krt0dq27sgyx</code>Polygon<code>0x0CBE91CF822c73C2315FB05100C2F714765d5c20</code>Polygon Sepolia<code>0x6b9C8671cdDC8dEab9c719bB87cBd3e782bA6a35</code>Provenance<code>-</code>Pythnet<code>EUrRARh92Cdc54xrDn6qzaqjA77NRrCcfbr8kPwoTL4z</code>Rootstock<code>0xbebdb6C8ddC678FfA9f8748f85C815C556Dd8ac6</code>Scroll<code>0x055F47F1250012C6B20c436570a76e52c17Af2D5</code>Seda<code>-</code>Sei<code>sei1nna9mzp274djrgzhzkac2gvm3j27l402s4xzr08chq57pjsupqnqaj0d5s</code>Seievm<code>0x07782FCe991dAb4DE7a3124032E534A0D059B4d8</code>Stargaze<code>-</code>Sui<code>0x31358d198147da50db32eda2562951d53973a0c0ad5ed738e9b17d88b213d790</code>Terra<code>terra1pd65m0q9tl3v8znnz5f5ltsfegyzah7g42cx5v</code>Terra2<code>terra19nv3xr5lrmmr7egvrk2kqgw4kcn43xrtd5g0mpgwwvhetusk4k7s66jyv0</code>Xlayer<code>0xA31aa3FDb7aF7Db93d18DDA4e19F811342EDF780</code>Xpla<code>xpla1upkjn4mthr0047kahvn0llqx4qpqfn75lnph4jpxfn8walmm8mqsanyy35</code></p> <p>Chain NameContract AddressEthereum<code>0xC89Ce4735882C9F0f0FE26686c53074E09B0D550</code>Ethereum Sepolia<code>-</code>Ethereum Holesky<code>-</code>Solana<code>Bridge1p5gheXUvJ6jGWGeCsgPKgnE3YgdGKRVCMY9o</code>Acala<code>-</code>Algorand<code>1004</code>Aptos<code>0xde0036a9600559e295d5f6802ef6f3f802f510366e0c23912b0655d972166017</code>Arbitrum<code>-</code>Arbitrum Sepolia<code>-</code>Avalanche<code>-</code>Base<code>-</code>Base Sepolia<code>-</code>Berachain<code>-</code>Blast<code>-</code>BNB Smart Chain<code>0xC89Ce4735882C9F0f0FE26686c53074E09B0D550</code>Celestia<code>-</code>Celo<code>-</code>Cosmoshub<code>-</code>Dymension<code>-</code>Evmos<code>-</code>Fantom<code>-</code>Gnosis<code>-</code>Injective<code>-</code>Karura<code>-</code>Klaytn<code>-</code>Kujira<code>-</code>Linea<code>-</code>Mantle<code>-</code>Moonbeam<code>-</code>NEAR<code>wormhole.test.near</code>Neon<code>-</code>Neutron<code>-</code>Oasis<code>-</code>Optimism<code>-</code>Optimism Sepolia<code>-</code>Osmosis<code>-</code>Polygon<code>-</code>Polygon Sepolia<code>-</code>Provenance<code>-</code>Pythnet<code>-</code>Rootstock<code>-</code>Scroll<code>-</code>Seda<code>-</code>Sei<code>-</code>Seievm<code>-</code>Stargaze<code>-</code>Sui<code>0x12253210c90f89e7a8525e6c52d41309ff5bfb31f43f561b5fe6f50cd72f9668</code>Terra<code>terra14hj2tavq8fpesdwxxcu44rty3hh90vhujrvcmstl4zr3txmfvw9ssrc8au</code>Terra2<code>terra14hj2tavq8fpesdwxxcu44rty3hh90vhujrvcmstl4zr3txmfvw9ssrc8au</code>Xlayer<code>-</code>Xpla<code>-</code></p>"},{"location":"build/reference/contract-addresses/#token-bridge","title":"Token Bridge","text":"MainNetTestNetDevNet <p>Chain NameContract AddressEthereum<code>0x3ee18B2214AFF97000D974cf647E7C347E8fa585</code>Solana<code>wormDTUJ6AWPNvk59vGQbDvGJmqbDTdgWgAqcLBCgUb</code>Acala<code>0xae9d7fe007b3327AA64A32824Aaac52C42a6E624</code>Algorand<code>842126029</code>Aptos<code>0x576410486a2da45eee6c949c995670112ddf2fbeedab20350d506328eefc9d4f</code>Arbitrum<code>0x0b2402144Bb366A632D14B83F244D2e0e21bD39c</code>Avalanche<code>0x0e082F06FF657D94310cB8cE8B0D9a04541d8052</code>Base<code>0x8d2de8d2f73F1F4cAB472AC9A881C9b123C79627</code>Berachain<code>-</code>Blast<code>0x24850c6f61C438823F01B7A3BF2B89B72174Fa9d</code>BNB Smart Chain<code>0xB6F6D86a8f9879A9c87f643768d9efc38c1Da6E7</code>Celestia<code>-</code>Celo<code>0x796Dff6D74F3E27060B71255Fe517BFb23C93eed</code>Cosmoshub<code>-</code>Dymension<code>-</code>Evmos<code>-</code>Fantom<code>0x7C9Fc5741288cDFdD83CeB07f3ea7e22618D79D2</code>Gnosis<code>-</code>Injective<code>inj1ghd753shjuwexxywmgs4xz7x2q732vcnxxynfn</code>Karura<code>0xae9d7fe007b3327AA64A32824Aaac52C42a6E624</code>Klaytn<code>0x5b08ac39EAED75c0439FC750d9FE7E1F9dD0193F</code>Kujira<code>-</code>Linea<code>-</code>Mantle<code>0x24850c6f61C438823F01B7A3BF2B89B72174Fa9d</code>Moonbeam<code>0xb1731c586ca89a23809861c6103f0b96b3f57d92</code>NEAR<code>contract.portalbridge.near</code>Neon<code>-</code>Neutron<code>-</code>Oasis<code>0x5848C791e09901b40A9Ef749f2a6735b418d7564</code>Optimism<code>0x1D68124e65faFC907325e3EDbF8c4d84499DAa8b</code>Osmosis<code>-</code>Polygon<code>0x5a58505a96D1dbf8dF91cB21B54419FC36e93fdE</code>Provenance<code>-</code>Pythnet<code>-</code>Rootstock<code>-</code>Scroll<code>0x24850c6f61C438823F01B7A3BF2B89B72174Fa9d</code>Seda<code>-</code>Sei<code>sei1smzlm9t79kur392nu9egl8p8je9j92q4gzguewj56a05kyxxra0qy0nuf3</code>Seievm<code>-</code>Stargaze<code>-</code>Sui<code>0xc57508ee0d4595e5a8728974a4a93a787d38f339757230d441e895422c07aba9</code>Terra<code>terra10nmmwe8r3g99a9newtqa7a75xfgs2e8z87r2sf</code>Terra2<code>terra153366q50k7t8nn7gec00hg66crnhkdggpgdtaxltaq6xrutkkz3s992fw9</code>Xlayer<code>0x5537857664B0f9eFe38C9f320F75fEf23234D904</code>Xpla<code>xpla137w0wfch2dfmz7jl2ap8pcmswasj8kg06ay4dtjzw7tzkn77ufxqfw7acv</code></p> <p>Chain NameContract AddressEthereum<code>0xF890982f9310df57d00f659cf4fd87e65adEd8d7</code>Ethereum Holesky<code>0x76d093BbaE4529a342080546cAFEec4AcbA59EC6</code>Ethereum Sepolia<code>0xDB5492265f6038831E89f495670FF909aDe94bd9</code>Solana<code>DZnkkTmCiFWfYTfT41X3Rd1kDgozqzxWaHqsw6W4x2oe</code>Acala<code>0xebA00cbe08992EdD08ed7793E07ad6063c807004</code>Algorand<code>86525641</code>Aptos<code>0x576410486a2da45eee6c949c995670112ddf2fbeedab20350d506328eefc9d4f</code>Arbitrum<code>0x23908A62110e21C04F3A4e011d24F901F911744A</code>Arbitrum Sepolia<code>0xC7A204bDBFe983FCD8d8E61D02b475D4073fF97e</code>Avalanche<code>0x61E44E506Ca5659E6c0bba9b678586fA2d729756</code>Base<code>0xA31aa3FDb7aF7Db93d18DDA4e19F811342EDF780</code>Base Sepolia<code>0x86F55A04690fd7815A3D802bD587e83eA888B239</code>Berachain<code>0xa10f2eF61dE1f19f586ab8B6F2EbA89bACE63F7a</code>Blast<code>0x430855B4D43b8AEB9D2B9869B74d58dda79C0dB2</code>BNB Smart Chain<code>0x9dcF9D205C9De35334D646BeE44b2D2859712A09</code>Celestia<code>-</code>Celo<code>0x05ca6037eC51F8b712eD2E6Fa72219FEaE74E153</code>Cosmoshub<code>-</code>Dymension<code>-</code>Evmos<code>-</code>Fantom<code>0x599CEa2204B4FaECd584Ab1F2b6aCA137a0afbE8</code>Gnosis<code>-</code>Injective<code>inj1q0e70vhrv063eah90mu97sazhywmeegp7myvnh</code>Karura<code>0xd11De1f930eA1F7Dd0290Fe3a2e35b9C91AEFb37</code>Klaytn<code>0xC7A13BE098720840dEa132D860fDfa030884b09A</code>Kujira<code>-</code>Linea<code>0xC7A204bDBFe983FCD8d8E61D02b475D4073fF97e</code>Mantle<code>0x75Bfa155a9D7A3714b0861c8a8aF0C4633c45b5D</code>Moonbeam<code>0xbc976D4b9D57E57c3cA52e1Fd136C45FF7955A96</code>NEAR<code>token.wormhole.testnet</code>Neon<code>-</code>Neutron<code>-</code>Oasis<code>0x88d8004A9BdbfD9D28090A02010C19897a29605c</code>Optimism<code>0xC7A204bDBFe983FCD8d8E61D02b475D4073fF97e</code>Optimism Sepolia<code>0x99737Ec4B815d816c49A385943baf0380e75c0Ac</code>Osmosis<code>-</code>Polygon<code>0x377D55a7928c046E18eEbb61977e714d2a76472a</code>Polygon Sepolia<code>0xC7A204bDBFe983FCD8d8E61D02b475D4073fF97e</code>Provenance<code>-</code>Pythnet<code>-</code>Rootstock<code>-</code>Scroll<code>0x22427d90B7dA3fA4642F7025A854c7254E4e45BF</code>Seda<code>-</code>Sei<code>sei1jv5xw094mclanxt5emammy875qelf3v62u4tl4lp5nhte3w3s9ts9w9az2</code>Seievm<code>-</code>Stargaze<code>-</code>Sui<code>0x6fb10cdb7aa299e9a4308752dadecb049ff55a892de92992a1edbd7912b3d6da</code>Terra<code>terra1pseddrv0yfsn76u4zxrjmtf45kdlmalswdv39a</code>Terra2<code>terra1c02vds4uhgtrmcw7ldlg75zumdqxr8hwf7npseuf2h58jzhpgjxsgmwkvk</code>Xlayer<code>0xdA91a06299BBF302091B053c6B9EF86Eff0f930D</code>Xpla<code>xpla1kek6zgdaxcsu35nqfsyvs2t9vs87dqkkq6hjdgczacysjn67vt8sern93x</code></p> <p>Chain NameContract AddressEthereum<code>0x0290FB167208Af455bB137780163b7B7a9a10C16</code>Ethereum Sepolia<code>-</code>Ethereum Holesky<code>-</code>Solana<code>B6RHG3mfcckmrYN1UhmJzyS1XX3fZKbkeUcpJe9Sy3FE</code>Acala<code>-</code>Algorand<code>1006</code>Aptos<code>0x84a5f374d29fc77e370014dce4fd6a55b58ad608de8074b0be5571701724da31</code>Arbitrum<code>-</code>Arbitrum Sepolia<code>-</code>Avalanche<code>-</code>Base<code>-</code>Base Sepolia<code>-</code>Berachain<code>-</code>Blast<code>-</code>BNB Smart Chain<code>0x0290FB167208Af455bB137780163b7B7a9a10C16</code>Celestia<code>-</code>Celo<code>-</code>Cosmoshub<code>-</code>Dymension<code>-</code>Evmos<code>-</code>Fantom<code>-</code>Gnosis<code>-</code>Injective<code>-</code>Karura<code>-</code>Klaytn<code>-</code>Kujira<code>-</code>Linea<code>-</code>Mantle<code>-</code>Moonbeam<code>-</code>NEAR<code>token.test.near</code>Neon<code>-</code>Neutron<code>-</code>Oasis<code>-</code>Optimism<code>-</code>Optimism Sepolia<code>-</code>Osmosis<code>-</code>Polygon<code>-</code>Polygon Sepolia<code>-</code>Provenance<code>-</code>Pythnet<code>-</code>Rootstock<code>-</code>Scroll<code>-</code>Seda<code>-</code>Sei<code>-</code>Seievm<code>-</code>Stargaze<code>-</code>Sui<code>0x830ed228c6f1bcb40003bb49af3277df2cbf933d63a6bcdcb0ba4580a1a7654e</code>Terra<code>terra1nc5tatafv6eyq7llkr2gv50ff9e22mnf70qgjlv737ktmt4eswrquka9l6</code>Terra2<code>terra1nc5tatafv6eyq7llkr2gv50ff9e22mnf70qgjlv737ktmt4eswrquka9l6</code>Xlayer<code>-</code>Xpla<code>-</code></p>"},{"location":"build/reference/contract-addresses/#nft-bridge","title":"NFT Bridge","text":"MainNetTestNetDevNet <p>Chain NameContract AddressEthereum<code>0x6FFd7EdE62328b3Af38FCD61461Bbfc52F5651fE</code>Solana<code>WnFt12ZrnzZrFZkt2xsNsaNWoQribnuQ5B5FrDbwDhD</code>Acala<code>0xb91e3638F82A1fACb28690b37e3aAE45d2c33808</code>Algorand<code>-</code>Aptos<code>0x1bdffae984043833ed7fe223f7af7a3f8902d04129b14f801823e64827da7130</code>Arbitrum<code>0x3dD14D553cFD986EAC8e3bddF629d82073e188c8</code>Avalanche<code>0xf7B6737Ca9c4e08aE573F75A97B73D7a813f5De5</code>Base<code>0xDA3adC6621B2677BEf9aD26598e6939CF0D92f88</code>Berachain<code>-</code>Blast<code>-</code>BNB Smart Chain<code>0x5a58505a96D1dbf8dF91cB21B54419FC36e93fdE</code>Celestia<code>-</code>Celo<code>0xA6A377d75ca5c9052c9a77ED1e865Cc25Bd97bf3</code>Cosmoshub<code>-</code>Dymension<code>-</code>Evmos<code>-</code>Fantom<code>0xA9c7119aBDa80d4a4E0C06C8F4d8cF5893234535</code>Gnosis<code>-</code>Injective<code>-</code>Karura<code>0xb91e3638F82A1fACb28690b37e3aAE45d2c33808</code>Klaytn<code>0x3c3c561757BAa0b78c5C025CdEAa4ee24C1dFfEf</code>Kujira<code>-</code>Linea<code>-</code>Mantle<code>-</code>Moonbeam<code>0x453cfbe096c0f8d763e8c5f24b441097d577bde2</code>NEAR<code>-</code>Neon<code>-</code>Neutron<code>-</code>Oasis<code>0x04952D522Ff217f40B5Ef3cbF659EcA7b952a6c1</code>Optimism<code>0xfE8cD454b4A1CA468B57D79c0cc77Ef5B6f64585</code>Osmosis<code>-</code>Polygon<code>0x90BBd86a6Fe93D3bc3ed6335935447E75fAb7fCf</code>Provenance<code>-</code>Pythnet<code>-</code>Rootstock<code>-</code>Scroll<code>-</code>Seda<code>-</code>Sei<code>-</code>Seievm<code>-</code>Stargaze<code>-</code>Sui<code>-</code>Terra<code>-</code>Terra2<code>-</code>Xlayer<code>-</code>Xpla<code>-</code></p> <p>Chain NameContract AddressEthereum<code>0xD8E4C2DbDd2e2bd8F1336EA691dBFF6952B1a6eB</code>Ethereum Holesky<code>0xc8941d483c45eF8FB72E4d1F9dDE089C95fF8171</code>Ethereum Sepolia<code>0x6a0B52ac198e4870e5F3797d5B403838a5bbFD99</code>Solana<code>2rHhojZ7hpu1zA91nvZmT8TqWWvMcKmmNBCr2mKTtMq4</code>Acala<code>0x96f1335e0AcAB3cfd9899B30b2374e25a2148a6E</code>Algorand<code>-</code>Aptos<code>0x1bdffae984043833ed7fe223f7af7a3f8902d04129b14f801823e64827da7130</code>Arbitrum<code>0xEe3dB83916Ccdc3593b734F7F2d16D630F39F1D0</code>Arbitrum Sepolia<code>0x23908A62110e21C04F3A4e011d24F901F911744A</code>Avalanche<code>0xD601BAf2EEE3C028344471684F6b27E789D9075D</code>Base<code>0xF681d1cc5F25a3694E348e7975d7564Aa581db59</code>Base Sepolia<code>0x268557122Ffd64c85750d630b716471118F323c8</code>Berachain<code>-</code>Blast<code>-</code>BNB Smart Chain<code>0xcD16E5613EF35599dc82B24Cb45B5A93D779f1EE</code>Celestia<code>-</code>Celo<code>0xaCD8190F647a31E56A656748bC30F69259f245Db</code>Cosmoshub<code>-</code>Dymension<code>-</code>Evmos<code>-</code>Fantom<code>0x63eD9318628D26BdCB15df58B53BB27231D1B227</code>Gnosis<code>-</code>Injective<code>-</code>Karura<code>0x0A693c2D594292B6Eb89Cb50EFe4B0b63Dd2760D</code>Klaytn<code>0x94c994fC51c13101062958b567e743f1a04432dE</code>Kujira<code>-</code>Linea<code>-</code>Mantle<code>-</code>Moonbeam<code>0x98A0F4B96972b32Fcb3BD03cAeB66A44a6aB9Edb</code>NEAR<code>-</code>Neon<code>-</code>Neutron<code>-</code>Oasis<code>0xC5c25B41AB0b797571620F5204Afa116A44c0ebA</code>Optimism<code>0x23908A62110e21C04F3A4e011d24F901F911744A</code>Optimism Sepolia<code>0x27812285fbe85BA1DF242929B906B31EE3dd1b9f</code>Osmosis<code>-</code>Polygon<code>0x51a02d0dcb5e52F5b92bdAA38FA013C91c7309A9</code>Polygon Sepolia<code>0x23908A62110e21C04F3A4e011d24F901F911744A</code>Provenance<code>-</code>Pythnet<code>-</code>Rootstock<code>-</code>Scroll<code>-</code>Seda<code>-</code>Sei<code>-</code>Seievm<code>-</code>Stargaze<code>-</code>Sui<code>-</code>Terra<code>-</code>Terra2<code>-</code>Xlayer<code>-</code>Xpla<code>-</code></p> <p>Chain NameContract AddressEthereum<code>0x26b4afb60d6c903165150c6f0aa14f8016be4aec</code>Ethereum Sepolia<code>-</code>Ethereum Holesky<code>-</code>Solana<code>NFTWqJR8YnRVqPDvTJrYuLrQDitTG5AScqbeghi4zSA</code>Acala<code>-</code>Algorand<code>-</code>Aptos<code>0x46da3d4c569388af61f951bdd1153f4c875f90c2991f6b2d0a38e2161a40852c</code>Arbitrum<code>-</code>Arbitrum Sepolia<code>-</code>Avalanche<code>-</code>Base<code>-</code>Base Sepolia<code>-</code>Berachain<code>-</code>Blast<code>-</code>BNB Smart Chain<code>0x26b4afb60d6c903165150c6f0aa14f8016be4aec</code>Celestia<code>-</code>Celo<code>-</code>Cosmoshub<code>-</code>Dymension<code>-</code>Evmos<code>-</code>Fantom<code>-</code>Gnosis<code>-</code>Injective<code>-</code>Karura<code>-</code>Klaytn<code>-</code>Kujira<code>-</code>Linea<code>-</code>Mantle<code>-</code>Moonbeam<code>-</code>NEAR<code>-</code>Neon<code>-</code>Neutron<code>-</code>Oasis<code>-</code>Optimism<code>-</code>Optimism Sepolia<code>-</code>Osmosis<code>-</code>Polygon<code>-</code>Polygon Sepolia<code>-</code>Provenance<code>-</code>Pythnet<code>-</code>Rootstock<code>-</code>Scroll<code>-</code>Seda<code>-</code>Sei<code>-</code>Seievm<code>-</code>Stargaze<code>-</code>Sui<code>-</code>Terra<code>-</code>Terra2<code>-</code>Xlayer<code>-</code>Xpla<code>-</code></p>"},{"location":"build/reference/contract-addresses/#wormhole-relayer","title":"Wormhole Relayer","text":"MainNetTestNetDevNet <p>Chain NameContract AddressEthereum<code>0x27428DD2d3DD32A4D7f7C497eAaa23130d894911</code>Solana<code>-</code>Acala<code>0x27428DD2d3DD32A4D7f7C497eAaa23130d894911</code>Algorand<code>-</code>Aptos<code>-</code>Arbitrum<code>0x27428DD2d3DD32A4D7f7C497eAaa23130d894911</code>Avalanche<code>0x27428DD2d3DD32A4D7f7C497eAaa23130d894911</code>Base<code>0x706f82e9bb5b0813501714ab5974216704980e31</code>Berachain<code>-</code>Blast<code>0x27428DD2d3DD32A4D7f7C497eAaa23130d894911</code>BNB Smart Chain<code>0x27428DD2d3DD32A4D7f7C497eAaa23130d894911</code>Celestia<code>-</code>Celo<code>0x27428DD2d3DD32A4D7f7C497eAaa23130d894911</code>Cosmoshub<code>-</code>Dymension<code>-</code>Evmos<code>-</code>Fantom<code>0x27428DD2d3DD32A4D7f7C497eAaa23130d894911</code>Gnosis<code>-</code>Injective<code>-</code>Karura<code>0x27428DD2d3DD32A4D7f7C497eAaa23130d894911</code>Klaytn<code>0x27428DD2d3DD32A4D7f7C497eAaa23130d894911</code>Kujira<code>-</code>Linea<code>-</code>Mantle<code>-</code>Moonbeam<code>0x27428DD2d3DD32A4D7f7C497eAaa23130d894911</code>NEAR<code>-</code>Neon<code>-</code>Neutron<code>-</code>Oasis<code>-</code>Optimism<code>0x27428DD2d3DD32A4D7f7C497eAaa23130d894911</code>Osmosis<code>-</code>Polygon<code>0x27428DD2d3DD32A4D7f7C497eAaa23130d894911</code>Provenance<code>-</code>Pythnet<code>-</code>Rootstock<code>-</code>Scroll<code>0x27428DD2d3DD32A4D7f7C497eAaa23130d894911</code>Seda<code>-</code>Sei<code>-</code>Seievm<code>-</code>Stargaze<code>-</code>Sui<code>-</code>Terra<code>-</code>Terra2<code>-</code>Xlayer<code>-</code>Xpla<code>-</code></p> <p>Chain NameContract AddressEthereum<code>0x28D8F1Be96f97C1387e94A53e00eCcFb4E75175a</code>Ethereum Holesky<code>-</code>Ethereum Sepolia<code>0x7B1bD7a6b4E61c2a123AC6BC2cbfC614437D0470</code>Solana<code>-</code>Acala<code>-</code>Algorand<code>-</code>Aptos<code>-</code>Arbitrum<code>0xAd753479354283eEE1b86c9470c84D42f229FF43</code>Arbitrum Sepolia<code>0x7B1bD7a6b4E61c2a123AC6BC2cbfC614437D0470</code>Avalanche<code>0xA3cF45939bD6260bcFe3D66bc73d60f19e49a8BB</code>Base<code>0xea8029CD7FCAEFFcD1F53686430Db0Fc8ed384E1</code>Base Sepolia<code>0x93BAD53DDfB6132b0aC8E37f6029163E63372cEE</code>Berachain<code>-</code>Blast<code>-</code>BNB Smart Chain<code>0x80aC94316391752A193C1c47E27D382b507c93F3</code>Celestia<code>-</code>Celo<code>0x306B68267Deb7c5DfCDa3619E22E9Ca39C374f84</code>Cosmoshub<code>-</code>Dymension<code>-</code>Evmos<code>-</code>Fantom<code>-</code>Gnosis<code>-</code>Injective<code>-</code>Karura<code>-</code>Klaytn<code>-</code>Kujira<code>-</code>Linea<code>-</code>Mantle<code>-</code>Moonbeam<code>0x0591C25ebd0580E0d4F27A82Fc2e24E7489CB5e0</code>NEAR<code>-</code>Neon<code>-</code>Neutron<code>-</code>Oasis<code>-</code>Optimism<code>0x01A957A525a5b7A72808bA9D10c389674E459891</code>Optimism Sepolia<code>0x93BAD53DDfB6132b0aC8E37f6029163E63372cEE</code>Osmosis<code>-</code>Polygon<code>0x0591C25ebd0580E0d4F27A82Fc2e24E7489CB5e0</code>Polygon Sepolia<code>-</code>Provenance<code>-</code>Pythnet<code>-</code>Rootstock<code>-</code>Scroll<code>-</code>Seda<code>-</code>Sei<code>-</code>Seievm<code>-</code>Stargaze<code>-</code>Sui<code>-</code>Terra<code>-</code>Terra2<code>-</code>Xlayer<code>-</code>Xpla<code>-</code></p> <p>Chain NameContract AddressEthereum<code>0xb98F46E96cb1F519C333FdFB5CCe0B13E0300ED4</code>Ethereum Sepolia<code>-</code>Ethereum Holesky<code>-</code>Solana<code>-</code>Acala<code>-</code>Algorand<code>-</code>Aptos<code>-</code>Arbitrum<code>-</code>Arbitrum Sepolia<code>-</code>Avalanche<code>-</code>Base<code>-</code>Base Sepolia<code>-</code>Berachain<code>-</code>Blast<code>-</code>BNB Smart Chain<code>0xb98F46E96cb1F519C333FdFB5CCe0B13E0300ED4</code>Celestia<code>-</code>Celo<code>-</code>Cosmoshub<code>-</code>Dymension<code>-</code>Evmos<code>-</code>Fantom<code>-</code>Gnosis<code>-</code>Injective<code>-</code>Karura<code>-</code>Klaytn<code>-</code>Kujira<code>-</code>Linea<code>-</code>Mantle<code>-</code>Moonbeam<code>-</code>NEAR<code>-</code>Neon<code>-</code>Neutron<code>-</code>Oasis<code>-</code>Optimism<code>-</code>Optimism Sepolia<code>-</code>Osmosis<code>-</code>Polygon<code>-</code>Polygon Sepolia<code>-</code>Provenance<code>-</code>Pythnet<code>-</code>Rootstock<code>-</code>Scroll<code>-</code>Seda<code>-</code>Sei<code>-</code>Seievm<code>-</code>Stargaze<code>-</code>Sui<code>-</code>Terra<code>-</code>Terra2<code>-</code>Xlayer<code>-</code>Xpla<code>-</code></p>"},{"location":"build/reference/contract-addresses/#cctp","title":"CCTP","text":"MainNetTestNetDevNet <p>Chain NameContract AddressEthereum<code>0xAaDA05BD399372f0b0463744C09113c137636f6a</code>Solana<code>-</code>Acala<code>-</code>Algorand<code>-</code>Aptos<code>-</code>Arbitrum<code>0x2703483B1a5a7c577e8680de9Df8Be03c6f30e3c</code>Avalanche<code>0x09Fb06A271faFf70A651047395AaEb6265265F13</code>Base<code>0x03faBB06Fa052557143dC28eFCFc63FC12843f1D</code>Berachain<code>-</code>Blast<code>-</code>BNB Smart Chain<code>-</code>Celestia<code>-</code>Celo<code>-</code>Cosmoshub<code>-</code>Dymension<code>-</code>Evmos<code>-</code>Fantom<code>-</code>Gnosis<code>-</code>Injective<code>-</code>Karura<code>-</code>Klaytn<code>-</code>Kujira<code>-</code>Linea<code>-</code>Mantle<code>-</code>Moonbeam<code>-</code>NEAR<code>-</code>Neon<code>-</code>Neutron<code>-</code>Oasis<code>-</code>Optimism<code>0x2703483B1a5a7c577e8680de9Df8Be03c6f30e3c</code>Osmosis<code>-</code>Polygon<code>0x0FF28217dCc90372345954563486528aa865cDd6</code>Provenance<code>-</code>Pythnet<code>-</code>Rootstock<code>-</code>Scroll<code>-</code>Seda<code>-</code>Sei<code>-</code>Seievm<code>-</code>Stargaze<code>-</code>Sui<code>-</code>Terra<code>-</code>Terra2<code>-</code>Xlayer<code>-</code>Xpla<code>-</code></p> <p>Chain NameContract AddressEthereum<code>-</code>Ethereum Holesky<code>-</code>Ethereum Sepolia<code>0x2703483B1a5a7c577e8680de9Df8Be03c6f30e3c</code>Solana<code>-</code>Acala<code>-</code>Algorand<code>-</code>Aptos<code>-</code>Arbitrum<code>-</code>Arbitrum Sepolia<code>0x2703483B1a5a7c577e8680de9Df8Be03c6f30e3c</code>Avalanche<code>0x58f4c17449c90665891c42e14d34aae7a26a472e</code>Base<code>-</code>Base Sepolia<code>0x2703483B1a5a7c577e8680de9Df8Be03c6f30e3c</code>Berachain<code>-</code>Blast<code>-</code>BNB Smart Chain<code>-</code>Celestia<code>-</code>Celo<code>-</code>Cosmoshub<code>-</code>Dymension<code>-</code>Evmos<code>-</code>Fantom<code>-</code>Gnosis<code>-</code>Injective<code>-</code>Karura<code>-</code>Klaytn<code>-</code>Kujira<code>-</code>Linea<code>-</code>Mantle<code>-</code>Moonbeam<code>-</code>NEAR<code>-</code>Neon<code>-</code>Neutron<code>-</code>Oasis<code>-</code>Optimism<code>-</code>Optimism Sepolia<code>0x2703483B1a5a7c577e8680de9Df8Be03c6f30e3c</code>Osmosis<code>-</code>Polygon<code>0x2703483B1a5a7c577e8680de9Df8Be03c6f30e3c</code>Polygon Sepolia<code>-</code>Provenance<code>-</code>Pythnet<code>-</code>Rootstock<code>-</code>Scroll<code>-</code>Seda<code>-</code>Sei<code>-</code>Seievm<code>-</code>Stargaze<code>-</code>Sui<code>-</code>Terra<code>-</code>Terra2<code>-</code>Xlayer<code>-</code>Xpla<code>-</code></p> <p>Chain NameContract AddressEthereum<code>-</code>Ethereum Sepolia<code>-</code>Ethereum Holesky<code>-</code>Solana<code>-</code>Acala<code>-</code>Algorand<code>-</code>Aptos<code>-</code>Arbitrum<code>-</code>Arbitrum Sepolia<code>-</code>Avalanche<code>-</code>Base<code>-</code>Base Sepolia<code>-</code>Berachain<code>-</code>Blast<code>-</code>BNB Smart Chain<code>-</code>Celestia<code>-</code>Celo<code>-</code>Cosmoshub<code>-</code>Dymension<code>-</code>Evmos<code>-</code>Fantom<code>-</code>Gnosis<code>-</code>Injective<code>-</code>Karura<code>-</code>Klaytn<code>-</code>Kujira<code>-</code>Linea<code>-</code>Mantle<code>-</code>Moonbeam<code>-</code>NEAR<code>-</code>Neon<code>-</code>Neutron<code>-</code>Oasis<code>-</code>Optimism<code>-</code>Optimism Sepolia<code>-</code>Osmosis<code>-</code>Polygon<code>-</code>Polygon Sepolia<code>-</code>Provenance<code>-</code>Pythnet<code>-</code>Rootstock<code>-</code>Scroll<code>-</code>Seda<code>-</code>Sei<code>-</code>Seievm<code>-</code>Stargaze<code>-</code>Sui<code>-</code>Terra<code>-</code>Terra2<code>-</code>Xlayer<code>-</code>Xpla<code>-</code></p>"},{"location":"build/reference/contract-addresses/#gateway","title":"Gateway","text":"MainNetTestNet Contract Address Wormhole Core Bridge <code>wormhole1ufs3tlq4umljk0qfe8k5ya0x6hpavn897u2cnf9k0en9jr7qarqqaqfk2j</code> Wormhole Token Bridge <code>wormhole1466nf3zuxpya8q9emxukd7vftaf6h4psr0a07srl5zw74zh84yjq4lyjmh</code> IBC Translator <code>wormhole14ejqjyq8um4p3xfqj74yld5waqljf88fz25yxnma0cngspxe3les00fpjx</code> Contract Address Wormhole Core Bridge <code>wormhole16jzpxp0e8550c9aht6q9svcux30vtyyyyxv5w2l2djjra46580wsazcjwp</code> Wormhole Token Bridge <code>wormhole1aaf9r6s7nxhysuegqrxv0wpm27ypyv4886medd3mrkrw6t4yfcnst3qpex</code> IBC Translator <code>wormhole1ctnjk7an90lz5wjfvr3cf6x984a8cjnv8dpmztmlpcq4xteaa2xs9pwmzk</code>"},{"location":"build/reference/contract-addresses/#fast-transfers","title":"Fast Transfers","text":"<p>This section provides the MainNet contract addresses for various components of the Fast Transfers protocol, including the Matching Engine, Token Router, and Upgrade Manager. Each contract is listed with its associated chain name and address, for the associated <code>chainId</code> refer to the Chain IDs page.</p> MatchingEngineProxyUpgradeManager Chain Name Address Solana HtkeCDdYY4i9ncAxXKjYTx8Uu3WM8JbtiLRYjtHwaVXb Chain Name Address Solana 4jyJ7EEsYa72REdD8ZMBvHFTXZ4VYGQPUHaJTajsK8SN"},{"location":"build/reference/contract-addresses/#token-router","title":"Token Router","text":"TokenRouterProxyTokenRouterImplementation Chain Name Address Constructor Arguments Solana 28topqjtJzMnPaGFmmZk68tzGmj9W9aMntaEK3QkgtRe Base 0x70287c79ee41C5D1df8259Cd68Ba0890cd389c47 0xE33C682aA6F7F6E31F0E861aAcCd7dB9C002B965, 0x439fab9100000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000014420e8aa32c31626f7f31d6fcc154eeccd6e6e9cb000000000000000000000000 Arbitrum 0x70287c79ee41C5D1df8259Cd68Ba0890cd389c47 0xE33C682aA6F7F6E31F0E861aAcCd7dB9C002B965, 0x439fab9100000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000014420e8aa32c31626f7f31d6fcc154eeccd6e6e9cb000000000000000000000000 Chain Name Address Constructor Arguments Base 0xB2BCa2A79f7C99aA684A14303d368ffDbc4307e9 0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913,0xbebdb6C8ddC678FfA9f8748f85C815C556Dd8ac6, 0x1682Ae6375C4E4A97e4B583BC394c861A46D8962, 1, 0x74e70ed52464f997369bbefd141d8a2d9dd3cd15e1f21b37bce18f45e0e923b2, 0xf4c8473a0e8fb093ca12970ed615db09f7ebbbb3d00f40b3e285e12f40e5c9a6, 5 Arbitrum 0xB2BCa2A79f7C99aA684A14303d368ffDbc4307e9 0xaf88d065e77c8cC2239327C5EDb3A432268e5831, 0xa5f208e072434bC67592E4C49C1B991BA79BCA46, 0x19330d10D9Cc8751218eaf51E8885D058642E08A, 1, 0x74e70ed52464f997369bbefd141d8a2d9dd3cd15e1f21b37bce18f45e0e923b2, 0xf4c8473a0e8fb093ca12970ed615db09f7ebbbb3d00f40b3e285e12f40e5c9a6, 5"},{"location":"build/start-building/","title":"Start Building","text":""},{"location":"build/start-building/#introduction","title":"Introduction","text":"<p>Wormhole's role as a Generic Message Passing (GMP) protocol means it facilitates interoperability across multiple areas of project development. The following sections will help you locate the tools most relevant to your development needs whether you are focused on building frontend user interfaces or smart contracts and protocols. This section also links to developer resources like references and code examples which are helpful for all builders looking to integrate with Wormhole. </p>"},{"location":"build/start-building/#choose-your-development-pathway","title":"Choose Your Development Pathway","text":"<ul> <li> <p> Build Frontend Applications</p> <p>Build user-friendly frontends that interact with Wormhole's existing integrations, enabling your users to transfer assets, query information, and monitor cross-chain activity.</p> <p> Build frontend applications</p> </li> <li> <p> Build Contract Integrations</p> <p>Leverage Wormhole's powerful messaging protocols to create contracts that can communicate and interact across multiple blockchains. By using Wormhole\u2019s core infrastructure, you can enable secure and seamless messaging, asset transfers, and more between supported networks.</p> <p> Integrate with contracts</p> </li> </ul>"},{"location":"build/start-building/#get-hands-on","title":"Get Hands-On","text":"<ul> <li> <p> Tutorials</p> <p>Follow in-depth, step-by-step tutorials to learn how to build cross-chain contracts, integrate Wormhole's SDK, and more.</p> <p> Explore tutorials</p> </li> <li> <p> Demos</p> <p>Explore pre-built reference applications that demonstrate real-world use cases of Wormhole\u2019s messaging protocols and token bridges.</p> <p> Get inspired with demos</p> </li> </ul>"},{"location":"build/start-building/#essential-resources-for-development","title":"Essential Resources for Development","text":"<ul> <li> <p> Supported Networks</p> <p>Explore the blockchains supported by Wormhole for cross-chain communication and asset transfers. Understand which networks are available for both TestNet and MainNet environments.</p> <p> Discover supported networks</p> </li> <li> <p> Reference</p> <p>Access the essential Wormhole chain IDs and smart contract addresses for messaging protocols, token bridges, and other key components.</p> <p> Explore Reference</p> </li> <li> <p> TestNet Faucets</p> <p>Get TestNet tokens to start experimenting with cross-chain transfers and contract deployment.</p> <p> Find TestNet faucets</p> </li> </ul>"},{"location":"build/start-building/demos/","title":"Demos","text":"<p>This page features various demos showcasing Wormhole's features, including starter apps, cross-chain examples, and UI components for token transfers and lending protocols.</p>"},{"location":"build/start-building/demos/#scaffolding","title":"Scaffolding","text":"<p>Scaffolding is a starter application repository that contains example dApps that integrate with Wormhole messaging. It includes basic xDapp structures, tests, and walkthroughs for core components like Wormhole messaging and the portal token bridge.</p>"},{"location":"build/start-building/demos/#wormhole-examples","title":"Wormhole Examples","text":"<p>Wormhole Examples contains a variety of example components. It features a mix of relayers, cross-chain applications, NFT projects, and more.</p>"},{"location":"build/start-building/demos/#basic-examples","title":"Basic Examples","text":"<p>Basic Examples features straightforward example projects that showcase minimum-code examples for how to send messages, tokens, and other standard functions.</p>"},{"location":"build/start-building/demos/#native-usdc-bridging","title":"Native USDC Bridging","text":"<p>The Native USDC Bridging repo demonstrates an integration of Circle's Cross-Chain Transfer Protocol using Wormhole.  </p>"},{"location":"build/start-building/demos/#reference-bridge-ui","title":"Reference Bridge UI","text":"<p>Reference Bridge UI is an example GUI that can be used to perform token transfers around the ecosystem.</p>"},{"location":"build/start-building/demos/#borrow-lend","title":"Borrow Lend","text":"<p>Borrow Lend contains two examples of cross-chain lending protocol implementations. The first example provides a basic lending skeleton for borrowing and lending between two chains. In contrast, the second example offers a more advanced cross-chain lending model using a hub-and-spoke approach.</p>"},{"location":"build/start-building/demos/#wormhole-ntt-connect-demo","title":"Wormhole NTT Connect Demo","text":"<p>The Wormhole NTT Connect demo configures a Vite-React TypeScript application using the Wormhole TypeScript SDK and, as an example, preconfigures the Wormhole Connect widget to allow transfers between Sepolia and Solana TestNet environments.</p>"},{"location":"build/start-building/demos/#wormhole-demo-ntt-ts-sdk","title":"Wormhole Demo NTT TS SDK","text":"<p>The Demo NTT TS SDK Example demonstrates the use of the Wormhole TS SDK to facilitate token transfers between different blockchain networks after performing a deployment of the Native Token Transfers framework.</p>"},{"location":"build/start-building/testnet-faucets/","title":"TestNet Faucets","text":""},{"location":"build/start-building/testnet-faucets/#get-started","title":"Get Started","text":"<p>Don't let the need for TestNet tokens get in the way of buildling your next great idea with Wormhole. Use this guide to quickly locate the TestNet token faucets you need to deploy and test applications and contracts on Wormhole's supported networks.</p>"},{"location":"build/start-building/testnet-faucets/#evm","title":"EVM","text":"<p>Ethereum Sepolia</p> <p> </p> <p>Ethereum Holesky</p> <p> </p> <p>Acala</p> <p> </p> <p>Arbitrum Sepolia</p> <p> </p> <p>Avalanche</p> <p> </p> <p>Base Sepolia</p> <p> </p> <p>Berachain</p> <p> </p> <p>Blast</p> <p> </p> <p>BNB Smart Chain</p> <p> </p> <p>Celo</p> <p> </p> <p>Fantom</p> <p> </p> <p>Gnosis</p> <p> </p> <p>Karura</p> <p> </p> <p>Klaytn</p> <p> </p> <p>Linea</p> <p> </p> <p>Mantle</p> <p> </p> <p>Moonbeam</p> <p> </p> <p>Neon</p> <p> </p> <p>Oasis</p> <p> </p> <p>Optimism Sepolia</p> <p> </p> <p>Polygon</p> <p> </p> <p>Rootstock</p> <p> </p> <p>Scroll</p> <p> </p> <p>Sei</p> <p> </p> <p>X Layer</p> <p> </p>"},{"location":"build/start-building/testnet-faucets/#algorand","title":"Algorand","text":"<p>Algorand</p> <p> </p>"},{"location":"build/start-building/testnet-faucets/#aptos","title":"Aptos","text":"<p>Aptos</p> <p> </p>"},{"location":"build/start-building/testnet-faucets/#cosmos","title":"Cosmos","text":"<p>Celestia</p> <p> </p> <p>Cosmos Hub</p> <p> </p> <p>Evmos</p> <p> </p> <p>Injective</p> <p> </p> <p>Kujira</p> <p> </p> <p>Neutron</p> <p> </p> <p>Osmosis</p> <p> </p> <p>Provenance</p> <p> </p> <p>Sei</p> <p> </p> <p>Stargaze</p> <p> </p> <p>Terra</p> <p> </p> <p>XPLA</p> <p> </p>"},{"location":"build/start-building/testnet-faucets/#near","title":"NEAR","text":"<p>NEAR</p> <p> </p>"},{"location":"build/start-building/testnet-faucets/#solana","title":"Solana","text":"<p>Solana</p> <p> </p>"},{"location":"build/start-building/testnet-faucets/#sui","title":"Sui","text":"<p>Sui</p> <p> </p>"},{"location":"build/start-building/supported-networks/","title":"Supported Networks","text":"<p>Wormhole supports several different blockchains and environments. Since many of the concepts for using Wormhole within a given blockchain environment are the same, this section is organized by environment, and individual chains are detailed within the environment page.</p>"},{"location":"build/start-building/supported-networks/#environments-supported","title":"Environments Supported","text":"<ul> <li>EVM</li> <li>Solana</li> <li>Cosmos</li> <li>Algorand</li> <li>NEAR</li> <li>Aptos</li> <li>Sui</li> </ul>"},{"location":"build/start-building/supported-networks/#blockchains-supported","title":"Blockchains Supported","text":"<p>Click on a blockchain's logo to see the relevant chain details.</p> <p>Acala </p> <p>Algorand </p> <p>Aptos </p> <p>Arbitrum </p> <p>Avalanche </p> <p>Base </p> <p>Berachain </p> <p>Blast </p> <p>BNB Smart Chain </p> <p>Celestia </p> <p>Celo </p> <p>Cosmoshub </p> <p>Dymension </p> <p>Ethereum </p> <p>Evmos </p> <p>Fantom </p> <p>Gnosis </p> <p>Injective </p> <p>Karura </p> <p>Klaytn </p> <p>Kujira </p> <p>Linea </p> <p>Mantle </p> <p>Moonbeam </p> <p>NEAR </p> <p>Neon </p> <p>Neutron </p> <p>Oasis </p> <p>Optimism </p> <p>Osmosis </p> <p>Polygon </p> <p>Provenance </p> <p>Pythnet </p> <p>Rootstock </p> <p>Scroll </p> <p>Seda </p> <p>Sei </p> <p>Seievm </p> <p>Solana </p> <p>Stargaze </p> <p>Sui </p> <p>Terra </p> <p>Terra2 </p> <p>Xlayer </p> <p>Xpla </p>"},{"location":"build/start-building/supported-networks/algorand/","title":"Algorand","text":"<p>This page includes details for working with Algorand environment chains.</p>"},{"location":"build/start-building/supported-networks/algorand/#developer-tools","title":"Developer Tools","text":"<p>The recommended development tool for Algorand is Algokit.</p>"},{"location":"build/start-building/supported-networks/algorand/#addresses","title":"Addresses","text":"<p>Because Wormhole works with many environments, the Wormhole address format is normalized. For Algorand chains, a Wormhole formatted address is the 58-character address decoded from base32 with its checksum removed. E.g. <code>M7UT7JWIVROIDGMQVJZUBQGBNNIIVOYRPC7JWMGQES4KYJIZHVCRZEGFRQ</code> becomes <code>0x67e93fa6c8ac5c819990aa7340c0c16b508abb1178be9b30d024b8ac25193d45</code>.</p> <p>Algorand also uses a uint64 for asset and application IDs. These are converted to 32 bytes by first converting to an 8-byte big-endian byte array, then padding with 24 bytes of zeroes. For example, <code>123</code> becomes <code>0x000000000000000000000000000000000000000000000000000000000000007b</code>.</p>"},{"location":"build/start-building/supported-networks/algorand/#emitter","title":"Emitter","text":"<p>The emitter is the application address, normalized to the Wormhole address format. </p>"},{"location":"build/start-building/supported-networks/algorand/#algorand_1","title":"Algorand","text":""},{"location":"build/start-building/supported-networks/algorand/#ecosystem","title":"Ecosystem","text":"<ul> <li>Website</li> <li>Allo Explorer | Pera Explorer</li> <li>Developer Docs | Faucet</li> </ul>"},{"location":"build/start-building/supported-networks/algorand/#wormhole-details","title":"Wormhole Details","text":"<ul> <li>Name: <code>algorand</code></li> <li>Chain ID: <code>8</code></li> <li>Contract Source: algorand/wormhole_core.py</li> </ul>"},{"location":"build/start-building/supported-networks/algorand/#consistency-levels","title":"Consistency Levels","text":"<p>The options for <code>consistencyLevel</code> (i.e., finality) are:</p> Level Value Finalized 0 <p>This field may be ignored since the chain provides instant finality.</p> <p>For more information see https://developer.algorand.org/docs/get-started/basics/why_algorand/#finality.</p>"},{"location":"build/start-building/supported-networks/algorand/#mainnet-contracts-mainnet-v10","title":"MainNet Contracts <code>mainnet-v1.0</code>","text":"Type Contract Core <code>842125965</code> Token Bridge <code>842126029</code> NFT Bridge N/A"},{"location":"build/start-building/supported-networks/algorand/#testnet-contracts-testnet-v10","title":"TestNet Contracts <code>testnet-v1.0</code>","text":"Type Contract Core <code>86525623</code> Token Bridge <code>86525641</code> NFT Bridge N/A"},{"location":"build/start-building/supported-networks/algorand/#local-network-contract","title":"Local Network Contract","text":"Type Contract Core <code>1004</code> Token Bridge <code>1006</code> NFT Bridge N/A"},{"location":"build/start-building/supported-networks/aptos/","title":"Aptos","text":"<p>This page includes details on working with Aptos-based chains.</p>"},{"location":"build/start-building/supported-networks/aptos/#addresses","title":"Addresses","text":"<p>Because Wormhole works with many environments, the Wormhole address format is normalized. For Aptos-based chains, no normalization is needed for standard addresses since they already have 32 bytes. E.g. <code>0x84a5f374d29fc77e370014dce4fd6a55b58ad608de8074b0be5571701724da31</code> becomes <code>0x84a5f374d29fc77e370014dce4fd6a55b58ad608de8074b0be5571701724da31</code>.</p> <p>However, emitter addresses are recorded as a uint64 (8 bytes), so they're left padded with <code>0</code>s to 32 bytes. E.g. <code>0x0000000000000001</code> becomes <code>0000000000000000000000000000000000000000000000000000000000000001</code>.</p>"},{"location":"build/start-building/supported-networks/aptos/#emitter","title":"Emitter","text":"<p>On Aptos, an emitter capability is taken from the core bridge. The core bridge generates capabilities in a sequence and the capability object ID is its index in the sequence. The capability object ID (uint64) is used as the emitter address after normalizing to the Wormhole address format.</p>"},{"location":"build/start-building/supported-networks/aptos/#aptos_1","title":"Aptos","text":""},{"location":"build/start-building/supported-networks/aptos/#ecosystem","title":"Ecosystem","text":"<ul> <li>Website</li> <li>Aptos Explorer | AptoScan</li> <li>Developer Docs | Faucet</li> </ul>"},{"location":"build/start-building/supported-networks/aptos/#wormhole-details","title":"Wormhole Details","text":"<ul> <li>Name: <code>aptos</code></li> <li>Chain ID: <code>22</code></li> <li>Contract Source: aptos/wormhole/sources/wormhole.move</li> </ul>"},{"location":"build/start-building/supported-networks/aptos/#consistency-levels","title":"Consistency Levels","text":"<p>The options for <code>consistencyLevel</code> (i.e., finality) are:</p> Level Value Finalized 0 <p>This field may be ignored since the chain provides instant finality. For more information, see the Aptos Docs.</p>"},{"location":"build/start-building/supported-networks/aptos/#mainnet-contracts-1","title":"MainNet Contracts <code>1</code>","text":"Type Contract Core 0x5bc11445584a763c1fa7ed39081f1b920954da14e04b32440cba863d03e19625 Token Bridge 0x576410486a2da45eee6c949c995670112ddf2fbeedab20350d506328eefc9d4f NFT Bridge 0x1bdffae984043833ed7fe223f7af7a3f8902d04129b14f801823e64827da7130"},{"location":"build/start-building/supported-networks/aptos/#testnet-contracts-2","title":"TestNet Contracts <code>2</code>","text":"Type Contract Core 0x5bc11445584a763c1fa7ed39081f1b920954da14e04b32440cba863d03e19625 Token Bridge 0x576410486a2da45eee6c949c995670112ddf2fbeedab20350d506328eefc9d4f NFT Bridge 0x1bdffae984043833ed7fe223f7af7a3f8902d04129b14f801823e64827da7130"},{"location":"build/start-building/supported-networks/aptos/#local-network-contract","title":"Local Network Contract","text":"Type Contract Core <code>0xde0036a9600559e295d5f6802ef6f3f802f510366e0c23912b0655d972166017</code> Token Bridge <code>0x84a5f374d29fc77e370014dce4fd6a55b58ad608de8074b0be5571701724da31</code> NFT Bridge <code>0x46da3d4c569388af61f951bdd1153f4c875f90c2991f6b2d0a38e2161a40852c</code>"},{"location":"build/start-building/supported-networks/evm/","title":"EVM Network Details","text":"<p>This page includes details for working with EVM environment chains.</p>"},{"location":"build/start-building/supported-networks/evm/#developer-tools","title":"Developer tools","text":"<p>The recommended development tool for EVM environments is Foundry.</p>"},{"location":"build/start-building/supported-networks/evm/#addresses","title":"Addresses","text":"<p>Because Wormhole works with many environments, the Wormhole address format is normalized. For EVM chains, a Wormhole formatted address is the 20-byte EVM standard address left padded with zeroes. e.g. <code>0xd8da6bf26964af9d7eed9e03e53415d37aa96045</code> becomes <code>0x000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa96045</code>.</p>"},{"location":"build/start-building/supported-networks/evm/#emitter","title":"Emitter","text":"<p>The emitter address on EVM chains is the contract address, normalized to the wormhole address format.</p>"},{"location":"build/start-building/supported-networks/evm/#ethereum","title":"Ethereum","text":"<p>Deployed contracts are also available on the Sepolia TestNet.</p>"},{"location":"build/start-building/supported-networks/evm/#ecosystem","title":"Ecosystem","text":"<ul> <li>Website</li> <li>Block Explorers: https://etherscan.io/</li> <li>https://ethereum.org/en/developers/docs/</li> </ul>"},{"location":"build/start-building/supported-networks/evm/#wormhole-details","title":"Wormhole Details","text":"<ul> <li>Name: <code>ethereum</code></li> <li>Chain ID: <code>2</code></li> <li>Contract Source: ethereum/contracts/bridge/Bridge.sol</li> </ul>"},{"location":"build/start-building/supported-networks/evm/#consistency-levels","title":"Consistency Levels","text":"<p>The options for <code>consistencyLevel</code> (i.e., finality) are:</p> Level Value Instant 200 Safe 201 <p>If a value is passed that isn't in the preceding set, it's assumed to mean finalized. For more information,, see https://www.alchemy.com/overviews/ethereum-commitment-levels.</p> MainNet Type Contract Core <code>0x98f3c9e6E3fAce36bAAd05FE09d375Ef1464288B</code> Token Bridge <code>0x3ee18B2214AFF97000D974cf647E7C347E8fa585</code> NFT Bridge <code>0x6FFd7EdE62328b3Af38FCD61461Bbfc52F5651fE</code> Relayer <code>0x27428DD2d3DD32A4D7f7C497eAaa23130d894911</code> CCTP <code>0xAaDA05BD399372f0b0463744C09113c137636f6a</code> TestNet <code>Holesky - 17000</code> Type Contract Core <code>0x706abc4E45D419950511e474C7B9Ed348A4a716c</code> Token Bridge <code>0xF890982f9310df57d00f659cf4fd87e65adEd8d7</code> NFT Bridge <code>0xD8E4C2DbDd2e2bd8F1336EA691dBFF6952B1a6eB</code> Relayer <code>0x28D8F1Be96f97C1387e94A53e00eCcFb4E75175a</code> MockProvider <code>0xD1463B4fe86166768d2ff51B1A928beBB5c9f375</code> MockIntegration <code>0xb81bc199b73AB34c393a4192C163252116a03370</code> Local Network Type Contract Core <code>0xC89Ce4735882C9F0f0FE26686c53074E09B0D550</code> Token Bridge <code>0x0290FB167208Af455bB137780163b7B7a9a10C16</code> NFT Bridge <code>0x26b4afb60d6c903165150c6f0aa14f8016be4aec</code> Relayer <code>0xb98F46E96cb1F519C333FdFB5CCe0B13E0300ED4</code> MockProvider <code>0x1ef9e15c3bbf0555860b5009B51722027134d53a</code> MockIntegration <code>0x0eb0dD3aa41bD15C706BC09bC03C002b7B85aeAC</code>"},{"location":"build/start-building/supported-networks/evm/#other-evm-chains","title":"Other EVM Chains","text":"<p>Besides Ethereum, several other EVM chains are supported.</p>"},{"location":"build/start-building/supported-networks/evm/#acala","title":"Acala","text":""},{"location":"build/start-building/supported-networks/evm/#ecosystem_1","title":"Ecosystem","text":"<ul> <li>Website</li> <li>Block Explorers: https://acala.subscan.io/ | https://blockscout.acala.network/</li> <li>Developer docs | Faucet</li> </ul>"},{"location":"build/start-building/supported-networks/evm/#wormhole-details_1","title":"Wormhole Details","text":"<ul> <li>Name: <code>acala</code></li> <li>Chain ID: <code>12</code></li> <li>Contract Source: ethereum/contracts/bridge/Bridge.sol</li> </ul>"},{"location":"build/start-building/supported-networks/evm/#consistency-levels_1","title":"Consistency Levels","text":"<p>The options for <code>consistencyLevel</code> (i.e., finality) are:</p> Level Value Instant 200 <p>If a value is passed that isn't in the preceding set, it's assumed to mean finalized.</p> MainNet <code>787</code> Type Contract Core <code>0xa321448d90d4e5b0A732867c18eA198e75CAC48E</code> Token Bridge <code>0xae9d7fe007b3327AA64A32824Aaac52C42a6E624</code> NFT Bridge <code>0xb91e3638F82A1fACb28690b37e3aAE45d2c33808</code> Relayer <code>0x27428DD2d3DD32A4D7f7C497eAaa23130d894911</code> TestNet <code>597</code> Type Contract Core <code>0x4377B49d559c0a9466477195C6AdC3D433e265c0</code> Token Bridge <code>0xebA00cbe08992EdD08ed7793E07ad6063c807004</code> NFT Bridge <code>0x96f1335e0AcAB3cfd9899B30b2374e25a2148a6E</code> Local Network Contract Type Contract Core N/A Token Bridge N/A NFT Bridge N/A"},{"location":"build/start-building/supported-networks/evm/#arbitrum","title":"Arbitrum","text":""},{"location":"build/start-building/supported-networks/evm/#ecosystem_2","title":"Ecosystem","text":"<ul> <li>Website</li> <li>Arbitrum Explorer</li> <li>Developer Docs</li> </ul>"},{"location":"build/start-building/supported-networks/evm/#wormhole-details_2","title":"Wormhole Details","text":"<ul> <li>Name: <code>arbitrum</code></li> <li>Chain ID: <code>23</code></li> <li>Contract Source: No source file</li> </ul>"},{"location":"build/start-building/supported-networks/evm/#consistency-levels_2","title":"Consistency Levels","text":"<p>The options for <code>consistencyLevel</code> (i.e., finality) are:</p> Level Value Instant 200 <p>If a value is passed that isn't in the preceding set, it's assumed to mean finalized.</p> <p>For more information,, see https://developer.arbitrum.io/tx-lifecycle.</p> MainNet <code>Arbitrum One - 42161</code> Type Contract Core <code>0xa5f208e072434bC67592E4C49C1B991BA79BCA46</code> Token Bridge <code>0x0b2402144Bb366A632D14B83F244D2e0e21bD39c</code> NFT Bridge <code>0x3dD14D553cFD986EAC8e3bddF629d82073e188c8</code> Relayer <code>0x27428DD2d3DD32A4D7f7C497eAaa23130d894911</code> CCTP <code>0x2703483B1a5a7c577e8680de9Df8Be03c6f30e3c</code> TestNet <code>Sepolia - 421614</code> Type Contract Core <code>0xC7A204bDBFe983FCD8d8E61D02b475D4073fF97e</code> Token Bridge <code>0x23908A62110e21C04F3A4e011d24F901F911744A</code> NFT Bridge <code>0xEe3dB83916Ccdc3593b734F7F2d16D630F39F1D0</code> Relayer <code>0xAd753479354283eEE1b86c9470c84D42f229FF43</code> MockProvider <code>0x90995DBd1aae85872451b50A569dE947D34ac4ee</code> MockIntegration <code>0x0de48f34E14d08934DA1eA2286Be1b2BED5c062a</code> Local Network Type Contract Core N/A Token Bridge N/A NFT Bridge N/A"},{"location":"build/start-building/supported-networks/evm/#aurora","title":"Aurora","text":""},{"location":"build/start-building/supported-networks/evm/#ecosystem_3","title":"Ecosystem","text":"<ul> <li>Website</li> <li>Block Explorer</li> <li>Developer docs | Faucet</li> </ul>"},{"location":"build/start-building/supported-networks/evm/#wormhole-details_3","title":"Wormhole Details","text":"<ul> <li>Name: <code>aurora</code></li> <li>Chain ID: <code>9</code></li> <li>Contract Source: ethereum/contracts/bridge/Bridge.sol</li> </ul> MainNet <code>1313161554</code> Type Contract Core <code>0xa321448d90d4e5b0A732867c18eA198e75CAC48E</code> Token Bridge <code>0x51b5123a7b0F9b2bA265f9c4C8de7D78D52f510F</code> NFT Bridge <code>0x6dcC0484472523ed9Cdc017F711Bcbf909789284</code> TestNet <code>1313161555</code> Type Contract Core <code>0xBd07292de7b505a4E803CEe286184f7Acf908F5e</code> Token Bridge <code>0xD05eD3ad637b890D68a854d607eEAF11aF456fba</code> NFT Bridge <code>0x8F399607E9BA2405D87F5f3e1B78D950b44b2e24</code> Local Network Type Contract Core N/A Token Bridge N/A NFT Bridge N/A"},{"location":"build/start-building/supported-networks/evm/#avalanche","title":"Avalanche","text":""},{"location":"build/start-building/supported-networks/evm/#ecosystem_4","title":"Ecosystem","text":"<ul> <li>Website</li> <li>C-Chain Block Explorer | https://subnets.avax.network/</li> <li>Developer docs | Faucet</li> </ul>"},{"location":"build/start-building/supported-networks/evm/#wormhole-details_4","title":"Wormhole Details","text":"<ul> <li>Name: <code>avalanche</code></li> <li>Chain ID: <code>6</code></li> <li>Contract Source: ethereum/contracts/bridge/Bridge.sol</li> </ul>"},{"location":"build/start-building/supported-networks/evm/#consistency-levels_3","title":"Consistency Levels","text":"<p>The options for <code>consistencyLevel</code> (i.e., finality) are:</p> Level Value Finalized 0 <p>This field may be ignored since the chain provides instant finality.</p> <p>For more information, see https://docs.avax.network/build/dapp/advanced/integrate-exchange#determining-finality.</p> MainNet <code>C-Chain - 43114</code> Type Contract Core <code>0x54a8e5f9c4CbA08F9943965859F6c34eAF03E26c</code> Token Bridge <code>0x0e082F06FF657D94310cB8cE8B0D9a04541d8052</code> NFT Bridge <code>0xf7B6737Ca9c4e08aE573F75A97B73D7a813f5De5</code> Relayer <code>0x27428DD2d3DD32A4D7f7C497eAaa23130d894911</code> CCTP <code>0x09Fb06A271faFf70A651047395AaEb6265265F13</code> TestNet <code>Fuji - 43113</code> Type Contract Core <code>0x7bbcE28e64B3F8b84d876Ab298393c38ad7aac4C</code> Token Bridge <code>0x61E44E506Ca5659E6c0bba9b678586fA2d729756</code> NFT Bridge <code>0xD601BAf2EEE3C028344471684F6b27E789D9075D</code> Relayer <code>0xA3cF45939bD6260bcFe3D66bc73d60f19e49a8BB</code> Mock Provider <code>0x60a86b97a7596eBFd25fb769053894ed0D9A8366</code> Mock Integration <code>0x5E52f3eB0774E5e5f37760BD3Fca64951D8F74Ae</code> CCTP <code>0x58f4c17449c90665891c42e14d34aae7a26a472e</code> Local Network Type Contract Core N/A Token Bridge N/A NFT Bridge N/A"},{"location":"build/start-building/supported-networks/evm/#base","title":"Base","text":""},{"location":"build/start-building/supported-networks/evm/#ecosystem_5","title":"Ecosystem","text":"<ul> <li>Website</li> <li>Block Explorer </li> <li>Developer docs</li> </ul>"},{"location":"build/start-building/supported-networks/evm/#wormhole-details_5","title":"Wormhole Details","text":"<ul> <li>Name: <code>base</code></li> <li>Chain ID: <code>30</code></li> <li>Contract Source: ethereum/contracts/bridge/Bridge.sol</li> </ul> MainNet <code>8453</code> Type Contract Core <code>0xbebdb6C8ddC678FfA9f8748f85C815C556Dd8ac6</code> Token Bridge <code>0x8d2de8d2f73F1F4cAB472AC9A881C9b123C79627</code> NFT Bridge <code>0xDA3adC6621B2677BEf9aD26598e6939CF0D92f88</code> Relayer <code>0x706f82e9bb5b0813501714ab5974216704980e31</code> CCTP <code>0x03faBB06Fa052557143dC28eFCFc63FC12843f1D</code> TestNet <code>Base Goerli - 84531</code> Type Contract Core <code>0x23908A62110e21C04F3A4e011d24F901F911744A</code> Token Bridge <code>0xA31aa3FDb7aF7Db93d18DDA4e19F811342EDF780</code> NFT Bridge <code>0xF681d1cc5F25a3694E348e7975d7564Aa581db59</code> Relayer <code>0xea8029CD7FCAEFFcD1F53686430Db0Fc8ed384E1</code> Mock Provider <code>0x60a86b97a7596eBFd25fb769053894ed0D9A8366</code> Mock Integration <code>0x9Ee656203B0DC40cc1bA3f4738527779220e3998</code> Local Network Type Contract Core N/A Token Bridge N/A NFT Bridge N/A"},{"location":"build/start-building/supported-networks/evm/#bsc","title":"BNB Smart Chain","text":""},{"location":"build/start-building/supported-networks/evm/#ecosystem_6","title":"Ecosystem","text":"<ul> <li>Website</li> <li>Etherscan</li> <li>Developer docs | Faucet</li> </ul>"},{"location":"build/start-building/supported-networks/evm/#wormhole-details_6","title":"Wormhole Details","text":"<ul> <li>Name: <code>bsc</code></li> <li>Chain ID: <code>4</code></li> <li>Contract Source: ethereum/contracts/bridge/Bridge.sol</li> </ul>"},{"location":"build/start-building/supported-networks/evm/#consistency-levels_4","title":"Consistency Levels","text":"<p>The options for <code>consistencyLevel</code> (i.e., finality) are:</p> Level Value Instant 200 Safe 201 <p>If a value is passed that isn't in the preceding set, it's assumed to mean finalized. For more information, see https://docs.bnbchain.org/docs/learn/consensus.</p> MainNet <code>56</code> Type Contract Core <code>0x98f3c9e6E3fAce36bAAd05FE09d375Ef1464288B</code> Token Bridge <code>0xB6F6D86a8f9879A9c87f643768d9efc38c1Da6E7</code> NFT Bridge <code>0x5a58505a96D1dbf8dF91cB21B54419FC36e93fdE</code> Relayer <code>0x27428DD2d3DD32A4D7f7C497eAaa23130d894911</code> TestNet <code>97</code> Type Contract Core <code>0x68605AD7b15c732a30b1BbC62BE8F2A509D74b4D</code> Token Bridge <code>0x9dcF9D205C9De35334D646BeE44b2D2859712A09</code> NFT Bridge <code>0xcD16E5613EF35599dc82B24Cb45B5A93D779f1EE</code> Relayer <code>0x80aC94316391752A193C1c47E27D382b507c93F3</code> Mock Provider <code>0x60a86b97a7596eBFd25fb769053894ed0D9A8366</code> Mock Integration <code>0xb6A04D6672F005787147472Be20d39741929Aa03</code> Local Network Type Contract Core <code>0xC89Ce4735882C9F0f0FE26686c53074E09B0D550</code> Token Bridge <code>0x0290FB167208Af455bB137780163b7B7a9a10C16</code> NFT Bridge <code>0x26b4afb60d6c903165150c6f0aa14f8016be4aec</code> Relayer <code>0xb98F46E96cb1F519C333FdFB5CCe0B13E0300ED4</code> Mock Provider <code>0x1ef9e15c3bbf0555860b5009B51722027134d53a</code> Mock Integration <code>0x0eb0dD3aa41bD15C706BC09bC03C002b7B85aeAC</code>"},{"location":"build/start-building/supported-networks/evm/#celo","title":"Celo","text":""},{"location":"build/start-building/supported-networks/evm/#ecosystem_7","title":"Ecosystem","text":"<ul> <li>Website</li> <li>https://explorer.celo.org/ | https://celoscan.io/</li> <li>Developer docs | Faucet</li> </ul>"},{"location":"build/start-building/supported-networks/evm/#wormhole-details_7","title":"Wormhole Details","text":"<ul> <li>Name: <code>celo</code></li> <li>Chain ID: <code>14</code></li> <li>Contract Source: ethereum/contracts/bridge/Bridge.sol</li> </ul>"},{"location":"build/start-building/supported-networks/evm/#consistency-levels_5","title":"Consistency Levels","text":"<p>The options for <code>consistencyLevel</code> (i.e., finality) are:</p> Level Value Instant 200 <p>If a value is passed that isn't in the preceding set, it's assumed to mean finalized.</p> MainNet <code>42220</code> Type Contract Core <code>0xa321448d90d4e5b0A732867c18eA198e75CAC48E</code> Token Bridge <code>0x796Dff6D74F3E27060B71255Fe517BFb23C93eed</code> NFT Bridge <code>0xA6A377d75ca5c9052c9a77ED1e865Cc25Bd97bf3</code> Relayer <code>0x27428DD2d3DD32A4D7f7C497eAaa23130d894911</code> TestNet  <code>Alfajores - 44787</code> Type Contract Core <code>0x88505117CA88e7dd2eC6EA1E13f0948db2D50D56</code> Token Bridge <code>0x05ca6037eC51F8b712eD2E6Fa72219FEaE74E153</code> NFT Bridge <code>0xaCD8190F647a31E56A656748bC30F69259f245Db</code> Relayer <code>0x306B68267Deb7c5DfCDa3619E22E9Ca39C374f84</code> Mock Provider <code>0x60a86b97a7596eBFd25fb769053894ed0D9A8366</code> Mock Integration <code>0x7f1d8E809aBB3F6Dc9B90F0131C3E8308046E190</code> Local Network Type Contract Core N/A Token Bridge N/A NFT Bridge N/A"},{"location":"build/start-building/supported-networks/evm/#fantom","title":"Fantom","text":""},{"location":"build/start-building/supported-networks/evm/#ecosystem_8","title":"Ecosystem","text":"<ul> <li>Website</li> <li>https://ftmscan.com/</li> <li>Developer docs | Faucet</li> </ul>"},{"location":"build/start-building/supported-networks/evm/#wormhole-details_8","title":"Wormhole Details","text":"<ul> <li>Name: <code>fantom</code></li> <li>Chain ID: <code>10</code></li> <li>Contract Source: ethereum/contracts/bridge/Bridge.sol</li> </ul>"},{"location":"build/start-building/supported-networks/evm/#consistency-levels_6","title":"Consistency Levels","text":"<p>The options for <code>consistencyLevel</code> (i.e., finality) are:</p> Level Value Instant 200 <p>If a value is passed that isn't in the preceding set, it's assumed to mean finalized.</p> MainNet <code>250</code> Type Contract Core <code>0x126783A6Cb203a3E35344528B26ca3a0489a1485</code> Token Bridge <code>0x7C9Fc5741288cDFdD83CeB07f3ea7e22618D79D2</code> NFT Bridge <code>0xA9c7119aBDa80d4a4E0C06C8F4d8cF5893234535</code> Relayer <code>0x27428DD2d3DD32A4D7f7C497eAaa23130d894911</code> TestNet <code>4002</code> Type Contract Core <code>0x1BB3B4119b7BA9dfad76B0545fb3F531383c3bB7</code> Token Bridge <code>0x599CEa2204B4FaECd584Ab1F2b6aCA137a0afbE8</code> NFT Bridge <code>0x63eD9318628D26BdCB15df58B53BB27231D1B227</code> Local Network Type Contract Core N/A Token Bridge N/A NFT Bridge N/A"},{"location":"build/start-building/supported-networks/evm/#gnosis","title":"Gnosis","text":""},{"location":"build/start-building/supported-networks/evm/#ecosystem_9","title":"Ecosystem","text":"<ul> <li>Website</li> <li>Block Explorer</li> <li>Developer docs | Faucet</li> </ul>"},{"location":"build/start-building/supported-networks/evm/#wormhole-details_9","title":"Wormhole Details","text":"<ul> <li>Name: <code>gnosis</code></li> <li>Chain ID: <code>25</code></li> <li>Contract Source: ethereum/contracts/bridge/Bridge.sol</li> </ul> MainNet <code>100</code> Type Contract Core <code>0xa321448d90d4e5b0A732867c18eA198e75CAC48E</code> Token Bridge N/A NFT Bridge N/A TestNet <code>Chaido - 10200</code> Type Contract Core <code>0xBB73cB66C26740F31d1FabDC6b7A46a038A300dd</code> Token Bridge N/A NFT Bridge N/A Local Network Type Contract Core N/A Token Bridge N/A NFT Bridge N/A"},{"location":"build/start-building/supported-networks/evm/#karura","title":"Karura","text":""},{"location":"build/start-building/supported-networks/evm/#ecosystem_10","title":"Ecosystem","text":"<ul> <li>Website</li> <li>Block Explorers: Subscan | BlockScout</li> <li>Developer Docs</li> </ul>"},{"location":"build/start-building/supported-networks/evm/#wormhole-details_10","title":"Wormhole Details","text":"<ul> <li>Name: <code>karura</code></li> <li>Chain ID: <code>11</code></li> <li>Contract Source: ethereum/contracts/bridge/Bridge.sol</li> </ul>"},{"location":"build/start-building/supported-networks/evm/#consistency-levels_7","title":"Consistency Levels","text":"<p>The options for <code>consistencyLevel</code> (i.e., finality) are:</p> Level Value Instant 200 <p>If a value is passed that isn't in the preceding set, it's assumed to mean finalized. For more information, see https://wiki.polkadot.network/docs/learn-consensus.</p> MainNet <code>686</code> Type Contract Core <code>0xa321448d90d4e5b0A732867c18eA198e75CAC48E</code> Token Bridge <code>0xae9d7fe007b3327AA64A32824Aaac52C42a6E624</code> NFT Bridge <code>0xb91e3638F82A1fACb28690b37e3aAE45d2c33808</code> Relayer <code>0x27428DD2d3DD32A4D7f7C497eAaa23130d894911</code> TestNet <code>596</code> Type Contract Core <code>0xE4eacc10990ba3308DdCC72d985f2a27D20c7d03</code> Token Bridge <code>0xd11De1f930eA1F7Dd0290Fe3a2e35b9C91AEFb37</code> NFT Bridge <code>0x0A693c2D594292B6Eb89Cb50EFe4B0b63Dd2760D</code> Local Network Type Contract Core N/A Token Bridge N/A NFT Bridge N/A"},{"location":"build/start-building/supported-networks/evm/#klaytn","title":"Klaytn","text":""},{"location":"build/start-building/supported-networks/evm/#ecosystem_11","title":"Ecosystem","text":"<ul> <li>Website</li> <li>Kaiascan | Klaytnscope</li> <li>Developer docs | Faucet</li> </ul>"},{"location":"build/start-building/supported-networks/evm/#wormhole-details_11","title":"Wormhole Details","text":"<ul> <li>Name: <code>klaytn</code></li> <li>Chain ID: <code>13</code></li> <li>Contract Source: ethereum/contracts/bridge/Bridge.sol</li> </ul>"},{"location":"build/start-building/supported-networks/evm/#consistency-levels_8","title":"Consistency Levels","text":"<p>The options for <code>consistencyLevel</code> (i.e., finality) are:</p> Level Value Instant 200 <p>If a value is passed that isn't in the preceding set, it's assumed to mean finalized.</p> MainNet <code>8217</code> Type Contract Core <code>0x0C21603c4f3a6387e241c0091A7EA39E43E90bb7</code> Token Bridge <code>0x5b08ac39EAED75c0439FC750d9FE7E1F9dD0193F</code> NFT Bridge <code>0x3c3c561757BAa0b78c5C025CdEAa4ee24C1dFfEf</code> Relayer <code>0x27428DD2d3DD32A4D7f7C497eAaa23130d894911</code> TestNet <code>Kairos - 1001</code> Type Contract Core <code>0x1830CC6eE66c84D2F177B94D544967c774E624cA</code> Token Bridge <code>0xC7A13BE098720840dEa132D860fDfa030884b09A</code> NFT Bridge <code>0x94c994fC51c13101062958b567e743f1a04432dE</code> Local Network Type Contract Core N/A Token Bridge N/A NFT Bridge N/A"},{"location":"build/start-building/supported-networks/evm/#moonbeam","title":"Moonbeam","text":""},{"location":"build/start-building/supported-networks/evm/#ecosystem_12","title":"Ecosystem","text":"<ul> <li>Website</li> <li>Moonbeam EVM Block Explorer</li> <li>Developer docs | Faucet</li> </ul>"},{"location":"build/start-building/supported-networks/evm/#wormhole-details_12","title":"Wormhole Details","text":"<ul> <li>Name: <code>moonbeam</code></li> <li>Chain ID: <code>16</code></li> <li>Contract Source: ethereum/contracts/bridge/Bridge.sol</li> </ul>"},{"location":"build/start-building/supported-networks/evm/#consistency-levels_9","title":"Consistency Levels","text":"<p>The options for <code>consistencyLevel</code> (i.e., finality) are:</p> Level Value Instant 200 <p>If a value is passed that isn't in the preceding set, it's assumed to mean finalized. For more information, see https://docs.moonbeam.network/builders/build/moonbeam-custom-api/#finality-rpc-endpoints.</p> MainNet <code>1284</code> Type Contract Core <code>0xC8e2b0cD52Cf01b0Ce87d389Daa3d414d4cE29f3</code> Token Bridge <code>0xb1731c586ca89a23809861c6103f0b96b3f57d92</code> NFT Bridge <code>0x453cfbe096c0f8d763e8c5f24b441097d577bde2</code> Relayer <code>0x27428DD2d3DD32A4D7f7C497eAaa23130d894911</code> TestNet <code>Moonbase-Alphanet - 1287</code> Type Contract Core <code>0xa5B7D85a8f27dd7907dc8FdC21FA5657D5E2F901</code> Token Bridge <code>0xbc976D4b9D57E57c3cA52e1Fd136C45FF7955A96</code> NFT Bridge <code>0x98A0F4B96972b32Fcb3BD03cAeB66A44a6aB9Edb</code> Relayer <code>0x0591C25ebd0580E0d4F27A82Fc2e24E7489CB5e0</code> MockProvider <code>0x60a86b97a7596eBFd25fb769053894ed0D9A8366</code> MockIntegration <code>0x3bF0c43d88541BBCF92bE508ec41e540FbF28C56</code> Local Network Type Contract Core N/A Token Bridge N/A NFT Bridge N/A"},{"location":"build/start-building/supported-networks/evm/#neon","title":"Neon","text":""},{"location":"build/start-building/supported-networks/evm/#ecosystem_13","title":"Ecosystem","text":"<ul> <li>Website</li> <li>Block Explorers: NeonScan | BlockScout</li> <li>Developer Docs | Faucet</li> </ul>"},{"location":"build/start-building/supported-networks/evm/#wormhole-details_13","title":"Wormhole Details","text":"<ul> <li>Name: <code>neon</code></li> <li>Chain ID: <code>17</code></li> <li>Contract Source: ethereum/contracts/bridge/Bridge.sol</li> </ul> MainNet <code>245022934</code> Type Contract Core N/A Token Bridge N/A NFT Bridge N/A TestNet <code>245022940</code> Type Contract Core N/A Token Bridge N/A NFT Bridge N/A Local Network Type Contract Core N/A Token Bridge N/A NFT Bridge N/A"},{"location":"build/start-building/supported-networks/evm/#oasis","title":"Oasis","text":""},{"location":"build/start-building/supported-networks/evm/#ecosystem_14","title":"Ecosystem","text":"<ul> <li>Website</li> <li>OasisScan</li> <li>Developer Docs | Faucet</li> </ul>"},{"location":"build/start-building/supported-networks/evm/#wormhole-details_14","title":"Wormhole Details","text":"<ul> <li>Name: <code>oasis</code></li> <li>Chain ID: <code>7</code></li> <li>Contract Source: ethereum/contracts/bridge/Bridge.sol</li> </ul> MainNet <code>42262</code> Type Contract Core <code>0xfE8cD454b4A1CA468B57D79c0cc77Ef5B6f64585</code> Token Bridge <code>0x5848C791e09901b40A9Ef749f2a6735b418d7564</code> NFT Bridge <code>0x04952D522Ff217f40B5Ef3cbF659EcA7b952a6c1</code> TestNet <code>42261</code> Type Contract Core <code>0xc1C338397ffA53a2Eb12A7038b4eeb34791F8aCb</code> Token Bridge <code>0x88d8004A9BdbfD9D28090A02010C19897a29605c</code> NFT Bridge <code>0xC5c25B41AB0b797571620F5204Afa116A44c0ebA</code> Local Network Type Contract Core N/A Token Bridge N/A NFT Bridge N/A"},{"location":"build/start-building/supported-networks/evm/#optimism","title":"Optimism","text":""},{"location":"build/start-building/supported-networks/evm/#ecosystem_15","title":"Ecosystem","text":"<ul> <li>Website</li> <li>Block Explorer</li> <li>Developer Docs</li> </ul>"},{"location":"build/start-building/supported-networks/evm/#wormhole-details_15","title":"Wormhole Details","text":"<ul> <li>Name: <code>optimism</code></li> <li>Chain ID: <code>24</code></li> <li>Contract Source: ethereum/contracts/bridge/Bridge.sol</li> </ul>"},{"location":"build/start-building/supported-networks/evm/#consistency-levels_10","title":"Consistency Levels","text":"<p>The options for <code>consistencyLevel</code> (i.e., finality) are:</p> Level Value Instant 200 <p>If a value is passed that isn't in the preceding set, it's assumed to mean finalized.</p> MainNet <code>10</code> Type Contract Core <code>0xEe91C335eab126dF5fDB3797EA9d6aD93aeC9722</code> Token Bridge <code>0x1D68124e65faFC907325e3EDbF8c4d84499DAa8b</code> NFT Bridge <code>0xfE8cD454b4A1CA468B57D79c0cc77Ef5B6f64585</code> Relayer <code>0x27428DD2d3DD32A4D7f7C497eAaa23130d894911</code> CCTP <code>0x2703483B1a5a7c577e8680de9Df8Be03c6f30e3c</code> TestNet <code>Optimism Goerli - 420</code> Type Contract Core <code>0x6b9C8671cdDC8dEab9c719bB87cBd3e782bA6a35</code> Token Bridge <code>0xC7A204bDBFe983FCD8d8E61D02b475D4073fF97e</code> NFT Bridge <code>0x23908A62110e21C04F3A4e011d24F901F911744A</code> Relayer <code>0x01A957A525a5b7A72808bA9D10c389674E459891</code> MockProvider <code>0xfCe1Df3EF22fe5Cb7e2f5988b7d58fF633a313a7</code> MockIntegration <code>0x421e0bb71dDeeC727Af79766423d33D8FD7dB963</code> Local Network Type Contract Core N/A Token Bridge N/A NFT Bridge N/A"},{"location":"build/start-building/supported-networks/evm/#polygon","title":"Polygon","text":""},{"location":"build/start-building/supported-networks/evm/#ecosystem_16","title":"Ecosystem","text":"<ul> <li>Website</li> <li>PolygonScan Block Explorer</li> <li>Developer Docs | Faucet</li> </ul>"},{"location":"build/start-building/supported-networks/evm/#wormhole-details_16","title":"Wormhole Details","text":"<ul> <li>Name: <code>polygon</code></li> <li>Chain ID: <code>5</code></li> <li>Contract Source: ethereum/contracts/bridge/Bridge.sol</li> </ul>"},{"location":"build/start-building/supported-networks/evm/#consistency-levels_11","title":"Consistency Levels","text":"<p>The options for <code>consistencyLevel</code> (i.e., finality) are:</p> Level Value Instant 200 <p>If a value is passed that isn't in the preceding set, it's assumed to mean finalized. For more information, see https://docs.polygon.technology/pos/architecture/heimdall/checkpoints/.</p> MainNet <code>137</code> Type Contract Core <code>0x7A4B5a56256163F07b2C80A7cA55aBE66c4ec4d7</code> Token Bridge <code>0x5a58505a96D1dbf8dF91cB21B54419FC36e93fdE</code> NFT Bridge <code>0x90BBd86a6Fe93D3bc3ed6335935447E75fAb7fCf</code> Relayer <code>0x27428DD2d3DD32A4D7f7C497eAaa23130d894911</code> CCTP <code>0x0FF28217dCc90372345954563486528aa865cDd6</code> TestNet <code>Mumbai - 80001</code> Type Contract Core <code>0x0CBE91CF822c73C2315FB05100C2F714765d5c20</code> Token Bridge <code>0x377D55a7928c046E18eEbb61977e714d2a76472a</code> NFT Bridge <code>0x51a02d0dcb5e52F5b92bdAA38FA013C91c7309A9</code> Relayer <code>0x0591C25ebd0580E0d4F27A82Fc2e24E7489CB5e0</code> MockProvider <code>0x60a86b97a7596eBFd25fb769053894ed0D9A8366</code> MockIntegration <code>0x3bF0c43d88541BBCF92bE508ec41e540FbF28C56</code> CCTP <code>0x2703483B1a5a7c577e8680de9Df8Be03c6f30e3c</code> Local Network Type Contract Core N/A Token Bridge N/A NFT Bridge N/A"},{"location":"build/start-building/supported-networks/evm/#rootstock","title":"Rootstock","text":""},{"location":"build/start-building/supported-networks/evm/#ecosystem_17","title":"Ecosystem","text":"<ul> <li>Website</li> <li>Block Explorer</li> <li>Developer Docs | Faucet</li> </ul>"},{"location":"build/start-building/supported-networks/evm/#wormhole-details_17","title":"Wormhole Details","text":"<ul> <li>Name: <code>rootstock</code></li> <li>Chain ID: <code>33</code></li> <li>Contract Source: No source file</li> </ul> MainNet <code>30</code> Type Contract Core <code>0xbebdb6C8ddC678FfA9f8748f85C815C556Dd8ac6</code> Token Bridge N/A NFT Bridge N/A TestNet <code>31</code> Type Contract Core <code>0xbebdb6C8ddC678FfA9f8748f85C815C556Dd8ac6</code> Token Bridge N/A NFT Bridge N/A Local Network Type Contract Core N/A Token Bridge N/A NFT Bridge N/A"},{"location":"build/start-building/supported-networks/evm/#ethereum-sepolia","title":"Ethereum Sepolia","text":"<p>Sepolia is a TestNet-only chain that can be used as an alternative to Goerli. Note that a different chain ID is used for Sepolia.</p>"},{"location":"build/start-building/supported-networks/evm/#wormhole-details_18","title":"Wormhole Details","text":"<ul> <li>Name: <code>sepolia</code></li> <li>Chain ID: <code>10002</code></li> <li>Contract Source: ethereum/contracts/bridge/Bridge.sol</li> </ul> MainNet (N/A) Type Contract Core N/A Token Bridge N/A NFT Bridge N/A TestNet <code>Sepolia - 11155111</code> Type Contract Core <code>0x4a8bc80Ed5a4067f1CCf107057b8270E0cC11A78</code> Token Bridge <code>0xDB5492265f6038831E89f495670FF909aDe94bd9</code> NFT Bridge <code>0x6a0B52ac198e4870e5F3797d5B403838a5bbFD99</code> Relayer <code>0x7B1bD7a6b4E61c2a123AC6BC2cbfC614437D0470</code> MockProvider <code>0x7A0a53847776f7e94Cc35742971aCb2217b0Db81</code> MockIntegration <code>0x68b7Cd0d27a6F04b2F65e11DD06182EFb255c9f0</code> CCTP <code>0x2703483B1a5a7c577e8680de9Df8Be03c6f30e3c</code> Local Network Type Contract Core N/A Token Bridge N/A NFT Bridge N/A"},{"location":"build/start-building/supported-networks/evm/#ethereum-holesky","title":"Ethereum Holesky","text":"<p>Holesky is a TestNet-only chain that can be used as an alternative to Goerli. Note that a different chain ID is used for Holesky.</p>"},{"location":"build/start-building/supported-networks/evm/#wormhole-details_19","title":"Wormhole Details","text":"<ul> <li>Name: <code>holesky</code></li> <li>Chain ID: <code>10006</code></li> <li>Contract Source: ethereum/contracts/bridge/Bridge.sol</li> </ul> MainNet (N/A) Type Contract Core N/A Token Bridge N/A NFT Bridge N/A TestNet <code>Holesky - 17000</code> Type Contract Core <code>0xa10f2eF61dE1f19f586ab8B6F2EbA89bACE63F7a</code> Token Bridge <code>0x76d093BbaE4529a342080546cAFEec4AcbA59EC6</code> NFT Bridge <code>0xc8941d483c45eF8FB72E4d1F9dDE089C95fF8171</code> Local Network Type Contract Core N/A Token Bridge N/A NFT Bridge N/A"},{"location":"build/start-building/supported-networks/evm/#arbitrum-sepolia","title":"Arbitrum Sepolia","text":""},{"location":"build/start-building/supported-networks/evm/#ecosystem_18","title":"Ecosystem","text":"<ul> <li>Website</li> <li>Arbitrum Explorer</li> <li>Developer Docs</li> </ul>"},{"location":"build/start-building/supported-networks/evm/#wormhole-details_20","title":"Wormhole Details","text":"<ul> <li>Name: <code>arbitrum_sepolia</code></li> <li>Chain ID: <code>10003</code></li> <li>Contract Source: No source file</li> </ul> MainNet Type Contract Core N/A Token Bridge N/A NFT Bridge N/A TestNet <code>Sepolia - 421614</code> Type Contract Core <code>0x6b9C8671cdDC8dEab9c719bB87cBd3e782bA6a35</code> Token Bridge <code>0xC7A204bDBFe983FCD8d8E61D02b475D4073fF97e</code> NFT Bridge <code>0x23908A62110e21C04F3A4e011d24F901F911744A</code> Relayer <code>0x7B1bD7a6b4E61c2a123AC6BC2cbfC614437D0470</code> MockProvider <code>0x7A0a53847776f7e94Cc35742971aCb2217b0Db81</code> MockIntegration <code>0x2B1502Ffe717817A0A101a687286bE294fe495f7</code> CCTP <code>0x2703483B1a5a7c577e8680de9Df8Be03c6f30e3c</code> Local Network Type Contract Core N/A Token Bridge N/A NFT Bridge N/A"},{"location":"build/start-building/supported-networks/evm/#optimism-sepolia","title":"Optimism Sepolia","text":""},{"location":"build/start-building/supported-networks/evm/#ecosystem_19","title":"Ecosystem","text":"<ul> <li>Website</li> <li>Block Explorer</li> <li>Developer Docs</li> </ul>"},{"location":"build/start-building/supported-networks/evm/#wormhole-details_21","title":"Wormhole Details","text":"<ul> <li>Name: <code>optimism_sepolia</code></li> <li>Chain ID: <code>10005</code></li> <li>Contract Source: ethereum/contracts/bridge/Bridge.sol</li> </ul>"},{"location":"build/start-building/supported-networks/evm/#consistency-levels_12","title":"Consistency Levels","text":"<p>The options for <code>consistencyLevel</code> (i.e., finality) are:</p> Level Value Instant 200 <p>If a value is passed that isn't in the preceding set, it's assumed to mean finalized.</p> MainNet Type Contract Core N/A Token Bridge N/A NFT Bridge N/A TestNet <code>Optimism Sepolia - 11155420</code> Type Contract Core <code>0x31377888146f3253211EFEf5c676D41ECe7D58Fe</code> Token Bridge <code>0x99737Ec4B815d816c49A385943baf0380e75c0Ac</code> NFT Bridge <code>0x27812285fbe85BA1DF242929B906B31EE3dd1b9f</code> Relayer <code>0x93BAD53DDfB6132b0aC8E37f6029163E63372cEE</code> MockProvider <code>0x7A0a53847776f7e94Cc35742971aCb2217b0Db81</code> MockIntegration <code>0xA404B69582bac287a7455FFf315938CCd92099c1</code> CCTP <code>0x2703483B1a5a7c577e8680de9Df8Be03c6f30e3c</code> Local Network Type Contract Core N/A Token Bridge N/A NFT Bridge N/A"},{"location":"build/start-building/supported-networks/evm/#base-sepolia","title":"Base Sepolia","text":""},{"location":"build/start-building/supported-networks/evm/#ecosystem_20","title":"Ecosystem","text":"<ul> <li>Website</li> <li>Etherscan</li> <li>Developer docs | Faucet</li> </ul>"},{"location":"build/start-building/supported-networks/evm/#wormhole-details_22","title":"Wormhole Details","text":"<ul> <li>Name: <code>base_sepolia</code></li> <li>Chain ID: <code>10004</code></li> <li>Contract Source: ethereum/contracts/bridge/Bridge.sol</li> </ul> MainNet Type Contract Core N/A Token Bridge N/A NFT Bridge N/A TestNet <code>Base Sepolia - 84532</code> Type Contract Core <code>0x79A1027a6A159502049F10906D333EC57E95F083</code> Token Bridge <code>0x86F55A04690fd7815A3D802bD587e83eA888B239</code> NFT Bridge <code>0x268557122Ffd64c85750d630b716471118F323c8</code> Relayer <code>0x93BAD53DDfB6132b0aC8E37f6029163E63372cEE</code> MockProvider <code>0x7A0a53847776f7e94Cc35742971aCb2217b0Db81</code> MockIntegration <code>0xA404B69582bac287a7455FFf315938CCd92099c1</code> CCTP <code>0x2703483B1a5a7c577e8680de9Df8Be03c6f30e3c</code> Local Network Type Contract Core N/A Token Bridge N/A NFT Bridge N/A"},{"location":"build/start-building/supported-networks/evm/#scroll","title":"Scroll","text":""},{"location":"build/start-building/supported-networks/evm/#ecosystem_21","title":"Ecosystem","text":"<ul> <li>Website</li> <li>ScrollScan Block Explorer</li> <li>Developer docs</li> </ul>"},{"location":"build/start-building/supported-networks/evm/#wormhole-details_23","title":"Wormhole Details","text":"<ul> <li>Name: <code>scroll</code></li> <li>Chain ID: <code>34</code></li> <li>Contract Source: No source file</li> </ul> MainNet <code>534352</code> Type Contract Core <code>0xbebdb6C8ddC678FfA9f8748f85C815C556Dd8ac6</code> Token Bridge <code>0x24850c6f61C438823F01B7A3BF2B89B72174Fa9d</code> NFT Bridge N/A Relayer <code>0x27428DD2d3DD32A4D7f7C497eAaa23130d894911</code> TestNet <code>Sepolia - 534351</code> Type Contract Core <code>0x055F47F1250012C6B20c436570a76e52c17Af2D5</code> Token Bridge <code>0x22427d90B7dA3fA4642F7025A854c7254E4e45BF</code> NFT Bridge N/A Local Network Type Contract Core N/A Token Bridge N/A NFT Bridge N/A"},{"location":"build/start-building/supported-networks/evm/#mantle","title":"Mantle","text":""},{"location":"build/start-building/supported-networks/evm/#ecosystem_22","title":"Ecosystem","text":"<ul> <li>Website</li> <li>Block Explorer</li> <li>Developer Docs | Faucet</li> </ul>"},{"location":"build/start-building/supported-networks/evm/#wormhole-details_24","title":"Wormhole Details","text":"<ul> <li>Name: <code>mantle</code></li> <li>Chain ID: <code>35</code></li> <li>Contract Source: No source file</li> </ul> MainNet <code>5000</code> Type Contract Core <code>0xbebdb6C8ddC678FfA9f8748f85C815C556Dd8ac6</code> Token Bridge <code>0x24850c6f61C438823F01B7A3BF2B89B72174Fa9d</code> NFT Bridge N/A TestNet <code>Sepolia - 5003</code> Type Contract Core <code>0x376428e7f26D5867e69201b275553C45B09EE090</code> Token Bridge <code>0x75Bfa155a9D7A3714b0861c8a8aF0C4633c45b5D</code> NFT Bridge N/A Local Network Type Contract Core N/A Token Bridge N/A NFT Bridge N/A"},{"location":"build/start-building/supported-networks/evm/#polygon-sepolia","title":"Polygon Sepolia","text":""},{"location":"build/start-building/supported-networks/evm/#ecosystem_23","title":"Ecosystem","text":"<ul> <li>Website</li> <li>Developer Docs | Faucet</li> </ul>"},{"location":"build/start-building/supported-networks/evm/#wormhole-details_25","title":"Wormhole Details","text":"<ul> <li>Name: <code>polygon_sepolia</code></li> <li>Chain ID: <code>10007</code></li> <li>Contract Source: ethereum/contracts/bridge/Bridge.sol</li> </ul>"},{"location":"build/start-building/supported-networks/evm/#consistency-levels_13","title":"Consistency Levels","text":"<p>The options for <code>consistencyLevel</code> (i.e., finality) are:</p> Level Value Instant 200 <p>If a value is passed that isn't in the preceding set, it's assumed to mean finalized. For more information, see https://docs.polygon.technology/pos/architecture/heimdall/checkpoints/.</p> MainNet Type Contract Core N/A Token Bridge N/A NFT Bridge N/A TestNet <code>Sepolia - 80002</code> Type Contract Core <code>0x6b9C8671cdDC8dEab9c719bB87cBd3e782bA6a35</code> Token Bridge <code>0xC7A204bDBFe983FCD8d8E61D02b475D4073fF97e</code> NFT Bridge <code>0x23908A62110e21C04F3A4e011d24F901F911744A</code> Local Network Contract Type Contract Core N/A Token Bridge N/A NFT Bridge N/A"},{"location":"build/start-building/supported-networks/evm/#berachain","title":"Berachain","text":""},{"location":"build/start-building/supported-networks/evm/#ecosystem_24","title":"Ecosystem","text":"<ul> <li>Website</li> <li>Explorer update</li> <li>Docs | Faucet</li> </ul>"},{"location":"build/start-building/supported-networks/evm/#wormhole-details_26","title":"Wormhole Details","text":"<ul> <li>Name: <code>berachain</code></li> <li>Chain ID: <code>39</code></li> <li>Contract Source: No source file</li> </ul> MainNet Type Contract Core N/A Token Bridge N/A NFT Bridge N/A TestNet <code>80084</code> Type Contract Core <code>0xBB73cB66C26740F31d1FabDC6b7A46a038A300dd</code> Token Bridge <code>0xa10f2eF61dE1f19f586ab8B6F2EbA89bACE63F7a</code> NFT Bridge N/A Local Network Type Contract Core N/A Token Bridge N/A NFT Bridge N/A"},{"location":"build/start-building/supported-networks/evm/#blast","title":"Blast","text":""},{"location":"build/start-building/supported-networks/evm/#ecosystem_25","title":"Ecosystem","text":"<ul> <li>Website</li> <li>Explorer</li> <li>Docs</li> </ul>"},{"location":"build/start-building/supported-networks/evm/#wormhole-details_27","title":"Wormhole Details","text":"<ul> <li>Name: <code>blast</code></li> <li>Chain ID: <code>36</code></li> <li>Contract Source: No source file</li> </ul> MainNet <code>81457</code> Type Contract Core <code>0xbebdb6C8ddC678FfA9f8748f85C815C556Dd8ac6</code> Token Bridge <code>0x24850c6f61C438823F01B7A3BF2B89B72174Fa9d</code> NFT Bridge N/A Relayer <code>0x27428DD2d3DD32A4D7f7C497eAaa23130d894911</code> TestNet <code>168587773</code> Type Contract Core <code>0x473e002D7add6fB67a4964F13bFd61280Ca46886</code> Token Bridge <code>0x430855B4D43b8AEB9D2B9869B74d58dda79C0dB2</code> NFT Bridge N/A Local Network Type Contract Core N/A Token Bridge N/A NFT Bridge N/A"},{"location":"build/start-building/supported-networks/evm/#linea","title":"Linea","text":""},{"location":"build/start-building/supported-networks/evm/#ecosystem_26","title":"Ecosystem","text":"<ul> <li>Website</li> <li>Explorer</li> <li>Docs</li> </ul>"},{"location":"build/start-building/supported-networks/evm/#wormhole-details_28","title":"Wormhole Details","text":"<ul> <li>Name: <code>linea</code></li> <li>Chain ID: <code>38</code></li> <li>Contract Source: No source file</li> </ul> MainNet <code>59144</code> Type Contract Core N/A Token Bridge N/A NFT Bridge N/A TestNet <code>59141</code> Type Contract Core <code>0x79A1027a6A159502049F10906D333EC57E95F083</code> Token Bridge <code>0xC7A204bDBFe983FCD8d8E61D02b475D4073fF97e</code> NFT Bridge N/A Local Network Type Contract Core N/A Token Bridge N/A NFT Bridge N/A"},{"location":"build/start-building/supported-networks/evm/#seievm","title":"Seievm","text":""},{"location":"build/start-building/supported-networks/evm/#ecosystem_27","title":"Ecosystem","text":"<ul> <li>Website</li> <li>Explorer</li> <li>Docs</li> </ul>"},{"location":"build/start-building/supported-networks/evm/#wormhole-details_29","title":"Wormhole Details","text":"<ul> <li>Name: <code>seievm</code></li> <li>Chain ID: <code>40</code></li> <li>Contract Source: No source file</li> </ul> MainNet Type Contract Core N/A Token Bridge N/A NFT Bridge N/A TestNet Type Contract Core <code>0x07782FCe991dAb4DE7a3124032E534A0D059B4d8</code> Token Bridge N/A NFT Bridge N/A Local Network Type Contract Core N/A Token Bridge N/A NFT Bridge N/A"},{"location":"build/start-building/supported-networks/evm/#x-layer","title":"X Layer","text":""},{"location":"build/start-building/supported-networks/evm/#ecosystem_28","title":"Ecosystem","text":"<ul> <li>Website</li> <li>Explorer</li> <li>Docs</li> </ul>"},{"location":"build/start-building/supported-networks/evm/#wormhole-details_30","title":"Wormhole Details","text":"<ul> <li>Name: <code>xlayer</code></li> <li>Chain ID: <code>37</code></li> <li>Contract Source: No source file</li> </ul> MainNet Type Contract Core <code>0x194B123c5E96B9b2E49763619985790Dc241CAC0</code> Token Bridge <code>0x5537857664B0f9eFe38C9f320F75fEf23234D904</code> NFT Bridge N/A TestNet <code>195</code> Type Contract Core <code>0xA31aa3FDb7aF7Db93d18DDA4e19F811342EDF780</code> Token Bridge <code>0xdA91a06299BBF302091B053c6B9EF86Eff0f930D</code> NFT Bridge N/A Local Network Type Contract Core N/A Token Bridge N/A NFT Bridge N/A"},{"location":"build/start-building/supported-networks/near/","title":"NEAR","text":"<p>This page includes details for working with NEAR-environment chains</p>"},{"location":"build/start-building/supported-networks/near/#addresses","title":"Addresses","text":"<p>Because Wormhole works with many environments, the Wormhole address format is normalized. For NEAR-based chains, because NEAR addresses are arbitrary-length strings, a Wormhole formatted address is the sha256 hash of the address. E.g., <code>contract.portalbridge.near</code> =&gt; <code>0x148410499d3fcda4dcfd68a1ebfcdddda16ab28326448d4aae4d2f0465cdfcb7</code>.</p>"},{"location":"build/start-building/supported-networks/near/#emitter","title":"Emitter","text":"<p>The emitter address on NEAR chains is the sha256 digest of the program address string, normalized to Wormhole address format.</p>"},{"location":"build/start-building/supported-networks/near/#ecosystem","title":"Ecosystem","text":"<ul> <li>Website</li> <li>Block Explorer</li> <li>Developer Docs</li> </ul>"},{"location":"build/start-building/supported-networks/near/#wormhole-details","title":"Wormhole Details","text":"<ul> <li>Name: <code>near</code></li> <li>Chain ID: <code>15</code></li> <li>Contract Source: No source file</li> </ul>"},{"location":"build/start-building/supported-networks/near/#consistency-levels","title":"Consistency Levels","text":"<p>The options for <code>consistencyLevel</code> (i.e., finality) are:</p> Level Value Finalized 0 <p>This field may be ignored since the chain provides instant finality.</p> <p>For more information, see the NEAR Consensus docs.</p> MainNetTestNetLocal Network Type Contract Core <code>contract.wormhole_crypto.near</code> Token Bridge <code>contract.portalbridge.near</code> NFT Bridge N/A Type Contract Core <code>wormhole.wormhole.testnet</code> Token Bridge <code>token.wormhole.testnet</code> NFT Bridge N/A Type Contract Core <code>wormhole.test.near</code> Token Bridge <code>token.test.near</code> NFT Bridge N/A"},{"location":"build/start-building/supported-networks/solana/","title":"Solana","text":"<p>This page includes details for working with the Solana environment chains.</p>"},{"location":"build/start-building/supported-networks/solana/#developer-tools","title":"Developer Tools","text":"<p>To develop contracts for Solana, you'll need to have the following tools installed:</p> <ul> <li>Cargo, a Rust build tool and package manager</li> <li>Solana CLI tools - CLI tools for working with Solana</li> <li>Anchor - Smart contract development framework</li> </ul> <p>Install Wormhole Rust crates to interact with Solana on-chain programs and Token Bridge.</p> <p>Warning</p> <p>Known issues exist with Solana version 1.15 - downgrade to Solana 1.14.14</p>"},{"location":"build/start-building/supported-networks/solana/#addresses","title":"Addresses","text":"<p>Because Wormhole works with many environments, the Wormhole address format is normalized. For Solana-based chains, a Wormhole formatted address is the base58 decoded address. E.g. <code>worm2ZoG2kUd4vFXhvjh93UUH596ayRfgQ2MgjNMTth</code> becomes <code>0x0e0a589a41a55fbd66c52a475f2d92a6d3dc9b4747114cb9af825a98b545d3ce</code></p>"},{"location":"build/start-building/supported-networks/solana/#emitter","title":"Emitter","text":"<p>The emitter address on Solana chains is a Program-Derived Address derived by the application and normalized to the Wormhole address format. </p> <p>Note</p> <p>As the application developer, you decide whether this address will remain consistent over time or change. It is strongly recommended that you keep it consistent.</p>"},{"location":"build/start-building/supported-networks/solana/#solana_1","title":"Solana","text":"<p>Note</p> <p>The contract addresses for <code>testnet</code> are on the Solana <code>devnet</code></p>"},{"location":"build/start-building/supported-networks/solana/#ecosystem","title":"Ecosystem","text":"<ul> <li>Website</li> <li>Blockchain Explorer</li> <li>Developer Docs</li> </ul>"},{"location":"build/start-building/supported-networks/solana/#wormhole-details","title":"Wormhole Details","text":"<ul> <li>Name: <code>solana</code></li> <li>Chain ID: <code>1</code></li> <li>Contract Source: No source file</li> </ul>"},{"location":"build/start-building/supported-networks/solana/#consistency-levels","title":"Consistency Levels","text":"<p>The options for <code>consistencyLevel</code> (i.e., finality) are:</p> Level Value Confirmed 0 Finalized 1 <p>For more information, see the Solana Docs.</p> MainNetTestNetLocal Network Contract <p><code>Mainnet Beta - 5eykt4UsFv8P8NJdTREpY1vzqKqZKvdpKuc147dw2N9d</code></p> Type Contract Core <code>worm2ZoG2kUd4vFXhvjh93UUH596ayRfgQ2MgjNMTth</code> Token Bridge <code>wormDTUJ6AWPNvk59vGQbDvGJmqbDTdgWgAqcLBCgUb</code> NFT Bridge <code>WnFt12ZrnzZrFZkt2xsNsaNWoQribnuQ5B5FrDbwDhD</code> <p><code>DevNet - EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG</code></p> Type Contract Core <code>3u8hJUVTA4jH1wYAyUur7FFZVQ8H635K3tSHHF4ssjQ5</code> Token Bridge <code>DZnkkTmCiFWfYTfT41X3Rd1kDgozqzxWaHqsw6W4x2oe</code> NFT Bridge <code>2rHhojZ7hpu1zA91nvZmT8TqWWvMcKmmNBCr2mKTtMq4</code> Type Contract Core <code>Bridge1p5gheXUvJ6jGWGeCsgPKgnE3YgdGKRVCMY9o</code> Token Bridge <code>B6RHG3mfcckmrYN1UhmJzyS1XX3fZKbkeUcpJe9Sy3FE</code> NFT Bridge <code>NFTWqJR8YnRVqPDvTJrYuLrQDitTG5AScqbeghi4zSA</code>"},{"location":"build/start-building/supported-networks/solana/#pythnet","title":"Pythnet","text":""},{"location":"build/start-building/supported-networks/solana/#ecosystem_1","title":"Ecosystem","text":"<ul> <li>Website</li> <li>Developer Docs</li> </ul>"},{"location":"build/start-building/supported-networks/solana/#wormhole-details_1","title":"Wormhole Details","text":"<ul> <li>Name: <code>pythnet</code></li> <li>Chain ID: <code>26</code></li> <li>Contract Source: No source file</li> </ul> MainNetTestNetLocal Network Type Contract Core <code>H3fxXJ86ADW2PNuDDmZJg6mzTtPxkYCpNuQUTgmJ7AjU</code> Token Bridge N/A NFT Bridge N/A Type Contract Core <code>EUrRARh92Cdc54xrDn6qzaqjA77NRrCcfbr8kPwoTL4z</code> Token Bridge N/A NFT Bridge N/A Type Contract Core N/A Token Bridge N/A NFT Bridge N/A"},{"location":"build/start-building/supported-networks/sui/","title":"Sui","text":"<p>This page contains details for working with Sui chains.</p>"},{"location":"build/start-building/supported-networks/sui/#developer-tools","title":"Developer Tools","text":"<p>You can install the Sui development tools using <code>cargo install</code>:</p> <pre><code>cargo install --locked \\\n    --git https://github.com/MystenLabs/sui.git \\\n    --rev 09b2081498366df936abae26eea4b2d5cafb2788 \\\n    sui sui-faucet\n</code></pre>"},{"location":"build/start-building/supported-networks/sui/#addresses","title":"Addresses","text":"<p>Because Wormhole works with many environments, the Wormhole address format is normalized. For Sui-based chains, no normalization is needed for standard addresses since they're already 32 bytes. E.g., <code>0x84a5f374d29fc77e370014dce4fd6a55b58ad608de8074b0be5571701724da31</code> remains the same with no changes.</p>"},{"location":"build/start-building/supported-networks/sui/#emitter","title":"Emitter","text":"<p>On Sui, the emitter is the object ID of the emitter capability.</p>"},{"location":"build/start-building/supported-networks/sui/#sui_1","title":"Sui","text":""},{"location":"build/start-building/supported-networks/sui/#ecosystem","title":"Ecosystem","text":"<ul> <li>Website</li> <li>SuiVision Block Explorer | Suiscan</li> <li>Developer Docs | Faucet</li> </ul>"},{"location":"build/start-building/supported-networks/sui/#wormhole-details","title":"Wormhole Details","text":"<ul> <li>Name: <code>sui</code></li> <li>Chain ID: <code>21</code></li> <li>Contract Source: No source file</li> </ul>"},{"location":"build/start-building/supported-networks/sui/#consistency-levels","title":"Consistency Levels","text":"<p>The options for <code>consistencyLevel</code> (i.e., finality) are:</p> Level Value Finalized 0 <p>This field may be ignored since the chain provides instant finality.</p> <p>For more information, see the Sui consensus docs.</p> MainNet <code>35834a8a</code>TestNet <code>4c78adac</code>Local Network Type Contract Core <code>0xaeab97f96cf9877fee2883315d459552b2b921edc16d7ceac6eab944dd88919c</code> Token Bridge <code>0xc57508ee0d4595e5a8728974a4a93a787d38f339757230d441e895422c07aba9</code> NFT Bridge N/A Type Contract Core <code>0x31358d198147da50db32eda2562951d53973a0c0ad5ed738e9b17d88b213d790</code> Token Bridge <code>0x6fb10cdb7aa299e9a4308752dadecb049ff55a892de92992a1edbd7912b3d6da</code> NFT Bridge N/A Type Contract Core <code>0x12253210c90f89e7a8525e6c52d41309ff5bfb31f43f561b5fe6f50cd72f9668</code> Token Bridge <code>0x830ed228c6f1bcb40003bb49af3277df2cbf933d63a6bcdcb0ba4580a1a7654e</code> NFT Bridge N/A"},{"location":"build/start-building/supported-networks/cosmos/","title":"Cosmos","text":"<p>In this section, you'll learn how to work with Wormhole in the Cosmos ecosystem and onboard your Cosmos chain to Wormhole Gateway.</p> <ul> <li> <p> Cosmos</p> <p>Learn how to work with Wormhole in the Cosmos ecosystem with address formats, emitter details, contract consistency levels, and key contract info. </p> <p> Start onboarding</p> </li> </ul> <ul> <li> <p> Onboard to Cosmos Gateway</p> <p>Learn how to onboard your Cosmos chain to Wormhole Gateway to enable bridging to and from your chain, including how to satisfy the requisite governance proposals, IBC setup, and UI integration.</p> <p> Start onboarding</p> </li> </ul>"},{"location":"build/start-building/supported-networks/cosmos/cosmos/","title":"Cosmos","text":"<p>This page includes details for working with Cosmos environment chains. </p>"},{"location":"build/start-building/supported-networks/cosmos/cosmos/#addresses","title":"Addresses","text":"<p>Because Wormhole works with many environments, the Wormhole address format is normalized. For Cosmos-based chains, this means a Wormhole formatted address is the bech32 format converted to hex. E.g. <code>xpla137w0wfch2dfmz7jl2ap8pcmswasj8kg06ay4dtjzw7tzkn77ufxqfw7acv</code> becomes <code>0x8f9cf727175353b17a5f574270e370776123d90fd74956ae4277962b4fdee24c</code>.</p>"},{"location":"build/start-building/supported-networks/cosmos/cosmos/#emitter","title":"Emitter","text":"<p>The emitter address on Cosmos chains is the contract's canonical address, normalized to the Wormhole address format. </p>"},{"location":"build/start-building/supported-networks/cosmos/cosmos/#cosmos-hub","title":"Cosmos Hub","text":""},{"location":"build/start-building/supported-networks/cosmos/cosmos/#ecosystem","title":"Ecosystem","text":"<ul> <li>Developer Docs</li> </ul>"},{"location":"build/start-building/supported-networks/cosmos/cosmos/#wormhole-details","title":"Wormhole Details","text":"<ul> <li>Name: <code>cosmoshub</code></li> <li>Chain ID: <code>4000</code></li> <li>Contract Source: No source file</li> </ul> MainNet <code>cosmoshub-4</code>TestNet <code>theta-testnet-001</code>Local Network Type Contract Core N/A Token Bridge N/A NFT Bridge N/A Type Contract Core N/A Token Bridge N/A NFT Bridge N/A Type Contract Core N/A Token Bridge N/A NFT Bridge N/A"},{"location":"build/start-building/supported-networks/cosmos/cosmos/#evmos","title":"Evmos","text":""},{"location":"build/start-building/supported-networks/cosmos/cosmos/#ecosystem_1","title":"Ecosystem","text":"<ul> <li>Website</li> <li>Mintscan</li> <li>Evmos JSON updates</li> <li>Faucet</li> </ul>"},{"location":"build/start-building/supported-networks/cosmos/cosmos/#wormhole-details_1","title":"Wormhole Details","text":"<ul> <li>Name: <code>evmos</code></li> <li>Chain ID: <code>4001</code></li> <li>Contract Source: No source file</li> </ul> MainNet <code>evmos_9001-2</code>TestNet <code>evmos_9000-4</code>Local Network Type Contract Core N/A Token Bridge N/A NFT Bridge N/A Type Contract Core N/A Token Bridge N/A NFT Bridge N/A Type Contract Core N/A Token Bridge N/A NFT Bridge N/A"},{"location":"build/start-building/supported-networks/cosmos/cosmos/#kujira","title":"Kujira","text":""},{"location":"build/start-building/supported-networks/cosmos/cosmos/#ecosystem_2","title":"Ecosystem","text":"<ul> <li>No webpage, update here</li> <li>No explorer, update here</li> <li>Kujira JSON updates</li> </ul>"},{"location":"build/start-building/supported-networks/cosmos/cosmos/#wormhole-details_2","title":"Wormhole Details","text":"<ul> <li>Name: <code>kujira</code></li> <li>Chain ID: <code>4002</code></li> <li>Contract Source: No source file</li> </ul> MainNet <code>kaiyo-1</code>TestNet <code>harpoon-4</code>Local Network Type Contract Core N/A Token Bridge N/A NFT Bridge N/A Type Contract Core N/A Token Bridge N/A NFT Bridge N/A Type Contract Core N/A Token Bridge N/A NFT Bridge N/A"},{"location":"build/start-building/supported-networks/cosmos/cosmos/#injective","title":"Injective","text":""},{"location":"build/start-building/supported-networks/cosmos/cosmos/#ecosystem_3","title":"Ecosystem","text":"<ul> <li>Website</li> <li>Injective Explorer | Injective TestNet Explorer</li> <li>Developer Docs | Injective TypeScript SDK docs | Injective trading docs</li> <li>Faucet</li> </ul>"},{"location":"build/start-building/supported-networks/cosmos/cosmos/#wormhole-details_3","title":"Wormhole Details","text":"<ul> <li>Name: <code>injective</code></li> <li>Chain ID: <code>19</code></li> <li>Contract Source: No source file</li> </ul> MainNet <code>injective-1</code>TestNet <code>injective-888</code>Local Network Type Contract Core <code>inj17p9rzwnnfxcjp32un9ug7yhhzgtkhvl9l2q74d</code> Token Bridge <code>inj1ghd753shjuwexxywmgs4xz7x2q732vcnxxynfn</code> NFT Bridge N/A Type Contract Core <code>inj1xx3aupmgv3ce537c0yce8zzd3sz567syuyedpg</code> Token Bridge <code>inj1q0e70vhrv063eah90mu97sazhywmeegp7myvnh</code> NFT Bridge N/A Type Contract Core N/A Token Bridge N/A NFT Bridge N/A"},{"location":"build/start-building/supported-networks/cosmos/cosmos/#osmosis","title":"Osmosis","text":""},{"location":"build/start-building/supported-networks/cosmos/cosmos/#ecosystem_4","title":"Ecosystem","text":"<ul> <li>Website</li> <li>Block Explorer</li> <li>Developer Docs</li> <li>Faucet</li> </ul>"},{"location":"build/start-building/supported-networks/cosmos/cosmos/#wormhole-details_4","title":"Wormhole Details","text":"<ul> <li>Name: <code>osmosis</code></li> <li>Chain ID: <code>20</code></li> <li>Contract Source: No source file</li> </ul> MainNet <code>osmosis-1</code>TestNet <code>osmo-test-5</code>Local Network Type Contract Core N/A Token Bridge N/A NFT Bridge N/A Type Contract Core <code>osmo1hggkxr0hpw83f8vuft7ruvmmamsxmwk2hzz6nytdkzyup9krt0dq27sgyx</code> Token Bridge N/A NFT Bridge N/A Type Contract Core N/A Token Bridge N/A NFT Bridge N/A"},{"location":"build/start-building/supported-networks/cosmos/cosmos/#sei","title":"Sei","text":""},{"location":"build/start-building/supported-networks/cosmos/cosmos/#ecosystem_5","title":"Ecosystem","text":"<ul> <li>Website</li> <li>SeiScan Explorer</li> <li>Faucet</li> </ul>"},{"location":"build/start-building/supported-networks/cosmos/cosmos/#wormhole-details_5","title":"Wormhole Details","text":"<ul> <li>Name: <code>sei</code></li> <li>Chain ID: <code>32</code></li> <li>Contract Source: No source file</li> </ul> MainNet <code>pacific-1</code>TestNet <code>atlantic-2</code>Local Network Type Contract Core <code>sei1gjrrme22cyha4ht2xapn3f08zzw6z3d4uxx6fyy9zd5dyr3yxgzqqncdqn</code> Token Bridge <code>sei1smzlm9t79kur392nu9egl8p8je9j92q4gzguewj56a05kyxxra0qy0nuf3</code> NFT Bridge N/A Type Contract Core <code>sei1nna9mzp274djrgzhzkac2gvm3j27l402s4xzr08chq57pjsupqnqaj0d5s</code> Token Bridge <code>sei1jv5xw094mclanxt5emammy875qelf3v62u4tl4lp5nhte3w3s9ts9w9az2</code> NFT Bridge N/A Type Contract Core N/A Token Bridge N/A NFT Bridge N/A"},{"location":"build/start-building/supported-networks/cosmos/cosmos/#terra","title":"Terra","text":""},{"location":"build/start-building/supported-networks/cosmos/cosmos/#ecosystem_6","title":"Ecosystem","text":"<ul> <li>Website</li> <li>Block Explorer</li> <li>Developer Docs</li> <li>Faucet</li> </ul>"},{"location":"build/start-building/supported-networks/cosmos/cosmos/#wormhole-details_6","title":"Wormhole Details","text":"<ul> <li>Name: <code>terra</code></li> <li>Chain ID: <code>3</code></li> <li>Contract Source: No source file</li> </ul> MainNet <code>columbus-5</code>TestNet <code>bombay-12</code>Local Network Type Contract Core <code>terra1dq03ugtd40zu9hcgdzrsq6z2z4hwhc9tqk2uy5</code> Token Bridge <code>terra10nmmwe8r3g99a9newtqa7a75xfgs2e8z87r2sf</code> NFT Bridge N/A Type Contract Core <code>terra1pd65m0q9tl3v8znnz5f5ltsfegyzah7g42cx5v</code> Token Bridge <code>terra1pseddrv0yfsn76u4zxrjmtf45kdlmalswdv39a</code> NFT Bridge N/A Type Contract Core <code>terra14hj2tavq8fpesdwxxcu44rty3hh90vhujrvcmstl4zr3txmfvw9ssrc8au</code> Token Bridge <code>terra1nc5tatafv6eyq7llkr2gv50ff9e22mnf70qgjlv737ktmt4eswrquka9l6</code> NFT Bridge N/A"},{"location":"build/start-building/supported-networks/cosmos/cosmos/#terra2","title":"Terra2","text":""},{"location":"build/start-building/supported-networks/cosmos/cosmos/#wormhole-details_7","title":"Wormhole Details","text":"<ul> <li>Name: <code>terra2</code></li> <li>Chain ID: <code>18</code></li> <li>Contract Source: No source file</li> </ul> MainNet <code>phoenix-1</code>TestNet <code>pisco-1</code>Local Network Type Contract Core <code>terra12mrnzvhx3rpej6843uge2yyfppfyd3u9c3uq223q8sl48huz9juqffcnhp</code> Token Bridge <code>terra153366q50k7t8nn7gec00hg66crnhkdggpgdtaxltaq6xrutkkz3s992fw9</code> NFT Bridge N/A Type Contract Core <code>terra19nv3xr5lrmmr7egvrk2kqgw4kcn43xrtd5g0mpgwwvhetusk4k7s66jyv0</code> Token Bridge <code>terra1c02vds4uhgtrmcw7ldlg75zumdqxr8hwf7npseuf2h58jzhpgjxsgmwkvk</code> NFT Bridge N/A Type Contract Core <code>terra14hj2tavq8fpesdwxxcu44rty3hh90vhujrvcmstl4zr3txmfvw9ssrc8au</code> Token Bridge <code>terra1nc5tatafv6eyq7llkr2gv50ff9e22mnf70qgjlv737ktmt4eswrquka9l6</code> NFT Bridge N/A"},{"location":"build/start-building/supported-networks/cosmos/cosmos/#xpla","title":"XPLA","text":""},{"location":"build/start-building/supported-networks/cosmos/cosmos/#ecosystem_7","title":"Ecosystem","text":"<ul> <li>Website</li> <li>Block Explorer</li> <li>Developer Docs</li> <li>Faucet</li> </ul>"},{"location":"build/start-building/supported-networks/cosmos/cosmos/#wormhole-details_8","title":"Wormhole Details","text":"<ul> <li>Name: <code>xpla</code></li> <li>Chain ID: <code>28</code></li> <li>Contract Source: No source file</li> </ul> MainNet <code>dimension_37-1</code>TestNet <code>cube_47-5</code>Local Network Type Contract Core <code>xpla1jn8qmdda5m6f6fqu9qv46rt7ajhklg40ukpqchkejcvy8x7w26cqxamv3w</code> Token Bridge <code>xpla137w0wfch2dfmz7jl2ap8pcmswasj8kg06ay4dtjzw7tzkn77ufxqfw7acv</code> NFT Bridge N/A Type Contract Core <code>xpla1upkjn4mthr0047kahvn0llqx4qpqfn75lnph4jpxfn8walmm8mqsanyy35</code> Token Bridge <code>xpla1kek6zgdaxcsu35nqfsyvs2t9vs87dqkkq6hjdgczacysjn67vt8sern93x</code> NFT Bridge N/A Type Contract Core N/A Token Bridge N/A NFT Bridge N/A"},{"location":"build/start-building/supported-networks/cosmos/cosmos/#neutron","title":"Neutron","text":""},{"location":"build/start-building/supported-networks/cosmos/cosmos/#ecosystem_8","title":"Ecosystem","text":"<ul> <li>Website</li> <li>Block Explorer</li> <li>Developer docs</li> </ul>"},{"location":"build/start-building/supported-networks/cosmos/cosmos/#wormhole-details_9","title":"Wormhole Details","text":"<ul> <li>Name: <code>neutron</code></li> <li>Chain ID: <code>4003</code></li> <li>Contract Source: No source file</li> </ul> MainNet <code>neutron-1</code>TestNet <code>pion-1</code>Local Network Type Contract Core <code>neutron16rerygcpahqcxx5t8vjla46ym8ccn7xz7rtc6ju5ujcd36cmc7zs9zrunh</code> Token Bridge N/A NFT Bridge N/A Type Contract Core <code>neutron1enf63k37nnv9cugggpm06mg70emcnxgj9p64v2s8yx7a2yhhzk2q6xesk4</code> Token Bridge N/A NFT Bridge N/A Type Contract Core N/A Token Bridge N/A NFT Bridge N/A"},{"location":"build/start-building/supported-networks/cosmos/cosmos/#celestia","title":"Celestia","text":""},{"location":"build/start-building/supported-networks/cosmos/cosmos/#ecosystem_9","title":"Ecosystem","text":"<ul> <li>Website</li> <li>Block Explorer</li> <li>Developer Docs</li> </ul>"},{"location":"build/start-building/supported-networks/cosmos/cosmos/#wormhole-details_10","title":"Wormhole Details","text":"<ul> <li>Name: <code>celestia</code></li> <li>Chain ID: <code>4004</code></li> <li>Contract Source: No source file, update here</li> </ul> MainNet <code>celestia</code>TestNet <code>mocha-4</code>Local Network Type Contract Core N/A Token Bridge N/A NFT Bridge N/A Type Contract Core N/A Token Bridge N/A NFT Bridge N/A Type Contract Core N/A Token Bridge N/A NFT Bridge N/A"},{"location":"build/start-building/supported-networks/cosmos/cosmos/#dymension","title":"Dymension","text":""},{"location":"build/start-building/supported-networks/cosmos/cosmos/#ecosystem_10","title":"Ecosystem","text":"<ul> <li>Website</li> <li>Block Explorer</li> <li>Developer Docs</li> </ul>"},{"location":"build/start-building/supported-networks/cosmos/cosmos/#wormhole-details_11","title":"Wormhole Details","text":"<ul> <li>Name: <code>dymension</code></li> <li>Chain ID: <code>4007</code></li> <li>Contract Source: No source file</li> </ul> MainNet <code>dymension_1100-1</code>TestNet Local Network Type Contract Core N/A Token Bridge N/A NFT Bridge N/A Type Contract Core N/A Token Bridge N/A NFT Bridge N/A Type Contract Core N/A Token Bridge N/A NFT Bridge N/A"},{"location":"build/start-building/supported-networks/cosmos/cosmos/#stargaze","title":"Stargaze","text":""},{"location":"build/start-building/supported-networks/cosmos/cosmos/#ecosystem_11","title":"Ecosystem","text":"<ul> <li>Website</li> <li>Block Explorer</li> <li>Developer Docs</li> </ul>"},{"location":"build/start-building/supported-networks/cosmos/cosmos/#wormhole-details_12","title":"Wormhole Details","text":"<ul> <li>Name: <code>stargaze</code></li> <li>Chain ID: <code>4005</code></li> <li>Contract Source: No source file</li> </ul> MainNet <code>stargaze-1</code>TestNetLocal Network Type Contract Core N/A Token Bridge N/A NFT Bridge N/A Type Contract Core N/A Token Bridge N/A NFT Bridge N/A Type Contract Core N/A Token Bridge N/A NFT Bridge N/A"},{"location":"build/start-building/supported-networks/cosmos/cosmos/#seda","title":"SEDA","text":""},{"location":"build/start-building/supported-networks/cosmos/cosmos/#ecosystem_12","title":"Ecosystem","text":"<ul> <li>Website</li> <li>Block Explorer</li> <li>Developer Docs</li> </ul>"},{"location":"build/start-building/supported-networks/cosmos/cosmos/#wormhole-details_13","title":"Wormhole Details","text":"<ul> <li>Name: <code>seda</code></li> <li>Chain ID: <code>4006</code></li> <li>Contract Source: No source file</li> </ul> MainNetTestNet <code>seda-1-testnet</code>Local Network Type Contract Core N/A Token Bridge N/A NFT Bridge N/A Type Contract Core N/A Token Bridge N/A NFT Bridge N/A Type Contract Core N/A Token Bridge N/A NFT Bridge N/A"},{"location":"build/start-building/supported-networks/cosmos/cosmos/#provenance","title":"Provenance","text":""},{"location":"build/start-building/supported-networks/cosmos/cosmos/#ecosystem_13","title":"Ecosystem","text":"<ul> <li>Website</li> <li>Block Explorer</li> <li>Developer Docs</li> </ul>"},{"location":"build/start-building/supported-networks/cosmos/cosmos/#wormhole-details_14","title":"Wormhole Details","text":"<ul> <li>Name: <code>provenance</code></li> <li>Chain ID: <code>4008</code></li> <li>Contract Source: No source file</li> </ul> MainNet <code>pio-mainnet-1</code>TestNetLocal Network Type Contract Core N/A Token Bridge N/A NFT Bridge N/A Type Contract Core N/A Token Bridge N/A NFT Bridge N/A Type Contract Core N/A Token Bridge N/A NFT Bridge N/A"},{"location":"build/start-building/supported-networks/cosmos/gateway/","title":"Wormhole Gateway Onboarding Instructions","text":"<p>This page is for any Cosmos chain developer who wants to enable bridging from Gateway. Gateway is Wormhole's Cosmos chain that leverages the Wormhole Guardian network for easy bridging from Ethereum to Cosmos. For an overview of Gateway, see The Gateway to Cosmos.</p>"},{"location":"build/start-building/supported-networks/cosmos/gateway/#propose-adding-your-chain-to-the-wormhole-guardians","title":"Propose Adding Your Chain to the Wormhole Guardians","text":"<ol> <li>Open a new GitHub governance discussion under Wormhole Gateway by filling out the Cosmos Chain Governance Proposal Template</li> <li>Allow 96 hours for discussion and governance vote</li> </ol>"},{"location":"build/start-building/supported-networks/cosmos/gateway/#join-the-wormhole-discord","title":"Join the Wormhole Discord","text":"<ol> <li>Join the Wormhole Discord</li> <li>Ping the moderator, Susu (<code>susu.wormhole</code>), to get added to the <code>#guardian-cosmos</code> channel</li> </ol>"},{"location":"build/start-building/supported-networks/cosmos/gateway/#establish-an-ibc-connection","title":"Establish an IBC Connection","text":"<ol> <li> <p>Allowlist your IBC relayer on Wormhole Gateway</p> <ol> <li>The IBC relayer should generate an address via the <code>wormchaind</code> CLI</li> <li> <p>Fill out the IBC relayer allowlist request template below and post the request in the <code>#guardian-cosmos</code> channel</p> View IBC relayer allowlist request template <pre><code>Hey @Guardians! Thank you for passing governance to support **[Cosmos Chain]** via Wormhole Gateway. We are very excited to integrate with Wormhole!\n\nWe will be using **[Relayer Provider]** as our IBC relayer to support the connection to Wormhole Gateway. Their address is **[Wormhole Gateway address].** \n\nCould one of the Guardians please allowlist this address so that it can submit transactions to Wormhole Gateway?\n\nWe understand that if this address misbehaves, the sponsoring Guardian can remove it from the allowlist at any time, which would effectively shut down IBC bridging to/from our chain and Gateway.\n\nThank you!\n</code></pre> </li> </ol> </li> <li> <p>Establish the IBC connection</p> <ol> <li>Please ensure that the parameters <code>trusting_period</code> and <code>trust_threshold</code> are set to the safest values. For example:<ol> <li><code>Trust_threshold</code> should be 2/3</li> <li><code>Trusting_period</code> should be 2/3 of the unbonding period of your chain</li> </ol> </li> <li>Please see Wormchain Syncing documentation to learn how to set up your own Wormhole Gateway node to connect your IBC relayer to. Alternatively, you can browse and connect to available public nodes on the Cosmos chain registry</li> <li> <p>Below, you'll find an example IBC relayer configuration for Wormhole Gateway</p> View example IBC relayer configuration for Wormhole Gateway <pre><code>[global]\nlog_level = \"info\"\n\n[mode.clients]\nenabled = true\nrefresh = true\nmisbehaviour = false\n\n[mode.connections]\nenabled = false\n\n[mode.channels]\nenabled = false\n\n[mode.packets]\nenabled = true\nclear_interval = 50\nclear_on_start = true\ntx_confirmation = true\nauto_register_counterparty_payee = false\n\n[rest]\nenabled = true\nhost = \"127.0.0.1\"\nport = 3000\n\n[telemetry]\nenabled = true\nhost = \"127.0.0.1\"\nport = 3001\n\n[telemetry.buckets.latency_submitted]\nstart = 500\nend = 20000\nbuckets = 10\n\n[telemetry.buckets.latency_confirmed]\nstart = 1000\nend = 30000\nbuckets = 10\n\n[[chains]]\nid = \"wormchain\"\ntype = \"CosmosSdk\"\nrpc_addr = \"...\"\ngrpc_addr = \"...\"\nrpc_timeout = \"10s\"\ntrusted_node = true\naccount_prefix = \"wormhole\"\nkey_name = \"default\"\nkey_store_type = \"Test\"\nstore_prefix = \"ibc\"\ndefault_gas = 1000000\nmax_gas = 9000000\ngas_multiplier = 1.2\nmax_msg_num = 30\nmax_tx_size = 180000\nmax_grpc_decoding_size = 33554432\nclock_drift = \"5s\"\nmax_block_time = \"30s\"\nccv_consumer_chain = false\nmemo_prefix = \"\"\nsequential_batch_tx = false\ntrusting_period = '14days'\n\n[chains.event_source]\nmode = \"push\"\nurl = \"...\"\nbatch_delay = \"500ms\"\n\n[chains.trust_threshold]\nnumerator = \"2\"\ndenominator = \"3\"\n\n[chains.gas_price]\nprice = 0.0\ndenom = \"utest\"\n\n[chains.packet_filter]\npolicy = 'allow'\nlist = [\n['transfer', 'channel-3'], # Osmosis transfer\n]\n\n[chains.address_type]\nderivation = \"cosmos\"\n</code></pre> </li> </ol> </li> <li> <p>Share the IBC connection details in the <code>#guardian-cosmos</code> channel along with a request to the Wormhole contributors to prepare governance for the IBC connection. Allow 48 hours for governance vote on accepting this IBC channel</p> </li> </ol>"},{"location":"build/start-building/supported-networks/cosmos/gateway/#optional-ui-integration-with-wormhole-connect","title":"Optional UI Integration with Wormhole Connect","text":"<p>Wormhole Connect is a seamless way to embed bridging directly to your app with three lines of code. Integrating Connect is fast, customizable, and brings all the functionality and utility of Wormhole right into your own application.</p> <p>If you'd like to add your Cosmos chain into Wormhole Connect, please refer to these reference PRs. Wormhole core contributors will need to review your PRs prior to merging them.</p> <ol> <li>Add your Cosmos chain ID to the Wormhole SDK</li> <li>Add your Cosmos chain to Wormhole Connect</li> </ol>"},{"location":"build/start-building/supported-networks/cosmos/gateway/#register-assets","title":"Register Assets","text":"<p>This final step involves registering bridged assets with the Cosmos Chain Registry and other relevant wallet and frontend registries.</p> <ol> <li>Permissionlessly attest the assets you want to bridge into your chain (if not already attested) to Wormhole Gateway</li> <li>Raise relevant PRs to ensure that explorers, wallets, and other UIs recognize the Wormhole assets when they are bridged to your chain. Here is an example PR adding Wormhole assets to Osmosis Mintscan</li> </ol> <p>Congratulations! You\u2019ve successfully connected your Cosmos chain to Gateway. If you have any questions or concerns, please contact Susu on the Wormhole Discord.</p>"},{"location":"build/toolkit/","title":"Wormhole Tooling","text":"<p>Regardless of which network development environment you are using, there are a few Wormhole-specific tools you should know about.</p>"},{"location":"build/toolkit/#get-started","title":"Get Started","text":"<ul> <li> <p> Wormholescan</p> <p>Wormholescan is an explorer for looking at individual transfer statuses on MainNet and TestNet.</p> <p> Review transactions on Wormholescan</p> </li> <li> <p> Wormhole CLI Tool</p> <p>The Wormhole CLI is a Swiss-Army knife utility command line tool. It is excellent for creating one-off VAAs, parsing VAAs, reading Wormhole contract configurations, and more.</p> <p> Get started with the CLI</p> </li> <li> <p> Wormhole SDK</p> <p>Explore Wormhole's TypeScript SDK and learn how to perform different types of transfers, including native, token, USDC, and Gateway transfers.</p> <p> Get started with the SDK</p> </li> <li> <p> Tilt</p> <p>Learn about Tilt, a Wormhole developer environment with a local Kubernetes set up for cross-chain testing with Guardian nodes and relayers for seamless development.</p> <p> Get started with Tilt</p> </li> </ul>"},{"location":"build/toolkit/#additional-resources","title":"Additional Resources","text":"<ul> <li> <p> Wormhole Spy SDK</p> <p>The Wormhole Spy SDK allows you to listen to all the Guardian Network activity.</p> <p> Check out the Spy SDK repository</p> </li> <li> <p> VAA Parser</p> <p>The VAA Parser is a resource for parsing out details of an encoded VAA.</p> <p> Try the VAA Parser</p> </li> </ul>"},{"location":"build/toolkit/cli/","title":"Wormhole CLI","text":"<p>This tool is a command-line interface to Wormhole, allowing you to perform various actions, such as querying a transaction's status or submitting token transfers.</p>"},{"location":"build/toolkit/cli/#installation","title":"Installation","text":"<p>Clone the repository and change directories to the appropriate directory:</p> <pre><code>git clone https://github.com/wormhole-foundation/wormhole &amp;&amp;\ncd wormhole/clients/js\n</code></pre> <p>Build and install the CLI tool:</p> <pre><code>make install\n</code></pre> <p>This installs two binaries, <code>worm-fetch-governance</code> and <code>worm</code> on your <code>$PATH</code>. To use <code>worm</code>, set up <code>$HOME/.wormhole/.env</code> with your private keys, based on <code>.env.sample</code> in this folder.</p>"},{"location":"build/toolkit/cli/#usage","title":"Usage","text":"<p>You can interact with the Wormhole CLI by typing <code>worm</code> and including the <code>command</code> and any necessary subcommands and parameters.  </p> Command Description <code>worm aptos INSERT_COMMAND</code> Aptos utilities <code>worm edit-vaa INSERT_COMMAND</code> Edits or generates a VAA <code>worm evm INSERT_COMMAND</code> EVM utilities <code>worm generate INSERT_COMMAND</code> Generate VAAs (DevNet and TestNet only) <code>worm info INSERT_COMMAND</code> Contract, chain, RPC, and address information utilities <code>worm near INSERT_NETWORK, INSERT_ACCOUNT</code> NEAR utilities <code>worm parse INSERT_VAA</code> Parse a VAA (can be in either hex or base64 format) <code>worm recover INSERT_DIGEST INSERT_SIGNATURE</code> Recover an address from a signature <code>worm status INSERT_NETWORK, INSERT_CHAIN, INSERT_TXN_HASH</code> Prints information about the automatic delivery initiated on the specified network, chain, and transaction hash <code>worm submit INSERT_VAA</code> Execute a VAA <code>worm sui INSERT_COMMAND</code> Sui utilities <code>worm transfer INSERT_SOURCE_CHAIN, INSERT_DESTINATION_CHAIN, INSERT_DESTINATION_ADDRESS, INSERT_AMOUNT, INSERT_NETWORK</code> Transfers a token <code>worm verify-vaa INSERT_VAA, INSERT_NETWORK</code> Verifies a VAA by querying the Core Contract on Ethereum <p>You can also refer to the below options, available with all <code>worm</code> commands:</p> <pre><code>Options:\n  --help     Show help                                                 [boolean]\n  --version  Show version number                                       [boolean]\n</code></pre>"},{"location":"build/toolkit/cli/#subcommands","title":"Subcommands","text":"Aptos <pre><code>worm aptos INSERT_COMMAND\n\nCommands:\n  worm aptos init-token-bridge              Init token bridge contract\n  worm aptos init-wormhole                  Init Wormhole core contract\n  worm aptos deploy &lt;package-dir&gt;           Deploy an Aptos package\n  worm aptos deploy-resource &lt;seed&gt;         Deploy an Aptos package using a\n  &lt;package-dir&gt;                             resource account\n  worm aptos send-example-message           Send example message\n  &lt;message&gt;\n  worm aptos derive-resource-account        Derive resource account address\n  &lt;account&gt; &lt;seed&gt;\n  worm aptos derive-wrapped-address         Derive wrapped coin type\n  &lt;chain&gt; &lt;origin-address&gt;\n  worm aptos hash-contracts &lt;package-dir&gt;   Hash contract bytecodes for upgrade\n  worm aptos upgrade &lt;package-dir&gt;          Perform upgrade after VAA has been\n                                            submitted\n  worm aptos migrate                        Perform migration after contract\n                                            upgrade\n  worm aptos faucet                         Request money from the faucet for a\n                                            given account\n  worm aptos start-validator                Start a local aptos validator\n\nOptions:\n  --help     Show help                                                 [boolean]\n  --version  Show version number                                       [boolean]\n</code></pre> Edit VAA <pre><code>worm edit-vaa INSERT_COMMAND\n\nOptions:\n      --help                       Show help                           [boolean]\n      --version                    Show version number                 [boolean]\n  -v, --vaa                        vaa in hex format         [string] [required]\n  -n, --network                    Network\n                            [required] [choices: \"mainnet\", \"testnet\", \"devnet\"]\n      --guardian-set-index, --gsi  guardian set index                   [number]\n      --signatures, --sigs         comma separated list of signatures   [string]\n      --wormscanurl, --wsu         url to wormscan entry for the vaa that\n                                   includes signatures                  [string]\n      --wormscan, --ws             if specified, will query the wormscan entry\n                                   for the vaa to get the signatures   [boolean]\n      --emitter-chain-id, --ec     emitter chain id to be used in the vaa\n                                                                        [number]\n      --emitter-address, --ea      emitter address to be used in the vaa[string]\n      --nonce, --no                nonce to be used in the vaa          [number]\n      --sequence, --seq            sequence number to be used in the vaa[string]\n      --consistency-level, --cl    consistency level to be used in the vaa\n                                                                        [number]\n      --timestamp, --ts            timestamp to be used in the vaa in unix\n                                   seconds                              [number]\n  -p, --payload                    payload in hex format                [string]\n      --guardian-secret, --gs      Guardian's secret key                [string]\n</code></pre> EVM <pre><code>worm evm INSERT_COMMAND\n\nCommands:\n  worm evm address-from-secret &lt;secret&gt;  Compute a 20 byte eth address from a 32\n                                         byte private key\n  worm evm storage-update                Update a storage slot on an EVM fork\n                                         during testing (anvil or hardhat)\n  worm evm chains                        Return all EVM chains\n  worm evm info                          Query info about the on-chain state of\n                                         the contract\n  worm evm hijack                        Override the guardian set of the core\n                                         bridge contract during testing (anvil\n                                         or hardhat)\n  worm evm start-validator               Start a local EVM validator\n\nOptions:\n  --help     Show help                                                 [boolean]\n  --version  Show version number                                       [boolean]\n  --rpc      RPC endpoint                                               [string]\n</code></pre> Generate <pre><code>worm generate INSERT_COMMAND\n\nCommands:\n  worm generate registration                Generate registration VAA\n  worm generate upgrade                     Generate contract upgrade VAA\n  worm generate attestation                 Generate a token attestation VAA\n  worm generate recover-chain-id            Generate a recover chain ID VAA\n  worm generate                             Sets the default delivery provider\n  set-default-delivery-provider             for the Wormhole Relayer contract\n\nOptions:\n      --help             Show help                                     [boolean]\n      --version          Show version number                           [boolean]\n  -g, --guardian-secret  Guardians' secret keys (CSV)        [string] [required]\n</code></pre> Info <pre><code>worm info INSERT_COMMAND\n\nCommands:\n  worm info chain-id &lt;chain&gt;                Print the wormhole chain ID integer\n                                            associated with the specified chain\n                                            name\n  worm info contract &lt;network&gt; &lt;chain&gt;      Print contract address\n  &lt;module&gt;\n  worm info emitter &lt;chain&gt; &lt;address&gt;       Print address in emitter address\n                                            format\n  worm info origin &lt;chain&gt; &lt;address&gt;        Print the origin chain and address\n                                            of the asset that corresponds to the\n                                            given chain and address.\n  worm info registrations &lt;network&gt;         Print chain registrations\n  &lt;chain&gt; &lt;module&gt;\n  worm info rpc &lt;network&gt; &lt;chain&gt;           Print RPC address\n  worm info wrapped &lt;origin-chain&gt;          Print the wrapped address on the\n  &lt;origin-address&gt; &lt;target-chain&gt;           target chain that corresponds with\n                                            the specified origin chain and\n                                            address.\n\nOptions:\n  --help     Show help                                                 [boolean]\n  --version  Show version number                                       [boolean]\n</code></pre> NEAR <pre><code>worm near INSERT_COMMAND\n\nCommands:\n  worm near contract-update &lt;file&gt;  Submit a contract update using our specific\n                                    APIs\n  worm near deploy &lt;file&gt;           Submit a contract update using near APIs\n\nOptions:\n      --help      Show help                                            [boolean]\n      --version   Show version number                                  [boolean]\n  -m, --module    Module to query  [choices: \"Core\", \"NFTBridge\", \"TokenBridge\"]\n  -n, --network   Network   [required] [choices: \"mainnet\", \"testnet\", \"devnet\"]\n      --account   Near deployment account                    [string] [required]\n      --attach    Attach some near                                      [string]\n      --target    Near account to upgrade                               [string]\n      --mnemonic  Near private keys                                     [string]\n      --key       Near private key                                      [string]\n  -r, --rpc       Override default rpc endpoint url                     [string]\n</code></pre> Parse <pre><code>worm parse INSERT_VAA\n\nPositionals:\n  vaa  vaa                                                              [string]\n\nOptions:\n  --help     Show help                                                 [boolean]\n  --version  Show version number                                       [boolean]\n</code></pre> Recover <pre><code>worm recover INSERT_DIGEST INSERT_SIGNATURE\n\nPositionals:\n  digest     digest                                                     [string]\n  signature  signature                                                  [string]\n\nOptions:\n  --help     Show help                                                 [boolean]\n  --version  Show version number                                       [boolean]\n</code></pre> Status <pre><code>worm status INSERT_NETWORK, INSERT_CHAIN, INSERT_TXN_HASH\n\nPositionals:\n  network  Network                     [choices: \n  'mainnet', \n  'testnet', \n  'devnet']\n  chain    Source chain\n             [choices: \n  'unset',\n  'solana',\n  'ethereum',\n  'terra',\n  'bsc',\n  'polygon',\n  'avalanche',\n  'oasis',\n  'algorand',\n  'aurora',\n  'fantom',\n  'karura',\n  'acala',\n  'klaytn',\n  'celo',\n  'near',\n  'moonbeam',\n  'neon',\n  'terra2',\n  'injective',\n  'osmosis',\n  'sui',\n  'aptos',\n  'arbitrum',\n  'optimism',\n  'gnosis',\n  'pythnet',\n  'xpla',\n  'btc',\n  'base',\n  'sei',\n  'rootstock',\n  'scroll',\n  'mantle',\n  'blast',\n  'xlayer',\n  'linea',\n  'berachain',\n  'seievm',\n  'wormchain',\n  'cosmoshub',\n  'evmos',\n  'kujira',\n  'neutron',\n  'celestia',\n  'stargaze',\n  'seda',\n  'dymension',\n  'provenance',\n  'sepolia',\n  'arbitrum_sepolia',\n  'base_sepolia',\n  'optimism_sepolia',\n  'holesky',\n  'polygon_sepolia']\n  tx       Source transaction hash                                      [string]\n\nOptions:\n  --help     Show help                                                 [boolean]\n  --version  Show version number                                       [boolean]\n</code></pre> Submit <pre><code>worm submit INSERT_VAA\n\nPositionals:\n  vaa  vaa                                                              [string]\n\nOptions:\n      --help              Show help                                    [boolean]\n      --version           Show version number                          [boolean]\n  -c, --chain             chain name\n[choices: 'unset',\n  'solana',\n  'ethereum',\n  'terra',\n  'bsc',\n  'polygon',\n  'avalanche',\n  'oasis',\n  'algorand',\n  'aurora',\n  'fantom',\n  'karura',\n  'acala',\n  'klaytn',\n  'celo',\n  'near',\n  'moonbeam',\n  'neon',\n  'terra2',\n  'injective',\n  'osmosis',\n  'sui',\n  'aptos',\n  'arbitrum',\n  'optimism',\n  'gnosis',\n  'pythnet',\n  'xpla',\n  'btc',\n  'base',\n  'sei',\n  'rootstock',\n  'scroll',\n  'mantle',\n  'blast',\n  'xlayer',\n  'linea',\n  'berachain',\n  'seievm',\n  'wormchain',\n  'cosmoshub',\n  'evmos',\n  'kujira',\n  'neutron',\n  'celestia',\n  'stargaze',\n  'seda',\n  'dymension',\n  'provenance',\n  'sepolia',\n  'arbitrum_sepolia',\n  'base_sepolia',\n  'optimism_sepolia',\n  'holesky',\n  'polygon_sepolia']\n  -n, --network           Network\n                            [required] \n  [choices: \n  'mainnet', \n  'testnet', \n  'devnet']\n  -a, --contract-address  Contract to submit VAA to (override config)   [string]\n      --rpc               RPC endpoint                                  [string]\n      --all-chains, --ac  Submit the VAA to all chains except for the origin\n                          chain specified in the payload\n                                                      [boolean] [default: false]\n</code></pre> Sui <pre><code>worm sui INSERT_COMMAND\n\nCommands:\n  worm sui build-coin                    Build wrapped coin and dump bytecode.\n\n                                         Example:\n                                         worm sui build-coin -d 8 -v V__0_1_1 -n\n                                         testnet -r\n                                         \"https://fullnode.testnet.sui.io:443\"\n  worm sui deploy &lt;package-dir&gt;          Deploy a Sui package\n  worm sui init-example-message-app      Initialize example core message app\n  worm sui init-token-bridge             Initialize token bridge contract\n  worm sui init-wormhole                 Initialize wormhole core contract\n  worm sui publish-example-message       Publish message from example app via\n                                         core bridge\n  worm sui setup-devnet                  Setup devnet by deploying and\n                                         initializing core and token bridges and\n                                         submitting chain registrations.\n  worm sui objects &lt;owner&gt;               Get owned objects by owner\n  worm sui package-id &lt;state-object-id&gt;  Get package ID from State object ID\n  worm sui tx &lt;transaction-digest&gt;       Get transaction details\n\nOptions:\n  --help     Show help                                                 [boolean]\n  --version  Show version number                                       [boolean]\n</code></pre> Transfer <pre><code>worm transfer INSERT_SOURCE_CHAIN, INSERT_DESTINATION_CHAIN, INSERT_DESTINATION_ADDRESS, INSERT_AMOUNT, INSERT_NETWORK\n\nOptions:\n      --help        Show help                                          [boolean]\n      --version     Show version number                                [boolean]\n      --src-chain   source chain [required] [choices:\n  'solana',\n  'ethereum',\n  'terra',\n  'bsc',\n  'polygon',\n  'avalanche',\n  'oasis',\n  'algorand',\n  'aurora',\n  'fantom',\n  'karura',\n  'acala',\n  'klaytn',\n  'celo',\n  'near',\n  'moonbeam',\n  'neon',\n  'terra2',\n  'injective',\n  'osmosis',\n  'sui',\n  'aptos',\n  'arbitrum',\n  'optimism',\n  'gnosis',\n  'pythnet',\n  'xpla',\n  'btc',\n  'base',\n  'sei',\n  'rootstock',\n  'scroll',\n  'mantle',\n  'blast',\n  'xlayer',\n  'linea',\n  'berachain',\n  'seievm',\n  'wormchain',\n  'cosmoshub',\n  'evmos',\n  'kujira',\n  'neutron',\n  'celestia',\n  'stargaze',\n  'seda',\n  'dymension',\n  'provenance',\n  'sepolia',\n  'arbitrum_sepolia',\n  'base_sepolia',\n  'optimism_sepolia',\n  'holesky',\n  'polygon_sepolia']\n  --dst-chain   destination chain\n           [required] [choices: \n  'solana',\n  'ethereum',\n  'terra',\n  'bsc',\n  'polygon',\n  'avalanche',\n  'oasis',\n  'algorand',\n  'aurora',\n  'fantom',\n  'karura',\n  'acala',\n  'klaytn',\n  'celo',\n  'near',\n  'moonbeam',\n  'neon',\n  'terra2',\n  'injective',\n  'osmosis',\n  'sui',\n  'aptos',\n  'arbitrum',\n  'optimism',\n  'gnosis',\n  'pythnet',\n  'xpla',\n  'btc',\n  'base',\n  'sei',\n  'rootstock',\n  'scroll',\n  'mantle',\n  'blast',\n  'xlayer',\n  'linea',\n  'berachain',\n  'seievm',\n  'wormchain',\n  'cosmoshub',\n  'evmos',\n  'kujira',\n  'neutron',\n  'celestia',\n  'stargaze',\n  'seda',\n  'dymension',\n  'provenance',\n  'sepolia',\n  'arbitrum_sepolia',\n  'base_sepolia',\n  'optimism_sepolia',\n  'holesky',\n  'polygon_sepolia']\n      --dst-addr    destination address                      [string] [required]\n      --token-addr  token address               [string] [default: native token]\n      --amount      token amount                             [string] [required]\n  -n, --network     Network [required] [choices: \"mainnet\", \"testnet\", \"devnet\"]\n      --rpc         RPC endpoint                                        [string]\n</code></pre> Verify VAA <pre><code>worm verify-vaa INSERT_VAA, INSERT_NETWORK\n\nOptions:\n      --help     Show help                                             [boolean]\n      --version  Show version number                                   [boolean]\n  -v, --vaa      vaa in hex format                           [string] [required]\n  -n, --network  Network    [required] [choices: \"mainnet\", \"testnet\", \"devnet\"]\n</code></pre>"},{"location":"build/toolkit/cli/#examples","title":"Examples","text":""},{"location":"build/toolkit/cli/#vaa-generation","title":"VAA generation","text":"<p>Use <code>generate</code> to create VAAs for testing. For example, use the following command to create an NFT bridge registration VAA:</p> <pre><code>worm generate registration --module NFTBridge \\\n    --chain bsc \\\n    --contract-address 0x706abc4E45D419950511e474C7B9Ed348A4a716c \\\n    --guardian-secret cfb12303a19cde580bb4dd771639b0d26bc68353645571a8cff516ab2ee113a0\n</code></pre> <p>The below example generates a token attestation VAA:</p> <pre><code>worm generate attestation --emitter-chain ethereum \\\n    --emitter-address 11111111111111111111111111111115 \\\n    --chain ethereum \\\n    --token-address 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48 \\\n    --decimals 6 \\\n    --symbol USDC \\\n    --name USDC \\\n    --guardian-secret cfb12303a19cde580bb4dd771639b0d26bc68353645571a8cff516ab2ee113a0\n</code></pre>"},{"location":"build/toolkit/cli/#vaa-parsing","title":"VAA parsing","text":"<p>Use <code>parse</code> to parse a VAA into JSON:</p> <pre><code>worm parse $(worm-fetch-governance 13940208096455381020)\n</code></pre> <p>This example will fetch governance VAA <code>13940208096455381020</code> and print it as JSON: </p> <pre><code># ...signatures elided\ntimestamp: 1651416474,\nnonce: 1570649151,\nemitterChain: 1,\nemitterAddress: '0000000000000000000000000000000000000000000000000000000000000004',\nsequence: 13940208096455381020n,\nconsistencyLevel: 32,\npayload: {\n  module: 'Core',\n  type: 'GuardianSetUpgrade',\n  chain: 0,\n  newGuardianSetIndex: 2,\n  newGuardianSetLength: 19,\n  newGuardianSet: [\n    '58cc3ae5c097b213ce3c81979e1b9f9570746aa5',\n    'ff6cb952589bde862c25ef4392132fb9d4a42157',\n    '114de8460193bdf3a2fcf81f86a09765f4762fd1',\n    '107a0086b32d7a0977926a205131d8731d39cbeb',\n    '8c82b2fd82faed2711d59af0f2499d16e726f6b2',\n    '11b39756c042441be6d8650b69b54ebe715e2343',\n    '54ce5b4d348fb74b958e8966e2ec3dbd4958a7cd',\n    '66b9590e1c41e0b226937bf9217d1d67fd4e91f5',\n    '74a3bf913953d695260d88bc1aa25a4eee363ef0',\n    '000ac0076727b35fbea2dac28fee5ccb0fea768e',\n    'af45ced136b9d9e24903464ae889f5c8a723fc14',\n    'f93124b7c738843cbb89e864c862c38cddcccf95',\n    'd2cc37a4dc036a8d232b48f62cdd4731412f4890',\n    'da798f6896a3331f64b48c12d1d57fd9cbe70811',\n    '71aa1be1d36cafe3867910f99c09e347899c19c3',\n    '8192b6e7387ccd768277c17dab1b7a5027c0b3cf',\n    '178e21ad2e77ae06711549cfbb1f9c7a9d8096e8',\n    '5e1487f35515d02a92753504a8d75471b9f49edb',\n    '6fbebc898f403e4773e95feb15e80c9a99c8348d'\n  ]\n}\n</code></pre>"},{"location":"build/toolkit/cli/#submitting-vaas","title":"Submitting VAAs","text":"<p>Use <code>submit</code> to submit a VAA to a chain. It first parses the VAA and determines the destination chain and module. For example, a contract upgrade contains both the target chain and module, so the only required argument is the network moniker (<code>mainnet</code> or <code>testnet</code>):</p> <pre><code>worm submit $(cat my-nft-registration.txt) --network mainnet\n</code></pre> <p>The script will ask you to specify the target chain for VAAs that don't have a specific target chain (like registrations or Guardian set upgrades). For example, to submit a Guardian set upgrade on all chains, simply run:</p> <pre><code>worm-fetch-governance 13940208096455381020 &gt; guardian-upgrade.txt\nworm submit $(cat guardian-upgrade.txt) --network mainnet --chain oasis\nworm submit $(cat guardian-upgrade.txt) --network mainnet --chain aurora\nworm submit $(cat guardian-upgrade.txt) --network mainnet --chain fantom\nworm submit $(cat guardian-upgrade.txt) --network mainnet --chain karura\nworm submit $(cat guardian-upgrade.txt) --network mainnet --chain acala\nworm submit $(cat guardian-upgrade.txt) --network mainnet --chain klaytn\nworm submit $(cat guardian-upgrade.txt) --network mainnet --chain avalanche\nworm submit $(cat guardian-upgrade.txt) --network mainnet --chain polygon\nworm submit $(cat guardian-upgrade.txt) --network mainnet --chain bsc\nworm submit $(cat guardian-upgrade.txt) --network mainnet --chain solana\nworm submit $(cat guardian-upgrade.txt) --network mainnet --chain terra\nworm submit $(cat guardian-upgrade.txt) --network mainnet --chain ethereum\nworm submit $(cat guardian-upgrade.txt) --network mainnet --chain celo\n</code></pre> <p>The VAA payload type (Guardian set upgrade) specifies that this VAA should go to the core bridge, and the tool directs it there.</p>"},{"location":"build/toolkit/cli/#getting-info","title":"Getting Info","text":"<p>To get info about a contract (only EVM supported at this time), use the following command:</p> <pre><code>worm evm info -c bsc -n mainnet -m TokenBridge\n</code></pre> <p>Running this command generates the following output:</p> <pre><code>{\n  \"address\": \"0xB6F6D86a8f9879A9c87f643768d9efc38c1Da6E7\",\n  \"wormhole\": \"0x98f3c9e6E3fAce36bAAd05FE09d375Ef1464288B\",\n  \"implementation\": \"0x621199f6beB2ba6fbD962E8A52A320EA4F6D4aA3\",\n  \"isInitialized\": true,\n  \"tokenImplementation\": \"0x7f8C5e730121657E17E452c5a1bA3fA1eF96f22a\",\n  \"chainId\": 4,\n  \"finality\": 15,\n  \"evmChainId\": \"56\",\n  \"isFork\": false,\n  \"governanceChainId\": 1,\n  \"governanceContract\": \"0x0000000000000000000000000000000000000000000000000000000000000004\",\n  \"WETH\": \"0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c\",\n  \"registrations\": {\n    \"Solana\": \"0xec7372995d5cc8732397fb0ad35c0121e0eaa90d26f828a534cab54391b3a4f5\",\n    \"Ethereum\": \"0x0000000000000000000000003ee18b2214aff97000d974cf647e7c347e8fa585\",\n    \"Terra\": \"0x0000000000000000000000007cf7b764e38a0a5e967972c1df77d432510564e2\",\n    \"Polygon\": \"0x0000000000000000000000005a58505a96d1dbf8df91cb21b54419fc36e93fde\",\n    \"Avalanche\": \"0x0000000000000000000000000e082f06ff657d94310cb8ce8b0d9a04541d8052\",\n    \"Oasis\": \"0x0000000000000000000000005848c791e09901b40a9ef749f2a6735b418d7564\",\n    \"Algorand\": \"0x67e93fa6c8ac5c819990aa7340c0c16b508abb1178be9b30d024b8ac25193d45\",\n    \"Aurora\": \"0x00000000000000000000000051b5123a7b0f9b2ba265f9c4c8de7d78d52f510f\",\n    \"Fantom\": \"0x0000000000000000000000007c9fc5741288cdfdd83ceb07f3ea7e22618d79d2\",\n    \"Karura\": \"0x000000000000000000000000ae9d7fe007b3327aa64a32824aaac52c42a6e624\",\n    \"Acala\": \"0x000000000000000000000000ae9d7fe007b3327aa64a32824aaac52c42a6e624\",\n    \"Klaytn\": \"0x0000000000000000000000005b08ac39eaed75c0439fc750d9fe7e1f9dd0193f\",\n    \"Celo\": \"0x000000000000000000000000796dff6d74f3e27060b71255fe517bfb23c93eed\",\n    \"Near\": \"0x148410499d3fcda4dcfd68a1ebfcdddda16ab28326448d4aae4d2f0465cdfcb7\",\n    \"Moonbeam\": \"0x000000000000000000000000b1731c586ca89a23809861c6103f0b96b3f57d92\",\n    \"Neon\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    \"Terra2\": \"0xa463ad028fb79679cfc8ce1efba35ac0e77b35080a1abe9bebe83461f176b0a3\",\n    \"Injective\": \"0x00000000000000000000000045dbea4617971d93188eda21530bc6503d153313\",\n    \"Osmosis\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    \"Sui\": \"0xccceeb29348f71bdd22ffef43a2a19c1f5b5e17c5cca5411529120182672ade5\",\n    \"Aptos\": \"0x0000000000000000000000000000000000000000000000000000000000000001\",\n    \"Arbitrum\": \"0x0000000000000000000000000b2402144bb366a632d14b83f244d2e0e21bd39c\",\n    \"Optimism\": \"0x0000000000000000000000001d68124e65fafc907325e3edbf8c4d84499daa8b\",\n    \"Gnosis\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    \"Pythnet\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    \"Xpla\": \"0x8f9cf727175353b17a5f574270e370776123d90fd74956ae4277962b4fdee24c\",\n    \"Btc\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    \"Base\": \"0x0000000000000000000000008d2de8d2f73f1f4cab472ac9a881c9b123c79627\",\n    \"Sei\": \"0x86c5fd957e2db8389553e1728f9c27964b22a8154091ccba54d75f4b10c61f5e\",\n    \"Rootstock\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    \"Scroll\": \"0x00000000000000000000000024850c6f61c438823f01b7a3bf2b89b72174fa9d\",\n    \"Mantle\": \"0x00000000000000000000000024850c6f61c438823f01b7a3bf2b89b72174fa9d\",\n    \"Blast\": \"0x00000000000000000000000024850c6f61c438823f01b7a3bf2b89b72174fa9d\",\n    \"Xlayer\": \"0x0000000000000000000000005537857664b0f9efe38c9f320f75fef23234d904\",\n    \"Linea\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    \"Berachain\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    \"Seievm\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    \"Snaxchain\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    \"Wormchain\": \"0xaeb534c45c3049d380b9d9b966f9895f53abd4301bfaff407fa09dea8ae7a924\",\n    \"Cosmoshub\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    \"Evmos\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    \"Kujira\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    \"Neutron\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    \"Celestia\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    \"Stargaze\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    \"Seda\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    \"Dymension\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    \"Provenance\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    \"Sepolia\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    \"ArbitrumSepolia\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    \"BaseSepolia\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    \"OptimismSepolia\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    \"Holesky\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    \"PolygonSepolia\": \"0x0000000000000000000000000000000000000000000000000000000000000000\"\n  }\n}\n</code></pre>"},{"location":"build/toolkit/cli/#additional-info-examples","title":"Additional Info Examples","text":"<p>You can get the contract address for a module as follows:</p> <pre><code>worm info rpc INSERT_NETWORK INSERT_CHAIN INSERT_MODULE\n</code></pre> <p>To get the contract address for <code>NFTBridge</code> on BSC MainNet, for example, you can provide the following command:</p> <pre><code>worm info contract mainnet bsc NFTBridge\n</code></pre> <p>You can get the RPC address for a chain as follows:</p> <pre><code>worm info rpc INSERT_NETWORK INSERT_CHAIN\n</code></pre> <p>To get the RPC address for BSC MainNet, for example, you can provide the following command: </p> <pre><code>worm info rpc mainnet bsc\n</code></pre>"},{"location":"build/toolkit/tilt/","title":"Tilt","text":"<p>Tilt is part of the official Docker ecosystem. It's a tool that allows developers to configure a Kubernetes environment for development easily.</p> <p>Note</p> <p>Tilt is often referred to as \"DevNet\" in the Wormhole ecosystem, so any information labeled as \"DevNet\" also applies to Tilt.</p> <p>However, in the context of Wormhole, \"Tilt\" refers to the development environment used by the Wormhole Core repository. This environment stands up Docker images for all the tools necessary to build across multiple blockchains, including:</p> <ul> <li>All the Wormhole-supported blockchains and ecosystems</li> <li>A Guardian node</li> <li>Relayers</li> <li>Databases, Redis</li> <li>Utility front ends</li> </ul> <p>The Tilt environment is designed to provide an entire cross-chain development stack right out of the box.</p>"},{"location":"build/toolkit/tilt/#is-tilt-right-for-you","title":"Is Tilt Right for You?","text":"<p>Tilt is a good option for developers who need a local development environment and have access to a machine that can handle running it. It is also an excellent option for developers who want to establish a CI testing suite.</p> ProsCons <ul> <li>Out-of-the-box support for the many components needed to develop across the heterogeneous blockchain spaces</li> <li>Consistent development environment, where contracts deploy deterministically, and everything is already linked up</li> <li>Ability to easily enable or disable components as needed</li> <li>Regularly updated as new components join the Wormhole ecosystem</li> </ul> <ul> <li>Relatively high system requirements, but this can be mitigated by disabling components</li> <li>Most blockchains are \"blank slates\" with no contracts deployed. Thus, if your contracts have any dependencies, you may have to deploy them yourself or alter the default Tilt configuration</li> <li>Spin-up and rebuild times can be slow, which can result in a slow workflow</li> </ul>"},{"location":"build/toolkit/tilt/#tilt-installation","title":"Tilt Installation","text":"<p>Tilt functions best in a UNIX-style environment. To run the Tilt environment, make sure you have Tilt and Go installed.</p>"},{"location":"build/toolkit/tilt/#macos-instructions","title":"MacOS Instructions","text":"<p>You'll need to have <code>homebrew</code> installed on your system. You can install it with:</p> <pre><code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n</code></pre> <p>Install Go:</p> <pre><code>brew install go\n</code></pre> <p>Install Docker:</p> <pre><code>brew install docker\n</code></pre> <p>After installation, go into Docker settings and switch on <code>kubernetes</code>. Also configure Docker to have 4 CPUs and about 16GB of RAM.</p> <p>Install Tilt:</p> <pre><code>brew install tilt\n</code></pre>"},{"location":"build/toolkit/tilt/#linux-instructions","title":"Linux Instructions","text":""},{"location":"build/toolkit/tilt/#install-go","title":"Install Go","text":"<p>You can install Go with the following command:</p> <pre><code>wget https://go.dev/dl/go1.18.1.linux-amd64.tar.gz &amp;&amp;\nrm -r /usr/local/go &amp;&amp; tar -C /usr/local -xzf go1.18.1.linux-amd64.tar.gz\n</code></pre>"},{"location":"build/toolkit/tilt/#install-docker-desktop","title":"Install Docker Desktop","text":"<p>If you're using Linux with a windows manager, it's highly recommended that you install Docker Desktop, since it comes with built-in Kubernetes, and you won't need to download Minikube. It's recommended that you allocate Docker at least 4 CPUs and 16GB RAM. Also, make sure you set up Docker as a non-root user. You can refer to this list of Docker installation methods.</p> <p>If you're using Docker Desktop, you can enable Kubernetes by going into Settings &gt; Kubernetes and checking the checkbox to enable Kubernetes.</p> <p></p>"},{"location":"build/toolkit/tilt/#minikube","title":"Minikube","text":"<p>The alternative to Docker Desktop with Kubernetes is to install minikube. You can configure Minikube as follows:</p> <pre><code>minikube start --driver=docker --kubernetes-version=v1.23.3 --cpus=4 --memory=14G --disk-size=10G --namespace=wormhole\n</code></pre> <p>If you reboot your VM you'll need to run the <code>minikube start</code> command again before you bring up Tilt.</p>"},{"location":"build/toolkit/tilt/#install-tilt","title":"Install Tilt","text":"<p>You can install Tilt with the following command:</p> <pre><code>curl -fsSL https://raw.githubusercontent.com/tilt-dev/tilt/master/scripts/install.sh | bash\n</code></pre>"},{"location":"build/toolkit/tilt/#linux-experimental-instructions","title":"Linux Experimental Instructions","text":"<p>This is an experimental, single-command setup script. </p> <p>Warning</p> <p>This is only recommended if you're running headless Linux and unable to use Docker Desktop, as you can enable Kubernetes from Docker.</p> <p>This experimental single command setup script should install dependencies for you on Linux and configure everything properly. If it doesn't work as expected, refer to the standard Linux installation steps above.</p> <pre><code>curl $URL | sh install_linux.sh &amp;&amp;\ncd wormhole/ &amp;&amp; \n./tilt.sh\n</code></pre> <p>If you've all got prerequisites installed, clone the Wormhole Core Repository and start Tilt.</p> <pre><code>git clone --branch main https://github.com/wormhole-foundation/wormhole.git &amp;&amp;\ncd wormhole &amp;&amp;\ntilt up\n</code></pre>"},{"location":"build/toolkit/tilt/#virtual-machine-instructions","title":"Virtual Machine Instructions","text":"<p>If you're running Tilt in a VM, you'll need to pass in some extra flags to enable Tilt to listen to incoming traffic from external addresses:</p> <pre><code>tilt up --host=0.0.0.0 -- --webHost=0.0.0.0\n</code></pre> <p>You can now access the Tilt UI at <code>vm_external_ip:10350</code>. If the VM's external IP doesn't work, check the firewall and port settings to make sure your VM allows incoming traffic. Be sure to check out the <code>Tiltfile</code>, which has much of the configuration and arguments for the development environment. It's relatively straightforward to enable and disable components. For example, you can enable blockchains by setting them to true at startup. Note the use of the <code>--</code> separator between Tilt command flags and the flags you wish to pass to configure the setup.</p> <pre><code>tilt up -- --algorand --solana\n</code></pre>"},{"location":"build/toolkit/tilt/#using-tilt","title":"Using Tilt","text":"<p>Tilt can be treated as an external environment or DevNet that you can easily spin up and tear down. If you've followed the standard setup, all your resources will be bound to various ports on localhost. To see all the endpoints that are hosted in your Tilt environment, you should check out the Tilt dashboard, located at http://localhost:10350/overview.</p> <p>All the deployed contract addresses can be found under the DevNet section of the chain being used in the Environments pages. Useful information pertaining to funded wallets and private keys can also be found in the <code>DevNet.md</code> file of the docs.</p>"},{"location":"build/toolkit/tilt/#shutting-down-tilt","title":"Shutting Down Tilt","text":"<p>To shut down Tilt, run <code>tilt down</code> with the same network flags provided in the <code>tilt up</code> command.</p> <pre><code>tilt down -- --solana --algorand\n</code></pre>"},{"location":"build/toolkit/tilt/#faq","title":"FAQ","text":""},{"location":"build/toolkit/tilt/#where-are-fantom-celo-polygon-and-other-evm-chains","title":"Where are Fantom, Celo, Polygon, and Other EVM Chains?","text":"<p>The smart contract development environment is effectively the same for all chains that support EVM. For changes in gas costs and transaction times, consider testing contract logic on DevNet and then using TestNet environments to get chain-specific answers.</p>"},{"location":"build/toolkit/tilt/#solana-is-taking-forever","title":"Solana is Taking Forever","text":"<p>Due to Solana's architecture, building the Solana pod often takes 25-40 minutes. Consider increasing the number of CPU cores assigned to DevNet for a faster build.</p>"},{"location":"build/toolkit/tilt/#solana-program-deploy-doesnt-work","title":"Solana Program Deploy Doesn't Work","text":"<p>Kubernetes doesn't currently allow port forwarding for UDP ports (GitHub Issue), which is what Solana uses for <code>solana program deploy</code>. Instead, it is recommended to use Solana Deployer. Not only does this deploy programs over regular RPC (thus bypassing UDP port requirements), but it's also much faster than <code>Solana program deploy.</code></p>"},{"location":"build/toolkit/tilt/#how-do-i-reset-state-for-a-pod","title":"How Do I Reset State For a Pod?","text":"<p>If you want to iterate quickly and don't want to bring Tilt down and back up, you can reset a pod's state by clicking the refresh button next to the pod name in the Tilt UI.</p>"},{"location":"build/toolkit/tilt/#contracts-and-accounts","title":"Contracts and Accounts","text":"<p>The DevNet environment deploys the core layer and Token Bridge to each chain at the same addresses every time. It also provides funds to specific wallets.</p>"},{"location":"build/toolkit/tilt/#default-ports","title":"Default Ports","text":"Service Port Guardian REST 7071 Guardian gRPC Port 7070 Eth0 RPC 8545 Eth1 RPC 8546 Solana RPC 8899"},{"location":"infrastructure/","title":"Infrastructure","text":""},{"location":"infrastructure/#get-started","title":"Get Started","text":"<p>Follow the guides in this section to learn how to run off-chain infrastructure services, such as running a spy or a customized relayer.</p> <ul> <li> <p> Relayers</p> <p>Learn how to develop your own custom off-chain relaying service, giving you greater control and flexibility than using Wormhole-deployed relayers.</p> <p> Run a relayer</p> </li> </ul> <ul> <li> <p> Spy</p> <p>Learn how to run a Spy locally to listen for and forward messages (Verifiable Action Approvals, or VAAs) published on the Wormhole network.</p> <p> Run a Spy</p> </li> </ul>"},{"location":"infrastructure/relayers/","title":"Relayers","text":""},{"location":"infrastructure/relayers/#get-started","title":"Get Started","text":"<ul> <li> <p> Run a Custom Relayer</p> <p>This section guides you through developing your own custom off-chain relaying service, giving you greater control and flexibility than using Wormhole-deployed relayers.</p> <p></p> <p>Benefits of running your own relayer:</p> <ul> <li>You can add logic to customize the delivery of messages</li> <li>You can perform off-chain computations resulting in optimized gas costs</li> </ul> <p></p> <p>Requirements for running your own relayer:</p> <ul> <li>You are responsible for developing and hosting your relayer</li> <li>You are responsible for paying target chain fees</li> <li>You are responsible for the liveness of your relayer</li> </ul> <p></p> <p> Get started now</p> </li> </ul>"},{"location":"infrastructure/relayers/#additional-resources","title":"Additional Resources","text":"<ul> <li> <p> What is a Relayer?</p> <p>Learn about what a relayer is, what role it plays in the delivery of cross-chain messages, and the different types of relayers in the Wormhole ecosystem.</p> <p> Learn more about relayers</p> </li> <li> <p> Simplify the Development Process</p> <p>Use the Wormhole Relayer Engine package as a foundational toolkit to develop your own customized off-chain relaying service, enabling tailored message handling.</p> <p> Check out the Relayer Engine source code</p> </li> </ul>"},{"location":"infrastructure/relayers/run-relayer/","title":"Run a Custom Relayer","text":""},{"location":"infrastructure/relayers/run-relayer/#introduction","title":"Introduction","text":"<p>Relayers play a crucial role in cross-chain communication, ensuring that messages are transferred seamlessly between different blockchains. While Wormhole relayers provide a reliable way to handle these transfers, they might not always meet every application's unique requirements.</p> <p>Custom relayers address these limitations by offering tailored solutions that cater to the distinct needs of your application. Developing a custom relayer gives you complete control over message processing, delivery mechanisms, and integration with existing systems. This customization allows for optimized performance and the ability to implement specific features that Wormhole-deployed relayers might not support.</p> <p>A custom relayer might be as simple as an in-browser process that polls the API for the availability of a VAA after submitting a transaction and delivers it to the target chain. It might also be implemented with a Spy coupled with some daemon listening for VAAs from a relevant chain ID and emitter, then taking action when one is observed.</p> <p>This guide teaches you how to set up and configure a custom relayer for efficient message handling. You'll start by understanding how to uniquely identify a VAA using its emitter address, sequence ID, and chain ID. Then, you'll explore the Relayer Engine, a package that provides a framework for building custom relayers, and learn how to fetch and handle VAAs using the Wormhole SDK.</p>"},{"location":"infrastructure/relayers/run-relayer/#get-started-with-a-custom-relayer","title":"Get Started with a Custom Relayer","text":"<p>To start building a custom relayer, it's essential to grasp the components you'll be managing as part of your relaying service. Your relayer must be capable of retrieving and delivering VAAs.</p> The off-chain components outlined in blue must be implemented."},{"location":"infrastructure/relayers/run-relayer/#how-to-uniquely-identify-a-vaa","title":"How to Uniquely Identify a VAA","text":"<p>Regardless of the environment, to get the VAA you intend to relay, you need:</p> <ul> <li>The <code>emitter</code> address</li> <li>The <code>sequence</code> ID of the message you're interested in</li> <li>The <code>chainId</code> for the chain that emitted the message</li> </ul> <p>With these three components, you're able to uniquely identify a VAA and process it.</p>"},{"location":"infrastructure/relayers/run-relayer/#use-the-relayer-engine","title":"Use the Relayer Engine","text":"<p>The <code>relayer-engine</code> is a package that provides the structure and a starting point for a custom relayer.</p> <p>With the Relayer Engine, a developer can write specific logic for filtering to receive only the messages they care about.</p> <p>Once a Wormhole message is received, the developer may apply additional logic to parse custom payloads or submit the Verifiable Action Approvals (VAA) to one or many destination chains.</p> <p>To use the Relayer Engine, a developer may specify how to relay Wormhole messages for their app using an idiomatic Express/Koa middleware-inspired API, then let the library handle all the details.</p>"},{"location":"infrastructure/relayers/run-relayer/#install-the-relayer-engine","title":"Install the Relayer Engine","text":"<p>First, install the <code>relayer-engine</code> package with your favorite package manager:</p> <pre><code>npm i @wormhole-foundation/relayer-engine\n</code></pre>"},{"location":"infrastructure/relayers/run-relayer/#get-started-with-the-relayer-engine","title":"Get Started with the Relayer Engine","text":"<p>In the following example, you'll:</p> <ol> <li>Set up a <code>StandardRelayerApp</code>, passing configuration options for our relayer</li> <li>Add a filter to capture only those messages our app cares about, with a callback to do something with the VAA once received</li> <li>Start the relayer app</li> </ol> <pre><code>import {\n  Environment,\n  StandardRelayerApp,\n  StandardRelayerContext,\n} from '@wormhole-foundation/relayer-engine';\nimport { CHAIN_ID_SOLANA } from '@certusone/wormhole-sdk';\n\n(async function main() {\n  // Initialize relayer engine app and pass relevant config options\n  const app = new StandardRelayerApp&lt;StandardRelayerContext&gt;(\n    Environment.TESTNET,\n    // Other app specific config options can be set here for things\n    // like retries, logger, or redis connection settings\n    {\n      name: 'ExampleRelayer',\n    }\n  );\n\n  // Add a filter with a callback that will be invoked\n  // on finding a VAA that matches the filter\n  app.chain(CHAIN_ID_SOLANA).address(\n    // Emitter address on Solana\n    'DZnkkTmCiFWfYTfT41X3Rd1kDgozqzxWaHqsw6W4x2oe',\n    // Callback function to invoke on new message\n    async (ctx, next) =&gt; {\n      const vaa = ctx.vaa;\n      const hash = ctx.sourceTxHash;\n      console.log(\n        `Got a VAA with sequence: ${vaa.sequence} from with txhash: ${hash}`\n      );\n    }\n  );\n\n  // Add and configure any other middleware here\n\n  // Start app. Blocks until unrecoverable error or process is stopped\n  await app.listen();\n})();\n</code></pre> <p>The first meaningful line instantiates the <code>StandardRelayerApp</code>, a subclass of the <code>RelayerApp</code> with standard defaults.</p> <pre><code>export class StandardRelayerApp&lt;\n  ContextT extends StandardRelayerContext = StandardRelayerContext,\n&gt; extends RelayerApp&lt;ContextT&gt; {\n  // ...\n  constructor(env: Environment, opts: StandardRelayerAppOpts) {\n</code></pre> <p>The only field you pass in the <code>StandardRelayerAppOpts</code> is the name to help identify log messages and reserve a namespace in Redis.</p> <code>StandardRelayerAppOpts</code> <p>Other options can be passed to the <code>StandardRelayerApp</code> constructor to configure the app further.</p> <pre><code>wormholeRpcs?: string[];  // List of URLs from which to query missed VAAs\nconcurrency?: number;     // How many concurrent requests to make for workflows\nspyEndpoint?: string;     // The hostname and port of our Spy\nlogger?: Logger;          // A custom Logger\nprivateKeys?: Partial&lt;{ [k in ChainId]: any[]; }&gt;; // A set of keys that can be used to sign and send transactions\ntokensByChain?: TokensByChain;    // The token list we care about\nworkflows?: { retries: number; }; // How many times to retry a given workflow\nproviders?: ProvidersOpts;        // Configuration for the default providers\nfetchSourceTxhash?: boolean;      // whether or not to get the original transaction ID/hash\n// Redis config\nredisClusterEndpoints?: ClusterNode[];\nredisCluster?: ClusterOptions;\nredis?: RedisOptions;\n</code></pre> <p>The next meaningful line in the example adds a filter middleware component. This middleware will cause the relayer app to request a subscription from the Spy for any VAAs that match the criteria and invoke the callback with the VAA.</p> <p>If you'd like your program to subscribe to <code>multiple</code> chains and addresses, you can call the same method several times or use the <code>multiple</code> helper.</p> <pre><code>app.multiple(\n  {\n    [CHAIN_ID_SOLANA]: 'DZnkkTmCiFWfYTfT41X3Rd1kDgozqzxWaHqsw6W4x2oe',\n    [CHAIN_ID_ETH]: ['0xabc1230000000...', '0xdef456000...'],\n  },\n  myCallback\n);\n</code></pre> <p>The last line in the simple example runs <code>await app.listen()</code>, which starts the relayer engine. Once started, the Relayer Engine issues subscription requests to the Spy and begins any other workflows (e.g., tracking missed VAAs).</p> <p>This will run until the process is killed or encounters an unrecoverable error. To gracefully shut down the relayer, call <code>app.stop()</code>.</p> <p>The source code for this example is available in the <code>relayer-engine</code> repository.</p>"},{"location":"infrastructure/relayers/run-relayer/#start-background-processes","title":"Start Background Processes","text":"<p>Note</p> <p>These processes must be running for the relayer app below to work.</p> <p>Next, you must start a Spy to listen for available VAAs published on the Guardian network. You also need a persistence layer. This example uses Redis.</p> <p>More details about the Spy are available in the Spy Documentation.</p>"},{"location":"infrastructure/relayers/run-relayer/#wormhole-network-spy","title":"Wormhole Network Spy","text":"<p>For our relayer app to receive messages, a local Spy must be running that watches the Guardian network. Our relayer app will receive updates from this Spy.</p> MainNet SpyTestNet Spy <pre><code>docker run --platform=linux/amd64 \\\n-p 7073:7073 \\\n--entrypoint /guardiand ghcr.io/wormhole-foundation/guardiand:latest \\\nspy \\\n--nodeKey /node.key \\\n--spyRPC \"[::]:7073\" \\\n--env mainnet\n</code></pre> <pre><code>docker run --platform=linux/amd64 \\\n-p 7073:7073 \\\n--entrypoint /guardiand ghcr.io/wormhole-foundation/guardiand:latest \\\nspy \\\n--nodeKey /node.key \\\n--spyRPC \"[::]:7073\" \\\n--env testnet   \n</code></pre>"},{"location":"infrastructure/relayers/run-relayer/#redis-persistence","title":"Redis Persistence","text":"<p>Note</p> <p>While you're using Redis here, the persistence layer can be swapped out for some other database by implementing the appropriate interface.</p> <p>A Redis instance must also be available to persist job data for fetching VAAs from the Spy.</p> <pre><code>docker run --rm -p 6379:6379 --name redis-docker -d redis\n</code></pre>"},{"location":"infrastructure/relayers/run-relayer/#use-the-wormhole-sdk","title":"Use the Wormhole SDK","text":"<p>You can also use the Wormhole SDK to poll the Guardian RPC until a signed VAA is ready using the SDK's <code>getSignedVAAWithRetry</code> function.</p> <pre><code>import {\n  getSignedVAAWithRetry,\n  parseVAA,\n  CHAIN_ID_SOLANA,\n  CHAIN_ID_ETH,\n} from '@certusone/wormhole-sdk';\n\nconst RPC_HOSTS = [\n  /* ...*/\n];\n\nasync function getVAA(\n  emitter: string,\n  sequence: string,\n  chainId: number\n): Promise&lt;Uint8Array&gt; {\n  // Wait for the VAA to be ready and fetch it from the guardian network\n  const { vaaBytes } = await getSignedVAAWithRetry(\n    RPC_HOSTS,\n    chainId,\n    emitter,\n    sequence\n  );\n  return vaaBytes;\n}\n\nconst vaaBytes = await getVAA('INSERT_EMITTER_ADDRESS', 1, CHAIN_ID_ETH);\n</code></pre> <p>Once you have the VAA, the delivery method is chain-dependent.</p> EVMSolana <p>On EVM chains, the bytes for the VAA can be passed directly as an argument to an ABI method.</p> <pre><code>// Set up eth wallet\nconst ethProvider = new ethers.providers.StaticJsonRpcProvider(\n  'INSERT_RPC_URL'\n);\nconst ethWallet = new ethers.Wallet('INSERT_PRIVATE_KEY', ethProvider);\n\n// Create client to interact with our target app\nconst ethHelloWorld = HelloWorld__factory.connect(\n  'INSERT_CONTRACT_ADDRESS',\n  ethWallet\n);\n\n// Invoke the receiveMessage on the ETH contract and wait for confirmation\nconst receipt = await ethHelloWorld\n  .receiveMessage(vaaBytes)\n  .then((tx: ethers.ContractTransaction) =&gt; tx.wait())\n  .catch((msg: any) =&gt; {\n    console.error(msg);\n    return null;\n  });\n</code></pre> <p>On Solana, the VAA is first posted to the core bridge, and then a custom transaction is prepared to process and validate the VAA. </p> <pre><code>import { CONTRACTS } from '@certusone/wormhole-sdk';\n\nexport const WORMHOLE_CONTRACTS = CONTRACTS[NETWORK];\nexport const CORE_BRIDGE_PID = new PublicKey(WORMHOLE_CONTRACTS.solana.core);\n\n// First, post the VAA to the core bridge\nawait postVaaSolana(\n  connection,\n  wallet.signTransaction,\n  CORE_BRIDGE_PID,\n  wallet.key(),\n  vaaBytes\n);\n\nconst program = createHelloWorldProgramInterface(connection, programId);\nconst parsed = isBytes(wormholeMessage)\n  ? parseVaa(wormholeMessage)\n  : wormholeMessage;\n\nconst ix = program.methods\n  .receiveMessage([...parsed.hash])\n  .accounts({\n    payer: new PublicKey(payer),\n    config: deriveConfigKey(programId),\n    wormholeProgram: new PublicKey(wormholeProgramId),\n    posted: derivePostedVaaKey(wormholeProgramId, parsed.hash),\n    foreignEmitter: deriveForeignEmitterKey(programId, parsed.emitterChain),\n    received: deriveReceivedKey(\n      programId,\n      parsed.emitterChain,\n      parsed.sequence\n    ),\n  })\n  .instruction();\n\nconst transaction = new Transaction().add(ix);\nconst { blockhash } = await connection.getLatestBlockhash(commitment);\ntransaction.recentBlockhash = blockhash;\ntransaction.feePayer = new PublicKey(payerAddress);\n\nconst signed = await wallet.signTxn(transaction);\nconst txid = await connection.sendRawTransaction(signed);\n\nawait connection.confirmTransaction(txid);\n</code></pre>"},{"location":"infrastructure/spy/","title":"Spy","text":""},{"location":"infrastructure/spy/#get-started","title":"Get Started","text":"<ul> <li> <p> Run a Spy</p> <p>The content in this section shows you how you can run your own infrastructure and spin up a Spy daemon locally to subscribe to a stream of messages, also known as Verifiable Action Approvals (VAAs).</p> <p> Get started now</p> </li> </ul>"},{"location":"infrastructure/spy/#additional-resources","title":"Additional Resources","text":"<ul> <li> <p> What is a Spy?</p> <p>Learn about what a Spy is and what role it plays in the delivery of cross-chain messages.</p> <p> Learn more about Spies</p> </li> <li> <p> Interact with a Spy</p> <p>Use the Wormhole Spy SDK to subscribe to the stream of signed messages.</p> <p> Use the Wormhole Spy SDK</p> </li> <li> <p> Alternative Implementations</p> <p>Check out Beacon, an alternative highly available version of the Wormhole Spy.</p> <p> Use Pyth Beacon</p> </li> </ul>"},{"location":"infrastructure/spy/run-spy/","title":"Run a Spy","text":""},{"location":"infrastructure/spy/run-spy/#introduction","title":"Introduction","text":"<p>The Spy is a lightweight component in the Wormhole infrastructure designed to listen for and forward messages (Verifiable Action Approvals (VAAs)) published on the Wormhole network. Running a Spy locally allows developers to subscribe to a filtered stream of these messages, facilitating the development of custom relayers or other integrations with Wormhole.</p> <p>For a more comprehensive understanding of the Spy and its role within the Wormhole ecosystem, refer to the Spy Documentation.</p>"},{"location":"infrastructure/spy/run-spy/#how-to-start-a-spy","title":"How to Start a Spy","text":"<p>To start a Spy locally, run the following Docker command:</p> MainNetTestNet <pre><code>docker run --platform=linux/amd64 \\\n    -p 7073:7073 \\\n    --entrypoint /guardiand ghcr.io/wormhole-foundation/guardiand:latest \\\n    spy \\\n    --nodeKey /node.key \\\n    --spyRPC \"[::]:7073\" \\\n    --env mainnet\n</code></pre> <pre><code>docker run --platform=linux/amd64 \\\n    -p 7073:7073 \\\n    --entrypoint /guardiand ghcr.io/wormhole-foundation/guardiand:latest \\\n    spy \\\n    --nodeKey /node.key \\\n    --spyRPC \"[::]:7073\" \\\n    --env testnet\n</code></pre> <p>Optionally, add the following flags to skip any VAAs with invalid signatures:</p> MainNetTestNet <pre><code>--ethRPC https://eth.drpc.org\n--ethContract 0x98f3c9e6E3fAce36bAAd05FE09d375Ef1464288B\n</code></pre> <pre><code>--ethRPC https://sepolia.drpc.org/\n--ethContract 0x4a8bc80Ed5a4067f1CCf107057b8270E0cC11A78    \n</code></pre>"},{"location":"infrastructure/spy/run-spy/#subscribe-to-filtered-vaas","title":"Subscribe to Filtered VAAs","text":"<p>Once running, a gRPC client (i.e., your program) can subscribe to a filtered stream of messages (VAAs).</p> <p>Use this proto-spec file to generate a client for the gRPC service.</p> <p>Note</p> <p>If using JavaScript/TypeScript, the Spydk makes setting up a client easier.</p>"},{"location":"infrastructure/spy/run-spy/#data-persistence","title":"Data Persistence","text":"<p>The Spy does not have a built-in persistence layer, so it is typically paired with something like Redis or an SQL database to record relevant messages.</p> <p>The persistence layer needs to implement the appropriate interface. For example, you can check out the Redis interface used by the Relayer Engine, a package that implements a client and persistence layer for messages received from a Spy subscription.</p>"},{"location":"learn/","title":"Learn","text":""},{"location":"learn/#get-started","title":"Get Started","text":"<p>This section offers informational content on Wormhole, covering its architecture, messaging protocols, and the fundamentals of how it enables cross-chain communication and asset transfers.</p> <ul> <li> <p> Fundamentals</p> <p>Start with the basics to get a solid understanding of what Wormhole has to offer and how it works to provide secure cross-chain communication.</p> <p> Get started</p> </li> <li> <p> Infrastructure Components</p> <p>Explore Wormhole's core infrastructure components and the unique roles each plays in enabling seamless message delivery across chains.</p> <p> Understand Wormhole's infrastructure</p> </li> <li> <p> Messaging</p> <p>Discover Wormhole's messaging protocols and how each facilitates secure and efficient communication across blockchains.</p> <p> Explore messaging protocols</p> </li> </ul>"},{"location":"learn/fundamentals/","title":"Wormhole Fundamentals","text":""},{"location":"learn/fundamentals/#get-started","title":"Get Started","text":"<p>This section covers the fundamentals of Wormhole, including what Wormhole is, a look at its architecture, and an overview of the robust security measures that safeguard cross-chain interactions.</p> <ul> <li> <p> Introduction to Wormhole</p> <p>New to Wormhole? Check out the introduction to Wormhole to learn what Wormhole is, the problems it solves, and how it works to solve them.</p> <p> Take a first glance at Wormhole</p> </li> <li> <p> Security</p> <p>Wormhole safeguards cross-chain communication with a strong focus on security, using proven technology and decentralized validation via Guardians.</p> <p> Review security measures</p> </li> <li> <p> Architecture Overview</p> <p>Explore Wormhole's architecture to understand how its core components seamlessly work together to deliver cross-chain messages securely.</p> <p> Discover how Wormhole works</p> </li> </ul>"},{"location":"learn/fundamentals/#reference","title":"Reference","text":"<ul> <li> <p> Glossary</p> <p>Check out key terms and their definitions within the Wormhole ecosystem to better understand the concepts and language used throughout the platform.</p> <p> Get to know the terms</p> </li> </ul>"},{"location":"learn/fundamentals/architecture/","title":"Architecture Overview","text":""},{"location":"learn/fundamentals/architecture/#architecture","title":"Architecture","text":"<p>Wormhole has several noteworthy components. Before discussing each component in depth, this page will provide an overview of how the major pieces fit together.</p> <p></p>"},{"location":"learn/fundamentals/architecture/#on-chain-components","title":"On-Chain Components","text":"<ul> <li>Emitter - a contract that calls the publish message method on the Core Contract. The Core Contract will write an event to the transaction logs with details about the emitter and sequence number to identify the message. This may be your xDapp or an existing ecosystem protocol</li> <li>Wormhole Core Contract - primary contract, this is the contract which the Guardians observe and which fundamentally allows for cross-chain communication</li> <li>Transaction logs - blockchain-specific logs that allow the Guardians to observe messages emitted by the Core Contract</li> </ul>"},{"location":"learn/fundamentals/architecture/#off-chain-components","title":"Off-Chain Components","text":"<ul> <li>Guardian Network - validators that exist in their own P2P network. Guardians observe and validate the messages emitted by the Core Contract on each supported chain to produce VAAs (signed messages)</li> <li>Guardian - one of 19 validators in the Guardian Network that contributes to the VAA multisig</li> <li>Spy - a daemon that subscribes to messages published within the Guardian Network. A Spy can observe and forward network traffic, which helps scale up VAA distribution</li> <li>API - a REST server to retrieve details for a VAA or the Guardian Network</li> <li>VAAs - Verifiable Action Approvals (VAAs) are the signed attestation of an observed message from the Wormhole Core Contract</li> <li>Relayer - any off-chain process that relays a VAA to the target chain<ul> <li>Wormhole relayers - a decentralized relayer network that delivers messages that are requested on-chain via the Wormhole relayer contract</li> <li>Custom relayers - relayers that only handle VAAs for a specific protocol or cross-chain application. They can execute custom logic off-chain, reducing gas costs and increasing cross-chain compatibility. Currently, cross-chain application developers are responsible for developing and hosting custom relayers</li> </ul> </li> </ul>"},{"location":"learn/fundamentals/glossary/","title":"Glossary","text":"<p>This glossary is an index of technical term definitions for words commonly used in Wormhole documentation.</p>"},{"location":"learn/fundamentals/glossary/#chain-id","title":"Chain ID","text":"<p>Wormhole assigns a unique <code>u16</code> integer chain ID to each supported blockchain. These chain IDs are specific to Wormhole and may differ from those used by blockchains to identify their networks.</p> <p>You can find each chain ID documented on the Wormhole Chain IDs page.</p>"},{"location":"learn/fundamentals/glossary/#consistency-level","title":"Consistency Level","text":"<p>The level of finality (consistency) a transaction should meet before being signed by a Guardian. See the Consistency Levels reference page for details.</p>"},{"location":"learn/fundamentals/glossary/#delivery-provider","title":"Delivery Provider","text":"<p>A Delivery Provider monitors for Wormhole Relayer delivery requests and delivers those requests to the intended target chain as instructed.</p>"},{"location":"learn/fundamentals/glossary/#emitter","title":"Emitter","text":"<p>The emitter contract makes the call to the Wormhole Core Contract. The published message includes the emitter contract address and, a sequence number for the message is tracked to provide a unique ID.</p>"},{"location":"learn/fundamentals/glossary/#finality","title":"Finality","text":"<p>The finality of a transaction depends on its blockchain properties. Once a transaction is considered final, you can assume the resulting state changes it caused won't be reverted.</p>"},{"location":"learn/fundamentals/glossary/#gateway","title":"Gateway","text":"<p>The Gateway, previously referred to as Wormchain, is the Cosmos-SDK chain Wormhole uses to facilitate communication with the Cosmos ecosystem.</p>"},{"location":"learn/fundamentals/glossary/#guardian","title":"Guardian","text":"<p>A Guardian is one of the 19 parties running validators in the Guardian Network contributing to the VAA multisig.</p>"},{"location":"learn/fundamentals/glossary/#guardian-network","title":"Guardian Network","text":"<p>Validators in their own P2P network who serve as Wormhole's oracle by observing activity on-chain and generating signed messages attesting to that activity.</p>"},{"location":"learn/fundamentals/glossary/#guardian-set","title":"Guardian Set","text":"<p>The Guardian Set is a set of guardians responsible for validating a message emitted from the core contracts. Occasionally, the members of the set will change through a governance action.</p>"},{"location":"learn/fundamentals/glossary/#heartbeat","title":"Heartbeat","text":"<p>Each Guardian will issue a <code>heartbeat</code> on a 15-second interval to signal that it is still running and convey details about its identity, uptime, version, and the status of the connected nodes.</p> <p>You can view the heartbeats on the Wormhole dashboard.</p>"},{"location":"learn/fundamentals/glossary/#observation","title":"Observation","text":"<p>An Observation is a data structure describing a message emitted by the Core Contract and noticed by the Guardian node.</p>"},{"location":"learn/fundamentals/glossary/#relayer","title":"Relayer","text":"<p>A relayer is any process that delivers VAAs to a destination.</p>"},{"location":"learn/fundamentals/glossary/#sequence","title":"Sequence","text":"<p>A nonce, strictly increasing, which is tracked by the Wormhole Core Contract and unique to the emitter chain and address.</p>"},{"location":"learn/fundamentals/glossary/#spy","title":"Spy","text":"<p>A Spy is a daemon that eavesdrops on the messages passed between Guardians, typically to track VAAs as they get signed.</p>"},{"location":"learn/fundamentals/glossary/#vaa","title":"VAA","text":"<p>Verifiable Action Approvals (VAAs) are the base data structure in the Wormhole ecosystem. They contain the messages emitted by xDapps along with information such as what contract emitted the message.</p>"},{"location":"learn/fundamentals/glossary/#validator","title":"Validator","text":"<p>A daemon configured to monitor a blockchain node and observe messages emitted by the Wormhole contracts.</p>"},{"location":"learn/fundamentals/glossary/#xchain","title":"xChain","text":"<p>A term that refers to the full range of cross-blockchain interoperability.</p>"},{"location":"learn/fundamentals/glossary/#xassets","title":"xAssets","text":"<p>A chain-and-path agnostic token on a layer outside the blockchain ecosystem that can conduct transactions on any blockchain.</p>"},{"location":"learn/fundamentals/glossary/#xdapp","title":"xDapp","text":"<p>A decentralized application that enables users to create and/or use xData.</p>"},{"location":"learn/fundamentals/glossary/#xdata","title":"xData","text":"<p>Data that exists in a layer outside of Layer 1 blockchains, which is accessible by all chains.</p>"},{"location":"learn/fundamentals/introduction/","title":"Introduction to Wormhole","text":"<p>In the rapidly evolving landscape of blockchain technology, interoperability between different blockchains remains a significant challenge. Developers often face hurdles in creating applications that can seamlessly operate across multiple blockchains, limiting innovation and the potential of decentralized ecosystems.</p> <p>Wormhole addresses this problem by providing a generic message-passing protocol that enables secure and efficient communication between blockchains. By allowing data and asset transfers across various blockchain networks, Wormhole breaks down the walls that traditionally separate these ecosystems.</p> <p>Wormhole is distinguished by its focus on robust security, scalability, and transparency. The protocol is supported by a decentralized network of validators that ensure the integrity of every cross-chain transaction. This, combined with Wormhole\u2019s proven performance in real-world applications, gives developers a dependable platform to create and scale multichain applications confidently.</p> <p></p> <p>Note</p> <p>The above is an oversimplified illustration of the protocol; details about the architecture and components are available on the architecture page.</p> <p>Wormhole allows developers to leverage the strengths of multiple blockchain ecosystems without being confined to one. This means applications can benefit from the unique features of various networks\u2014such as Solana's high throughput, Ethereum's security, and Cosmos's interoperability while maintaining a unified, efficient user experience.</p> <p>This page introduces the key concepts and components necessary to understand how Wormhole enables fast, secure, and scalable cross-chain communication.</p>"},{"location":"learn/fundamentals/introduction/#what-problems-does-wormhole-solve","title":"What Problems Does Wormhole Solve?","text":"<p>Interoperability is a critical challenge in the rapidly evolving blockchain landscape. Individual blockchains are often isolated, limiting the potential for integrated applications operating across multiple ecosystems. Wormhole solves this problem by enabling seamless communication between blockchains, allowing developers to create multichain applications that can leverage the unique features of each network.</p> <p>Critical problems Wormhole addresses include:</p> <ul> <li>Blockchain isolation - Wormhole connects disparate blockchains, enabling the transfer of assets, data, and governance actions across networks</li> <li>Cross-chain complexity - by abstracting the complexities of cross-chain communication, Wormhole makes it easier for developers to build and deploy cross-chain applications</li> <li>Security and decentralization - Wormhole prioritizes security through a decentralized Guardian network that validates and signs messages, ensuring the integrity of cross-chain interactions</li> </ul>"},{"location":"learn/fundamentals/introduction/#what-does-wormhole-offer","title":"What Does Wormhole Offer?","text":"<p>Wormhole provides a suite of tools and protocols that support a wide range of use cases:</p> <ul> <li>Cross-chain messaging - securely transfer arbitrary data between blockchains, enabling the development of cross-chain decentralized applications (xDapps)</li> <li>Asset transfers - facilitate the movement of tokens and NFTs across supported chains with ease, powered by protocols built on Wormhole like Portal</li> <li>Developer tools - leverage Wormhole\u2019s SDKs, APIs, Wormhole Scan, and documentation to build and deploy cross-chain applications quickly and efficiently</li> </ul>"},{"location":"learn/fundamentals/introduction/#what-isnt-wormhole","title":"What Isn't Wormhole?","text":"<ul> <li>Wormhole is not a blockchain - it acts as a communication layer that connects different blockchains, enabling them to interact without being a blockchain itself</li> <li>Wormhole is not a token bridge - while it facilitates token transfers, Wormhole also supports a wide range of cross-chain applications, making it much more versatile than a typical bridge</li> </ul>"},{"location":"learn/fundamentals/introduction/#use-cases-of-wormhole","title":"Use Cases of Wormhole","text":"<p>Consider the following examples of potential applications enabled by Wormhole:</p> <ul> <li>Cross-chain exchange - using Wormhole Connect, developers can build exchanges that allow deposits from any Wormhole-connected chain, significantly increasing liquidity access</li> <li>Cross-chain governance - NFT collections on different networks can use Wormhole to communicate votes cast on their respective chains to a designated \"voting\" chain for combined proposals</li> <li>Cross-chain game - games can be developed on a performant network like Solana, with rewards issued as NFTs on another network, such as Ethereum</li> </ul>"},{"location":"learn/fundamentals/introduction/#explore","title":"Explore","text":"<p>Discover more about the Wormhole ecosystem, components, and protocols:</p> <ul> <li>Architecture - explore the components of the protocol</li> <li>Protocol Specifications - learn about the protocols built on top of Wormhole</li> </ul>"},{"location":"learn/fundamentals/introduction/#demos","title":"Demos","text":"<p>Demos offer more realistic implementations than tutorials:</p> <ul> <li>Wormhole Scaffolding - quickly set up a project with the Scaffolding repository</li> <li>xDapp Book Projects - run and learn from example programs</li> </ul> <p>More demos are available in the demos page.</p> <p>Note</p> <p>Wormhole Integration Complete?</p> <p>Let us know so we can list your project in our ecosystem directory and introduce you to our global, multichain community!</p> <p>Reach out now!</p>"},{"location":"learn/fundamentals/introduction/#supported-blockchains","title":"Supported Blockchains","text":"<p>Wormhole supports a growing number of blockchains.</p> <p>Acala </p> <p>Algorand </p> <p>Aptos </p> <p>Arbitrum </p> <p>Avalanche </p> <p>Base </p> <p>Berachain </p> <p>Blast </p> <p>BNB Smart Chain </p> <p>Celestia </p> <p>Celo </p> <p>Cosmoshub </p> <p>Dymension </p> <p>Ethereum </p> <p>Evmos </p> <p>Fantom </p> <p>Gnosis </p> <p>Injective </p> <p>Karura </p> <p>Klaytn </p> <p>Kujira </p> <p>Linea </p> <p>Mantle </p> <p>Moonbeam </p> <p>NEAR </p> <p>Neon </p> <p>Neutron </p> <p>Oasis </p> <p>Optimism </p> <p>Osmosis </p> <p>Polygon </p> <p>Provenance </p> <p>Pythnet </p> <p>Rootstock </p> <p>Scroll </p> <p>Seda </p> <p>Sei </p> <p>Seievm </p> <p>Solana </p> <p>Stargaze </p> <p>Sui </p> <p>Terra </p> <p>Terra2 </p> <p>Xlayer </p> <p>Xpla </p>"},{"location":"learn/fundamentals/security/","title":"Security","text":""},{"location":"learn/fundamentals/security/#core-security-assumptions","title":"Core Security Assumptions","text":"<p>At its core, Wormhole is secured by a network of Guardian nodes that validate and sign messages. If a super majority (e.g., 13 out of 19) of Guardians sign the same message, it can be considered valid. A smart contract on the target chain will verify the signatures and format of the message before approving any transaction.</p> <ul> <li>Wormhole's core security primitive is its signed messages (signed VAAs)</li> <li>The Guardian network is currently secured by a collection of 19 of the world's top validator companies</li> <li>Guardians produce signed state attestations (signed VAAs) when requested by a Core Contract integrator</li> <li>Every Guardian runs full nodes (rather than light nodes) of every blockchain in the Wormhole network, so if a blockchain suffers a consensus attack or hard fork, the blockchain will disconnect from the network rather than potentially produce invalid signed VAAs</li> <li>Any Signed VAA can be verified as authentic by the Core Contract of any other chain</li> <li>Relayers are considered untrusted in the Wormhole ecosystem</li> </ul> <p>In summary:</p> <ul> <li>Core integrators aren't exposed to risk from chains and contracts they don't integrate with</li> <li>By default, you only trust Wormhole's signing process and the core contracts of the chains you're on</li> <li>You can expand your contract and chain dependencies as you see fit</li> </ul> <p>Core assumptions aside, many other factors impact the real-world security of decentralized platforms. Here is more information on additional measures that have been put in place to ensure the security of Wormhole.</p>"},{"location":"learn/fundamentals/security/#guardian-network","title":"Guardian Network","text":"<p>Wormhole is an evolving platform. While the Guardian set currently comprises 19 validators, this is a limitation of current blockchain technology.</p>"},{"location":"learn/fundamentals/security/#governance","title":"Governance","text":"<p>Governance is the process through which contract upgrades happen. Guardians manually vote on governance proposals that originate inside the Guardian Network and are then submitted to ecosystem contracts.</p> <p>This means that governance actions are held to the same security standard as the rest of the system. A two-thirds supermajority of the Guardians is required to pass any governance action.</p> <p>Governance messages can target any of the various wormhole modules, including the core contracts and all currently deployed token bridge contracts. When a Guardian signs such a message, its signature implies a vote on the action in question. Once more than two-thirds of the Guardians have signed, the message and governance action are considered valid.</p> <p>All governance actions and contract upgrades have been managed via Wormhole's on-chain governance system.</p> <p>Via governance, the Guardians can:</p> <ul> <li>Change the current Guardian set</li> <li>Expand the Guardian set</li> <li>Upgrade ecosystem contract implementations</li> </ul> <p>The governance system is fully open source in the core repository. See the Open Source section for contract source.</p>"},{"location":"learn/fundamentals/security/#monitoring","title":"Monitoring","text":"<p>A key element of Wormhole's defense-in-depth strategy is that each Guardian is a highly competent validator company with its own in-house processes for running, monitoring, and securing blockchain operations. This heterogeneous approach to monitoring increases the likelihood that fraudulent activity is detected and reduces the number of single failure points in the system.</p> <p>Guardians are not just running Wormhole validators; they're running validators for every blockchain inside of Wormhole as well, which allows them to perform monitoring holistically across decentralized computing rather than just at a few single points.</p> <p>Guardians monitor:</p> <ul> <li>Block production and consensus of each blockchain - if a blockchain's consensus is violated, it will be disconnected from the network until the Guardians resolve the issue</li> <li>Smart contract level data - via processes like the Governor, Guardians constantly monitor the circulating supply and token movements across all supported blockchains</li> <li>Guardian level activity - the Guardian Network functions as an autonomous decentralized computing network, complete with its blockchain (Gateway)</li> </ul>"},{"location":"learn/fundamentals/security/#gateway-and-asset-layer-protections","title":"Gateway And Asset Layer Protections","text":"<p>One of the most powerful aspects of the Wormhole ecosystem is that Guardians effectively have the entire state of DeFi available to them.</p> <p>Gateway is a Cosmos-based blockchain that runs internally to the Guardian network, whereby the Guardians can effectively execute smart contracts against the current state of all blockchains rather than just one blockchain.</p> <p>This enables additional protection for the Wormhole Asset Layer in addition to the core assumptions:</p> <ul> <li>Global Accountant - the accountant tracks the total circulating supply of all Wormhole assets across all chains and prevents any blockchain from bridging assets which would violate the supply invariant</li> </ul> <p>In addition to the Global Accountant, Guardians may only sign transfers that do not violate the requirements of the Governor. The Governor tracks inflows and outflows of all blockchains and delays suspicious transfers that may indicate an exploit.</p>"},{"location":"learn/fundamentals/security/#open-source","title":"Open Source","text":"<p>Wormhole builds in the open and is always open source.</p> <ul> <li>Wormhole core repository</li> <li>Wormhole Foundation GitHub organization</li> <li>Wormhole contract deployments</li> </ul>"},{"location":"learn/fundamentals/security/#audits","title":"Audits","text":"<p>Wormhole has been heavily audited, with 29 third-party audits completed and more started. Audits have been performed by the following firms:</p> <ul> <li>Trail of Bits</li> <li>Neodyme</li> <li>Kudelski</li> <li>OtterSec</li> <li>Certik</li> <li>Hacken</li> <li>Zellic</li> <li>Coinspect</li> <li>Halborn</li> <li>Cantina</li> </ul> <p>All audits and final reports can be found in security page of the GitHub Repo.</p>"},{"location":"learn/fundamentals/security/#bug-bounties","title":"Bug Bounties","text":"<p>Wormhole has one of the largest bug bounty programs in software development and has repeatedly shown commitment to engaging with the white hat community.</p> <p>Wormhole runs a bug bounty program through Immunefi program, with a top payout of 5 million dollars.</p> <p>If you are interested in contributing to Wormhole security, please look at this section for Getting Started as a White Hat, and follow the Wormhole Contributor Guidelines.</p> <p>For more information about submitting to the bug bounty programs, refer to the Wormhole Immunefi page.</p>"},{"location":"learn/fundamentals/security/#learn-more","title":"Learn More","text":"<p>The SECURITY.md from the official repository has the latest security policies and updates.</p>"},{"location":"learn/infrastructure/","title":"Infrastructure Components","text":""},{"location":"learn/infrastructure/#get-started","title":"Get Started","text":"<p>This section provides a closer look at the core components that power Wormhole's infrastructure, including Guardians, relayers, VAAs, and the Spy.</p> <ul> <li> <p> How Do Wormhole\u2019s Infrastructure Components Work Together?</p> <p>A simplified flow of a cross-chain message from a source-chain contract to a target-chain contract can be summarized as follows:</p> <ol> <li>Messages are sent from a source contract to the Wormhole Core Contract on the source chain, which publishes them on-chain</li> <li>Guardians then validate these messages before forwarding them to the target chain</li> <li>The validated message is encapsulated in a VAA (Verifiable Action Approval), combining the message with Guardian signatures to create a proof</li> <li>A relayer relays the VAA to the target chain, which is then verified by the Wormhole Core Contract on the target chain</li> </ol> <p>You can find more information about the infrastructure components and how they work together on the Architecture Overview page.</p> </li> </ul>"},{"location":"learn/infrastructure/#components","title":"Components","text":"<ul> <li> <p> Wormhole Core Contracts</p> <p>The Core Contracts are responsible for publishing and verifying all cross-chain messages.</p> <p> Learn more about Core Contracts</p> </li> <li> <p> Verifiable Action Approvals (VAAs)</p> <p>VAAs are Wormhole's core messaging primitive, consisting of cross-chain data packets.</p> <p> Learn more about VAAs</p> </li> <li> <p> Guardians</p> <p>Guardians are nodes responsible for observing messages and signing the corresponding payloads.</p> <p> Learn more about Guardians</p> </li> <li> <p> Relayers</p> <p>Relayers are processes that handle the delivery of VAAs to their intended destination.</p> <p> Learn more about relayers</p> </li> <li> <p> Spy</p> <p>A Spy watches the messages published by the Guardian Network and can forward network traffic.</p> <p> Learn more about the Spy</p> </li> </ul>"},{"location":"learn/infrastructure/core-contracts/","title":"Core Contracts","text":""},{"location":"learn/infrastructure/core-contracts/#introduction","title":"Introduction","text":"<p>The Wormhole Core Contract is a fundamental component of the Wormhole interoperability protocol deployed across each supported blockchain network. This contract acts as the foundational layer that enables secure and efficient cross-chain messaging, as all cross-chain applications either interact directly with the Core Contract or with another contract that does.</p> <p>This guide summarizes the key functions of the Core Contract and outlines how the Core Contract works.</p>"},{"location":"learn/infrastructure/core-contracts/#key-functions-of-the-wormhole-core-contract","title":"Key Functions of the Wormhole Core Contract","text":"<ul> <li> <p>Cross-chain messaging - the Core Contract enables the transfer of messages between different blockchain networks connected via Wormhole. It standardizes and secures the message format, ensuring consistent communication across multiple chains. This capability allows developers to build cross-chain applications that leverage the unique features of each network</p> </li> <li> <p>Verification and validation - the Core Contract is responsible for verifying and validating all VAAs received on the target chain. When a message is transmitted from one blockchain, it is signed by the Wormhole Guardians (a decentralized set of validators). The Core Contract on the target chain checks this signature to confirm that the message is legitimate and has not been tampered with</p> </li> <li> <p>Guardian Network coordination - the Core Contract coordinates with Wormhole's Guardian Network to facilitate secure, trustless communication across chains. By relying on a quorum of Guardians to verify cross-chain messages and transactions, the contract ensures that only validated interactions are processed, enhancing the protocol's overall security and reliability</p> </li> <li> <p>Event emission for monitoring - the Core Contract emits events for every cross-chain message it processes, allowing dApps and developers to monitor activity on the network. These events are critical for tracking message statuses, debugging, and building responsive applications that can react to cross-chain events in real time</p> </li> </ul>"},{"location":"learn/infrastructure/core-contracts/#how-the-core-contract-works","title":"How the Core Contract Works","text":"<p>The Wormhole Core Contract is central in facilitating secure and efficient cross-chain transactions. It enables communication between different blockchain networks by packaging transaction data into standardized messages, verifying their authenticity, and ensuring they are executed correctly on the destination chain. This process involves several steps, from the initial message submission to final execution, all while leveraging the Wormhole Guardian network to maintain trust and security.</p> <p>Below is a simplified breakdown that focuses on the role of the Wormhole Core Contract in these operations:</p> <ol> <li>Message submission - when a user initiates a cross-chain transaction, the Wormhole Core Contract on the source chain packages the transaction data into a standardized message payload and submits it to the Guardian Network for verification</li> <li>Guardian verification - the Guardians observe and sign the message independently. Once enough Guardians have signed the message, the collection of signatures is combined with the message and metadata to produce a VAA</li> <li>Message reception and execution - on the target chain, the Wormhole Core Contract receives the verified message, checks the Guardians' signatures, and executes the corresponding actions, such as minting tokens, updating states, or calling specific smart contract functions</li> </ol> <p>For a closer look at how messages flow between chains and all of the components involved, you can refer to the Architecture Overview page.</p>"},{"location":"learn/infrastructure/core-contracts/#message-submission","title":"Message Submission","text":"<p>When sending a cross-chain message from the source chain Core Contract, you'll call a function that publishes the message. The implementation strategy for publishing messages differs by chain. However, the general strategy consists of the Core Contract posting the following items to the blockchain logs:</p> <ul> <li><code>emitterAddress</code> - the contract which made the call to publish the message</li> <li><code>sequenceNumber</code> - a unique number that increments for every message for a given emitter (and implicitly chain)</li> <li><code>consistencyLevel</code>- the level of finality to reach before the Guardians will observe and attest the emitted event. This is a defense against reorgs and rollbacks since a transaction, once considered \"final,\"  is guaranteed not to have the state changes it caused rolled back. Since different chains use different consensus mechanisms, each one has different finality assumptions, so this value is treated differently on a chain-by-chain basis. See the options for finality for each chain in the Consistency Levels reference page</li> </ul> <p>There are no fees to publish a message except when publishing on Solana, but this is subject to change in the future.</p>"},{"location":"learn/infrastructure/core-contracts/#message-reception","title":"Message Reception","text":"<p>When receiving a cross-chain message on the target chain Core Contract, the general approach involves parsing and verifying the components of a VAA.</p> <p>The process of receiving and verifying a VAA ensures that the message was properly attested by the Guardian Network, maintaining the integrity and authenticity of the data transmitted between chains.</p>"},{"location":"learn/infrastructure/core-contracts/#multicast","title":"Multicast","text":"<p>Multicast refers to simultaneously broadcasting a single message or transaction across different blockchains. This means there is no destination address or chain for the sending and receiving functions. This is possible because VAAs attest that \"this contract on this chain said this thing.\" Therefore, VAAs are multicast by default and will be verified as authentic on any chain where they are used.</p> <p>This multicast-by-default model makes it easy to synchronize the state across the entire ecosystem because a single blockchain can make its data available to every chain in a single action with low latency. This reduces the complexity of the n^2 problems encountered by routing data to a large number of blockchains.</p> <p>This doesn't mean an application\u00a0cannot\u00a0specify a destination address or chain. For example, the Token Bridge and Wormhole relayer contracts require that some destination details be passed and verified on the destination chain.</p> <p>Because the VAA creation is separate from relaying, the multicast model does not incur an additional cost when a single chain is targeted. If the data isn't needed on a certain blockchain, don't relay it there, and it won't cost anything.</p>"},{"location":"learn/infrastructure/guardians/","title":"Guardians","text":""},{"location":"learn/infrastructure/guardians/#guardian","title":"Guardian","text":"<p>Wormhole relies on a set of distributed nodes that monitor the state on several blockchains. In Wormhole, these nodes are referred to as Guardians. The current Guardian set can be seen in the Dashboard.</p> <p>It is the Guardians' role to observe messages and sign the corresponding payloads. Each Guardian performs this step in isolation, combining the resulting signatures with other Guardians as a final step. The resulting collection of independent observations forms a multisig, representing proof that the majority of the Wormhole network has observed and agreed upon a state. These multisigs are referred to as VAAs in Wormhole.</p>"},{"location":"learn/infrastructure/guardians/#guardian-network","title":"Guardian Network","text":"<p>The Guardian Network is designed to serve as Wormhole's oracle component, and the entire Wormhole ecosystem is founded on its technical underpinnings. It is the most critical element of the Wormhole ecosystem and represents the most crucial component to learn about if you want a deep understanding of it.</p> <p>To understand not just how the Guardian Network works but why it works the way it does, it is important to review the key design considerations. To become the best-in-class interoperability platform, Wormhole needed to have five critical features:</p> <ul> <li>Decentralization - control of the network needs to be distributed amongst many parties</li> <li>Modularity - disparate parts of the ecosystem, such as the oracle, relayer, applications, and others, should be kept as separate and modular as possible so they can be designed, modified, and upgraded independently</li> <li>Chain Agnosticism - Wormhole should be able to support not only EVM but also chains like Solana, Algorand, Cosmos, and even platforms that still need to be created. It also shouldn't have any one chain as a single point of failure</li> <li>Scalability - Wormhole should be able to secure a large amount of value immediately and be able to handle the large transaction volume</li> <li>Upgradeable - as the decentralized computing ecosystem evolves, Wormhole will need to be able to change the implementation of its existing modules without breaking integrators</li> </ul> <p>Next, the ways\u00a0by which Wormhole achieves this will be examined individually.</p>"},{"location":"learn/infrastructure/guardians/#decentralization","title":"Decentralization","text":"<p>Decentralization is the biggest concern. Previous interoperability solutions have largely been entirely centralized, and even newer solutions utilizing things like adversarial relayers still tend to have single points of failure or collusion thresholds as low as one or two.</p> <p>When designing a decentralized oracle network, the first option to consider is likely a Proof-of-Stake (PoS) system however, this is a suboptimal solution. PoS is designed for blockchain consensus in smart contract-enabled environments, so it's less suitable when the network verifies the output of many blockchains and doesn't support its own smart contracts. While it looks appealing from a decentralization perspective, network security remains to be seen, and it can make some of the other outlined goals more challenging to achieve. Different options need to be explored.</p> <p>Another option is to use Zero-Knowledge Proofs (ZKP) to secure the network. This would be a good solution from a decentralization perspective, as it's trustless. However, ZKPs are still a nascent technology, and verifying them on-chain isn't feasible, especially on chains with limited computational environments. That means a form of multisig will be needed to secure the network.</p> <p>In the current De-Fi landscape, most of the top blockchains are secured by the same handful of validator companies. Currently, only a limited number of companies in the world have the skills and capital to run top-notch validator companies.</p> <p>If a protocol could unite a large number of those validator companies into a purpose-built consensus mechanism optimized for chain interoperability, that design would likely be more performant and secure than a network bootstrapped by a tokenomics model. Assuming the validators would be on board, how many could Wormhole realistically utilize?</p> <p>If Wormhole used threshold signatures, the answer would be \"as many as are willing to participate.\" However, threshold signatures need more support across the blockchain world, meaning verifying the signatures would be difficult and expensive, ultimately limiting scalability and chain agnosticism. Thus, a t-schnorr multisig presents itself as the best option: cheap and well-supported, even though its verification costs increase linearly with the number of signatures included.</p> <p>All these things considered, 19 seems to be the maximum number and a good tradeoff. If two-thirds of the signatures are needed for consensus, then 13 signatures must be verified on-chain, which remains reasonable from a gas-cost perspective.</p> <p>Rather than securing the network with tokenomics, it is better to initially secure the network by involving robust companies that are heavily invested in De-Fi's success. The 19 Guardians aren't anonymous or small, they are many of the largest and most widely known validator companies in cryptocurrency. </p> <p>This led to a network of 19 Guardians, each with an equal stake, and joined in a purpose-built Proof-of-Authority consensus mechanism. As threshold signatures become better supported, the Guardian Set can expand, and once ZKPs are ubiquitous, the Guardian Network will become fully trustless.</p> <p>With the perspective on Decentralization laid out, the remaining elements fall into place.</p>"},{"location":"learn/infrastructure/guardians/#modularity","title":"Modularity","text":"<p>The Guardian Network is robust and trustworthy by itself, so there's no need for components like the relayer to contribute to the security model. That makes Wormhole able to have simple components that are very good at their one thing. Guardians only need to verify on-chain activity and produce VAAs, while relayers only need to interact with blockchains and deliver messages.</p> <p>The VAAs' signing scheme can be changed without affecting downstream users, and multiple relay mechanisms can exist independently. xAssets can be implemented purely at the application layer, and cross-chain applications can use whatever components suit them.</p>"},{"location":"learn/infrastructure/guardians/#chain-agnosticism","title":"Chain Agnosticism","text":"<p>Today, Wormhole supports a broader range of ecosystems than any other interoperability protocol because it uses simple tech (t-schnorr signatures), an adaptable, heterogeneous relayer model, and a robust validator network.</p> <p>Wormhole can expand to new ecosystems as quickly as a Core Contract can be developed for the smart contract runtime. Relayers don't need to be factored into the security model; they just need to be able to upload messages to the blockchain. The Guardians are able to observe every transaction on every chain without taking shortcuts.</p>"},{"location":"learn/infrastructure/guardians/#scalability","title":"Scalability","text":"<p>Wormhole scales well, as demonstrated by its ability to handle huge total value locked (TVL) and transaction volume even during tumultuous events.</p> <p>The requirements for running a Guardian are relatively heavy, as they must run a full node for every single blockchain in the ecosystem. This is another reason why a limited number of robust validator companies are beneficial for this design.</p> <p>However, once all the full nodes are running, the Guardian Network's actual computation and network overheads become lightweight. The blockchains' performance tends to be the bottleneck in Wormhole rather than anything happening inside the Guardian Network.</p>"},{"location":"learn/infrastructure/guardians/#upgradeable","title":"Upgradeable","text":"<p>Over time, the Guardian Set can be expanded beyond 19 using threshold signatures. Various relaying models will emerge, each with their own strengths and weaknesses. ZKPs can be used on chains where they are well-supported. The cross-chain application ecosystem will grow, and cross-chain applications will become increasingly intermingled. There are very few APIs in Wormhole, and most items are implementation details from the integrator perspective. This creates a clear pathway towards a fully trustless interoperability layer that spans decentralized computing.</p>"},{"location":"learn/infrastructure/relayer/","title":"Relayers","text":"<p>This documentation provides a comprehensive guide to relayers within the Wormhole network, describing their role, types, and benefits in facilitating cross-chain processes.</p> <p>Relayers in the Wormhole context are processes that deliver Verified Action Approvals (VAAs) to their destination, playing a crucial role in Wormhole's security model. They can't compromise security, only availability, and act as delivery mechanisms for VAAs without the capacity to tamper with the outcome.</p> <p>There are three primary types of relayers discussed:</p> <ul> <li>Client-side relaying - a cost-efficient, no-backend-infrastructure approach relying on user-facing front ends. It provides a simple solution, although it can complicate the user experience due to the manual steps involved</li> <li>Custom relayers - backend components that handle parts of the cross-chain process, offering a smoother user experience and allowing off-chain calculations to reduce gas costs. These relayers could operate through direct listening to the Guardian Network (Spy relaying) or by providing a REST endpoint to accept VAAs to be relayed (REST relaying)</li> <li>Wormhole-deployed relayers - a decentralized relayer network that can deliver arbitrary VAAs, reducing the developer's need to develop, host, or maintain relayers. However, they require all calculations to be done on-chain and might be less gas-efficient</li> </ul>"},{"location":"learn/infrastructure/relayer/#fundamentals","title":"Fundamentals","text":"<p>This section highlights the crucial principles underpinning the operation and handling of relayers within the Wormhole network.</p> <p>Relayers are fundamentally trustless entities within the network. This means that while they don't require your trust, they shouldn't be trusted implicitly. They function as delivery mechanisms, transporting VAAs from their source to their destination.</p> <p>Key characteristics of VAAs include:</p> <ul> <li>Public emission from the Guardian Network</li> <li>Authentication through signatures from the Guardian Network</li> <li>Verifiability by any entity or any Wormhole Core Contract</li> <li>As a result of these characteristics, anyone can pick up a VAA and deliver it anywhere, but no one can alter the VAA content without invalidating the signatures</li> </ul> <p>When designing contracts, it's crucial to only trust information contained within your contract or a VAA. Relying on information from a relayer could expose you to input attacks.</p> <p>Advanced strategies can involve relayers performing trustless off-chain computation passed into the destination contract. These strategies can optimize gas costs but also create attack vectors if not used correctly.</p> <p>In summary, the design of a relayer should ensure that there's a single, deterministic way to process messages in your protocol. In an optimally designed protocol, relayers should have a \"correct\" implementation, mirroring \"crank turner\" processes used elsewhere in blockchain.</p>"},{"location":"learn/infrastructure/relayer/#client-side-relaying","title":"Client-Side Relaying","text":"<p>Client-side relaying relies on user-facing front ends, such as a webpage or a wallet, to complete the cross-chain process.</p> <p>Key Features</p> <ul> <li>Cost-efficiency - users only pay the transaction fee for the second transaction, eliminating any additional costs</li> <li>No backend infrastructure - the process is completely client-based, eliminating the need for a backend relaying infrastructure</li> </ul> <p>Implementation</p> <p>Users themselves carry out the three steps of the cross-chain process:</p> <ol> <li>Perform an action on chain A</li> <li>Retrieve the resulting VAA from the Guardian Network</li> <li>Perform an action on chain B using the VAA</li> </ol> <p>Considerations</p> <p>Note</p> <p>Though simple, this type of relaying is generally not recommended if your aim is a highly polished user experience. It can, however, be useful for getting a Minimum Viable Product (MVP) up and running.</p> <ul> <li>Users must sign all required transactions with their own wallet</li> <li>Users must have funds to pay the transaction fees on every chain involved</li> <li>The user experience may be cumbersome due to the manual steps involved</li> </ul>"},{"location":"learn/infrastructure/relayer/#custom-relayers","title":"Custom Relayers","text":"<p>Custom relayers are purpose-built components within the Wormhole protocol, designed to relay messages for specific applications. They are capable of performing off-chain computations and can be customized to suit a variety of use cases.</p> <p>Key Features</p> <ul> <li>Optimization - capable of performing trustless off-chain computations which can optimize gas costs</li> <li>Customizability - allows for specific strategies like batching, conditional delivery, multi-chain deliveries, and more</li> <li>Incentive structure - developers have the freedom to design an incentive structure suitable for their application</li> <li>Enhanced UX - the ability to retrieve a VAA from the Guardian Network and perform an action on the target chain using the VAA on behalf of the user can simplify the user experience</li> </ul> <p>Implementation</p> <p>Note</p> <p>To make the development of custom relayers easier, a plugin relayer is available in the main Wormhole repository. This sets up the basic infrastructure for relaying, allowing developers to focus on implementing the specific logic for their application.</p> <p>There are two main methods of setting up a custom relayer:</p> <ul> <li>Spy relaying - involves listening directly to the Guardian Network via a Spy</li> <li>REST relaying - provides a REST endpoint to accept a VAA that should be relayed</li> </ul> <p>Considerations</p> <p>Remember, despite their name, custom relayers still need to be considered trustless. VAAs are public and can be submitted by anyone, so developers shouldn't rely on off-chain relayers to perform any computation considered \"trusted.\"</p> <ul> <li>Development work and hosting of relayers are required</li> <li>The fee-modeling can become complex, as relayers are responsible for paying target chain fees</li> <li>Relayers are responsible for availability, adding dependency for the cross-chain application</li> </ul>"},{"location":"learn/infrastructure/relayer/#wormhole-relayers","title":"Wormhole Relayers","text":"<p>Wormhole relayers are a component of a decentralized network in the Wormhole protocol, facilitating the delivery of VAAs to recipient contracts compatible with the standard relayer API.</p> <p>Key Features</p> <ul> <li>Lower operational costs - no need to develop, host, or maintain individual relayers</li> <li>Simplified integration - because there is no need to run a relayer, integration is as simple as calling a function and implementing an interface</li> </ul> <p>Implementation</p> <p>The Wormhole relayer integration involves two key steps:</p> <ul> <li>Delivery request - request delivery from the ecosystem Wormhole relayer contract</li> <li>Relay reception - implement a <code>receiveWormholeMessages</code> function within their contracts. This function is invoked upon successful relay of the VAA</li> </ul> <p>Considerations</p> <p>Note</p> <p>Developers should note that the choice of relayers depends their project's specific requirements and constraints. Wormhole relayers offer simplicity and convenience but limit customization and optimization opportunities compared to custom relayers.</p> <ul> <li>All computations are performed on-chain</li> <li>Potentially less gas-efficient compared to custom relayers</li> <li>Optimization features like conditional delivery, batching, off-chain calculations might be restricted</li> <li>Support may not be available for all chains</li> </ul>"},{"location":"learn/infrastructure/spy/","title":"Spy","text":""},{"location":"learn/infrastructure/spy/#introduction","title":"Introduction","text":"<p>In the Wormhole context, a Spy is a daemon that subscribes to the gossiped messages in the Guardian Network.</p> <p>They don\u2019t do any validation work. Instead, they watch the Guardian Network and act as an interface to allow users and applications to check on the Spy-accessible messages.</p>"},{"location":"learn/infrastructure/spy/#spy-accessible-messages","title":"Spy-Accessible Messages","text":"<p>The messages available over gossip are things like:</p> <ul> <li>Verifiable Action Approvals (VAAs) - packets of cross-chain data. A Spy can see whether a VAA has been approved by the Guardian Network</li> <li>Observations - messages emitted by Core Contracts that the Guardians have picked up</li> <li>Guardian heartbeats - the liveness of a Guardian</li> </ul>"},{"location":"learn/infrastructure/spy/#source-code","title":"Source Code","text":"<p>The source code for the Spy is available on GitHub.</p>"},{"location":"learn/infrastructure/vaas/","title":"Verified Action Approvals","text":"<p>VAAs are Wormhole's core messaging primitive. They are packets of cross-chain data emitted whenever a cross-chain application contract interacts with the Core Contract.</p> <p>The Guardians must validate messages emitted by contracts before sending them to the target chain. Once a majority of Guardians observe the message and determine finality, the Guardians sign a keccak256 hash of the message body.</p> <p>The message is wrapped up in a structure called a VAA, which combines the message with the Guardian signatures to form a proof.</p> <p>VAAs are uniquely indexed by the (<code>emitter_chain</code>, <code>emitter_address</code>, <code>sequence</code>) tuple. To obtain a VAA, one can query the Wormholescan API with this information.</p> <p>These VAAs are ultimately what a smart contract on a receiving chain must process to receive a Wormhole message.</p>"},{"location":"learn/infrastructure/vaas/#vaa-format","title":"VAA Format","text":"<p>The basic VAA has two components: a header and a body.</p>"},{"location":"learn/infrastructure/vaas/#header","title":"Header","text":"<p>The header holds metadata about the current VAA, the Guardian set that is currently active, and the list of signatures gathered so far.</p> <ul> <li><code>version</code> byte - the VAA Version</li> <li><code>guardian_set_index</code> u32 - indicates which Guardian set is signing</li> <li><code>len_signatures</code> u8 - the number of signatures stored</li> <li><code>signatures</code> []signature - the collection of Guardian signatures</li> </ul> <p>Where each <code>signature</code> is:</p> <ul> <li><code>index</code> u8 - the index of this Guardian in the Guardian set</li> <li><code>signature</code> [65]byte - the ECDSA signature</li> </ul>"},{"location":"learn/infrastructure/vaas/#body","title":"Body","text":"<p>The body is deterministically derived from an on-chain message. Any two Guardians processing the same message must derive the same resulting body. This requirement exists so that there is always a one-to-one relationship between VAAs and messages to avoid double-processing messages.</p> <ul> <li><code>timestamp</code> u32 - the timestamp of the block this message was published in</li> <li><code>nonce</code> u32</li> <li><code>emitter_chain</code> u16 - the id of the chain that emitted the message</li> <li><code>emitter_address</code> [32]byte - the contract address (Wormhole formatted) that called the Core Contract</li> <li><code>sequence</code> u64 - the auto-incrementing integer that represents the number of messages published by this emitter</li> <li><code>consistency_level</code> u8 - the consistency level (finality) required by this emitter</li> <li><code>payload</code> []byte - arbitrary bytes containing the data to be acted on</li> </ul> <p>The body contains relevant information for entities, such as contracts, or other systems, that process or utilize VAAs. When a function like <code>parseAndVerifyVAA</code> is called, the body is returned, allowing verification of the <code>emitterAddress</code> to determine if the VAA originated from a trusted contract.</p> <p>Note</p> <p>Because VAAs have no destination, they are effectively multicast. Any Core Contract on any chain in the network will verify them as authentic. If a VAA has a specific destination, relayers are entirely responsible for completing that delivery appropriately.</p>"},{"location":"learn/infrastructure/vaas/#signatures","title":"Signatures","text":"<p>The body of the VAA is hashed twice with <code>keccak256</code> to produce the signed digest message.</p> <pre><code>// hash the bytes of the body twice\ndigest = keccak256(keccak256(body))\n// sign the result \nsignature = ecdsa_sign(digest, key)\n</code></pre> <p>Note</p> <p>Different implementations of the ECDSA signature validation may apply a keccak256 hash to the message passed, so care must be taken to pass the correct arguments.</p> <p>For example, the Solana secp256k1 program will hash the message passed. In this case, the argument for the message should be a single hash of the body, not the twice-hashed body.</p>"},{"location":"learn/infrastructure/vaas/#payload-types","title":"Payload Types","text":"<p>Different applications built on Wormhole may specify a format for the payloads attached to a VAA. This payload provides information on the target chain and contract so it can take action (e.g., minting tokens to a receiver address).</p>"},{"location":"learn/infrastructure/vaas/#token-transfer","title":"Token Transfer","text":"<p>Tokens are transferred between chains using a lockup/mint and burn/unlock mechanism. Many bridges use such a basic method, but the implementation described leverages the generic message-passing protocol provided by Wormhole to handle the routing of lock and burn events across chains. This approach ensures that Wormhole's Token Bridge is chain-agnostic. The bridge can be rapidly integrated into any network with a Wormhole contract. Wormhole's generic message-passing doesn't require any program to send messages to understand the specific implementation details of other chains.</p> <p>To transfer tokens from Chain A to Chain B, you must lock them on A and mint them on B. The tokens on A must be proven to be locked before the minting can occur on B. To facilitate this process, Chain A first locks the tokens and emits a message indicating that the locking has been completed. This message has the following structure and is referred to as a transfer message:</p> <ul> <li><code>payload_id</code> u8 - the ID of the payload. This should be set to <code>1</code> for a token transfer</li> <li><code>amount</code> u256 - amount of tokens being transferred</li> <li><code>token_address</code> u8[32] - address on the source chain</li> <li><code>token_chain</code> u16 - numeric ID for the source chain</li> <li><code>to</code> u8[32] - address on the destination chain</li> <li><code>to_chain</code> u16 - numeric ID for the destination chain</li> <li><code>fee</code> u256 - portion of amount paid to a relayer</li> </ul> <p>This structure contains everything the receiving chain needs to learn about a lockup event. Once Chain B receives this payload, it can mint the corresponding asset.</p> <p>Note that Chain B is agnostic regarding how the tokens on the sending side were locked. They could have been burned by a mint or locked in a custody account. The protocol relays the event once enough Guardians have attested to its existence.</p>"},{"location":"learn/infrastructure/vaas/#attestation","title":"Attestation","text":"<p>The Transfer event in the preceding section needs an important detail added. While the program on Chain B can trust the message to inform it of token lockup events, it has no way of verifying the correct token is locked up. The address alone is a meaningless value to most users. To solve this, the Token Bridge supports token attestation.</p> <p>For a token attestation, Chain A emits a message containing metadata about a token, which Chain B may use to preserve the name, symbol, and decimal precision of a token address.</p> <p>The message format for this action is as follows:</p> <ul> <li><code>payload_id</code> u8 - the ID of the payload. This should be set to <code>2</code> for an attestation</li> <li><code>token_address</code> [32]byte - address of the originating token contract</li> <li><code>token_chain</code> u16 - chain ID of the originating token </li> <li><code>decimals</code> u8 - number of decimals this token should have</li> <li><code>symbol</code> [32]byte - short name of asset</li> <li><code>name</code> [32]byte - full name of asset</li> </ul> <p>Attestations use a fixed-length byte array to encode UTF8 token name and symbol data.</p> <p>Note</p> <p>Because the byte array is fixed length, the data contained may truncate multibyte Unicode characters.</p> <p>When sending an attestation VAA, it is recommended to send the longest UTF-8 prefix that doesn't truncate a character and then right-pad it with zero bytes.</p> <p>When parsing an attestation VAA, it is recommended to trim all trailing zero bytes and converting the remainder to UTF-8 via any lossy algorithm.</p> <p>Note</p> <p>Be mindful that different on-chain systems may have different VAA parsers, resulting in different names/symbols on different chains if the string is long or contains invalid UTF8.</p> <p>Without knowing a token's decimal precision, Chain B cannot correctly mint the number of tokens when processing a transfer. For this reason, the Token Bridge requires an attestation for each token transfer.</p>"},{"location":"learn/infrastructure/vaas/#token-transfer-with-message","title":"Token Transfer with Message","text":"<p>Note</p> <p>This VAA type is also referred to as a payload3 message or a Contract Controlled Transfer.</p> <p>The Token Transfer with Message data structure is identical to the token-only data structure with the addition of a <code>payload</code> field containing arbitrary bytes. In this arbitrary byte field, an app may include additional data in the transfer to inform some application-specific behavior.</p> <ul> <li><code>payload_id</code> u8 -  the ID of the payload. This should be set to <code>3</code> for a token transfer with message </li> <li><code>amount</code> u256 - amount of tokens being transferred</li> <li><code>token_address</code> u8[32] - address on the source chain</li> <li><code>token_chain</code> u16 - numeric ID for the source chain</li> <li><code>to</code> u8[32] - address on the destination chain</li> <li><code>to_chain</code> u16 - numeric ID for the destination chain</li> <li><code>fee</code> u256 - portion of amount paid to a relayer</li> <li><code>payload</code> []byte - message, arbitrary bytes, app specific</li> </ul>"},{"location":"learn/infrastructure/vaas/#governance","title":"Governance","text":"<p>Governance VAAs don't have a <code>payload_id</code> field like the preceding formats. They're used to trigger some action in the deployed contracts (for example, upgrade).</p>"},{"location":"learn/infrastructure/vaas/#action-structure","title":"Action Structure","text":"<p>Governance messages contain pre-defined actions, which can target the various Wormhole modules currently deployed on-chain. The structure contains the following fields:</p> <ul> <li><code>module</code> u8[32] - contains a right-aligned module identifier</li> <li><code>action</code> u8 - predefined governance action to execute</li> <li><code>chain</code> u16 - chain the action is targeting. This should be set to <code>0</code> for all chains</li> <li><code>args</code> any - arguments to the action</li> </ul> <p>Below is an example message containing a governance action triggering a code upgrade to the Solana Core Contract. The module field here is a right-aligned encoding of the ASCII Core, represented as a 32-byte hex string.</p> <pre><code>module:       0x0000000000000000000000000000000000000000000000000000436f7265\naction:       1\nchain:        1\nnew_contract: 0x348567293758957162374959376192374884562522281937446234828323\n</code></pre>"},{"location":"learn/infrastructure/vaas/#actions","title":"Actions","text":"<p>The meaning of each numeric action is pre-defined and documented in the Wormhole design documents. For each application, the relevant definitions can be found via these links:</p> <ul> <li>Core governance actions</li> <li>Token Bridge governance actions</li> <li>NFT Bridge governance actions</li> </ul>"},{"location":"learn/infrastructure/vaas/#lifetime-of-a-message","title":"Lifetime of a Message","text":"<p>Note</p> <p>Anyone can submit the VAA to the target chain. The Guardians typically don't perform this step to avoid transaction fees. Instead, applications built on top of Wormhole can acquire the VAA via the Guardian RPC and make the submission in a separate flow.</p> <p>With the concepts now defined, it is possible to illustrate what a full flow for message passing between two chains looks like. The following stages demonstrate each step of processing that the Wormhole network performs to route a message.</p> <ol> <li>A message is emitted by a contract running on Chain A - any contract can emit messages, and the Guardians are programmed to observe all chains for these events. Here, the Guardians are represented as a single entity to simplify the graphics, but the observation of the message must be performed individually by each of the 19 Guardians</li> <li>Signatures are aggregated - Guardians observe and sign the message independently. Once enough Guardians have signed the message, the collection of signatures is combined with the message and metadata to produce a VAA</li> <li>VAA submitted to target chain - the VAA acts as proof that the Guardians have collectively attested the existence of the message payload; to complete the final step, the VAA itself is submitted (or relayed) to the target chain to be processed by a receiving contract</li> </ol>"},{"location":"learn/messaging/","title":"Messaging Protocols","text":""},{"location":"learn/messaging/#get-started","title":"Get Started","text":"<p>This section covers various aspects and services related to communication protocols and systems within the Wormhole platform. Each subsection provides detailed information on key components, contracts, and bridges for messaging and data transfer.</p> <ul> <li> <p> Token Bridge</p> <p>The Token and NFT Bridges provide a secure, low-lift integration for cross-chain transfers of fungible and non-fungible tokens (NFTs).</p> <p> Learn more about Token Bridges</p> </li> <li> <p> Cosmos Gateway</p> <p>Wormhole Gateway is a Cosmos-SDK chain designed to bridge non-native assets into the Cosmos ecosystem, offering unified liquidity across Cosmos chains.</p> <p> Learn more about Gateway</p> </li> <li> <p> Circle's CCTP Bridge</p> <p>The CCTP Bridge supports fast and cost-effective native USDC transfers across blockchains using Circle's Cross Chain Transfer Protocol (CCTP).</p> <p> Learn more about CCTP</p> </li> <li> <p> Native Token Transfers</p> <p>Wormhole's Native Token Transfers (NTT) offers an open source and flexible framework for cross-chain token transfers, providing full control over token behavior on each blockchain.</p> <p> Learn more about NTT</p> </li> <li> <p> Fast Transfers</p> <p>Fast Transfers is a protocol designed by Wormhole to provide quick and efficient cross-chain liquidity movement, addressing fragmentation and finality with a hub-and-spoke model.</p> <p> Learn more about Fast Transfers</p> </li> </ul>"},{"location":"learn/messaging/cctp/","title":"Circle's CCTP Bridge","text":"<p>Wormhole Connect and the Wormhole TypeScript SDK support fast, cheap, native USDC bridging between all networks supported by Circle's Cross-Chain Transfer Protocol. CCTP is Circle's native USDC cross-chain transfer attestation service.</p> <p>While this protocol is wholly separate from Wormhole itself, Wormhole builds on top of CCTP and adds several valuable augmentations, making it more straightforward to use and more useful for end users. These features include:</p> <ul> <li>Automated relaying - eliminates the need for users to redeem USDC transfers themselves</li> <li>Gas payment on the destination chain - allows users to transfer USDC without needing to pay gas on the destination chain</li> <li>Gas drop off - enables users to convert a portion of USDC into the destination chain's gas token upon a successful transfer</li> </ul> <p>Note</p> <p>Wormhole supports all CCTP-supported chains but at the moment only a handful of chains are supported by Circle.</p> <p>You can use Wormhole's CCTP-powered USDC bridging by embedding the Connect Widget or by integrating the TypeScript SDK directly.</p>"},{"location":"learn/messaging/cctp/#automatic-relaying","title":"Automatic Relaying","text":"<p>To complete a CCTP transfer, the Circle Attestation must be delivered to the destination chain.</p> <p>This attestation delivery may be difficult or impossible in some contexts. For example, in a browser context, the user doesn't wish to wait for finality to deliver the attestation. To address this difficulty, the Wormhole CCTP relayer may be used either with the Wormhole Connect Widget or more directly with the Wormhole TypeScript SDK.</p> <p>The Wormhole CCTP Relayer charges a fee to deliver the attestation and complete the transfer.</p> Chain Fee Ethereum 1.0 USDC Everything else 0.1 USDC"},{"location":"learn/messaging/cctp/#native-gas-drop-off","title":"Native Gas Drop Off","text":"<p>Another advantage of using the automatic relaying feature is the opportunity to transfer some native gas to the receiver on the destination chain. This feature is referred to as native gas drop off.</p> <p>The ability to perform native gas drop off addresses the common issue where a user may hold a balance of USDC but has no native gas to perform subsequent transactions.</p>"},{"location":"learn/messaging/fast-transfers/","title":"Fast Transfers","text":""},{"location":"learn/messaging/fast-transfers/#overview","title":"Overview","text":"<p>Moving liquidity across different networks in the broader blockchain ecosystem enables assets and value to flow freely. However, challenges such as fragmented liquidity and slow transfer times often hinder this process due to the time-to-finality across various chains. These issues can lead to inefficiencies and delays that negatively impact the user experience and the functionality of decentralized applications.</p> <p>Fast Transfers is a protocol designed by Wormhole to address these challenges by providing a quick and efficient solution for cross-chain liquidity movement. Leveraging a hub-and-spoke model with Solana as the central hub, Fast Transfers consolidates liquidity into a single, unified pool. Solana was specifically chosen for its fast finality and low transaction costs, critical for enabling rapid asset transfers. This approach minimizes fragmentation by eliminating the need for multiple wrapped versions of the same token across different chains, ensuring a more streamlined and efficient transfer process.</p> <p>The key component of Fast Transfers is its aggregated auction mechanism, where solvers/market makers compete to offer the best rates for cross-chain transactions. This competitive environment ensures optimal pricing and efficient execution of transfers, significantly reducing wait times compared to traditional cross-chain methods.</p> <p>By addressing liquidity fragmentation and transfer delays, Fast Transfers provides developers with a robust and reliable infrastructure for building applications requiring swift and seamless cross-chain asset transfers. This enhancement improves the overall user experience and promotes greater interoperability within the blockchain ecosystem.</p> <p>This page introduces all relevant concepts to understand how Fast Transfers work, including the auction mechanism, the hub-and-spoke model, and the role of solvers in ensuring liquidity is always available where it\u2019s needed.</p>"},{"location":"learn/messaging/fast-transfers/#key-concepts","title":"Key Concepts","text":""},{"location":"learn/messaging/fast-transfers/#messaging-requirements-to-support-fast-transfers","title":"Messaging Requirements to Support Fast Transfers","text":"<p>To support Fast Transfers, a blockchain must meet one of the following messaging requirements:</p> <ul> <li>CCTP USDC (Cross-Chain Transfer Protocol USDC) - the primary requirement is that the chain must support CCTP USDC. This allows for seamless asset transfers using USDC as the intermediary currency across different chains</li> <li>NTT USDC (Native Token Transfers USDC) - Fast Transfers relies on Native Token Transfers (NTT) for chains that don't support CCTP or lack a canonical version of USDC. In this scenario, USDC is locked on the hub chain, and an NTT message is sent to the destination chain to initiate the transfer</li> <li>Liquidity through Wormhole-wrapped assets - in cases where CCTP USDC or NTT USDC are unavailable, the chain must have liquidity in Wormhole-wrapped assets. These wrapped assets can be used as an intermediate currency to facilitate transfers</li> </ul>"},{"location":"learn/messaging/fast-transfers/#hub-and-spoke-model","title":"Hub and Spoke Model","text":"<p>The hub-and-spoke model is a system architecture commonly used to optimize the movement of assets or information across a network. In this model, a central \"hub\" acts as the primary point of control and coordination, while \"spokes\" are the various endpoints or destinations that connect to the hub. This architecture is particularly effective in managing complex systems where resources need to be efficiently distributed and coordinated across multiple locations.</p> <p>At a high level, the hub-and-spoke model operates as follows:</p> <ul> <li>Hub -  the central node where all resources, data, assets, or information are aggregated and managed. The hub handles the distribution to the spokes, acting as a central point of processing and coordination. In the context of Fast Transfers, Solana serves as the hub chain where all liquidity is concentrated. Solana was chosen due to its fast finality, low transaction costs, and strong support for the Cross-Chain Transfer Protocol (CCTP). By consolidating liquidity on Solana, Fast Transfers can efficiently manage the distribution of assets across multiple chains through a competitive auction mechanism. Additionally, CCTP USDC is used as the base asset, ensuring that USDC liquidity is available for moving assets across different chains</li> <li>Spokes - the spokes are the endpoints connected to the hub. They rely on the hub to receive and send resources or information, creating a streamlined and centralized flow. In the case of Fast Transfers, these are the destination chains to which assets are transferred. Rather than transferring tokens directly between source and destination chains, Fast Transfers routes all transactions through the Solana hub. This routing allows for a more streamlined and efficient transfer process, reducing the complexity and delays that can arise from managing direct transfers between multiple chains</li> </ul> <p>This model is highly efficient because it aggregates control and reduces the complexity of direct interactions between each endpoint. Instead of managing multiple direct connections, each spoke only needs to connect to the hub, simplifying the overall system and ensuring that liquidity is effectively utilized where it is needed most.</p>"},{"location":"learn/messaging/fast-transfers/#how-it-works","title":"How It Works","text":"<p>Fast Transfers operates through a series of well-defined steps to ensure quick and reliable cross-chain transfers:</p> <ol> <li>Liquidity aggregation - the transfer process begins by moving assets from the source chain (a spoke) to the hub chain, Solana. Here, liquidity is concentrated, and the auction process takes place</li> <li>Auction process - once the assets reach Solana, an auction is initiated on the hub chain. Solvers, who are market participants, bid to provide the best possible rate for the transfer. The winning solver executes the swap and facilitates the transfer to the destination chain via:<ul> <li>CCTP (Cross-Chain Transfer Protocol) - the protocol uses CCTP to manage the movement of assets from the hub chain. CCTP handles the burning of tokens on the source chain and the minting of equivalent tokens on the destination chain, ensuring the integrity of the transfer process</li> <li>NTT (Native Token Transfers) - for chains that do not support CCTP, Fast Transfers employs NTT messages. In this case, USDC is locked on Solana, and an NTT message is sent to the destination chain, triggering the transfer of an equivalent value of tokens</li> </ul> </li> <li>Final transfer - the final step involves the solvers executing the necessary swaps to provide the user with a useful token on the destination chain. This ensures that the user receives the desired asset promptly, completing the cross-chain transfer process</li> </ol> <p>This structured approach allows Fast Transfers to overcome the limitations of direct chain-to-chain transfers by using Solana as a central hub and leveraging the strengths of CCTP and NTT protocols, ensuring efficient and reliable liquidity movement across multiple chains.</p>"},{"location":"learn/messaging/fast-transfers/#auction-mechanism","title":"Auction Mechanism","text":"<p>The auction mechanism is a core component of the Fast Transfers protocol, ensuring users receive the most efficient and cost-effective cross-chain transfers. It operates on the Solana network, where solvers compete to fulfill transfer requests by bidding in a reverse Dutch auction. This competitive environment drives down costs and speeds up the transfer process, benefiting both users and solvers.</p>"},{"location":"learn/messaging/fast-transfers/#auction-process","title":"Auction Process","text":"<p>The auction process is designed to be straightforward yet effective, enabling solvers to bid on transfer requests while managing risk through a security deposit system. Here\u2019s a detailed step-by-step breakdown of how the auction mechanism works:</p> <ol> <li>Initiation - users initiate a transfer through the Fast Transfers protocol, either via a user interface (UI) or directly on-chain. They can choose between a standard transfer, which waits for finality on the sending chain, or a Fast Transfer, which triggers the auction process. For Fast Transfers, users specify a maximum fee they are willing to pay and a deadline by which the auction must start. This ensures that the process is both cost-effective and timely</li> <li>Auction - the auction begins on the Solana network when a user requests a Fast Tansfer. Solvers monitor the network for these requests and initiate an auction by placing an offer to fulfill the transfer at or below the user\u2019s specified maximum fee. To start the auction, the solver must transfer the amount of USDC requested by the user (X USDC) plus a small security deposit to the Fast Transfer hub on Solana. This deposit acts as a commitment to the process</li> <li>Competition - once the auction is initiated, other solvers can participate by submitting lower bids in a reverse Dutch auction. The goal is to provide end users with the best possible rate. If a new solver submits a better offer, the previous solver\u2019s funds (X USDC and the security deposit) are returned, and the new offer takes precedence. This competitive process ensures that users receive the best possible transfer rate </li> <li>Fulfillment - the winning solver must complete the transfer within a predefined grace period to earn their fee and security deposit back. If they fail to do so, their security deposit may be slashed, and the slashed amount is given to the user as compensation for any delays. This incentive mechanism rewards prompt execution. Upon successful completion, the Fast Transfer hub sends the X USDC to the user\u2019s destination wallet, and the solver receives their security deposit back along with the fee for the transfer</li> <li>Settle auction - after the user\u2019s original transfer reaches finality on the source chain, the winning solver can use the finalized Wormhole message to settle the auction with the Fast Transfer hub. This allows the solver to retrieve the original transfer amount (X USDC) back into their wallet</li> </ol> <p>In summary, the auction mechanism ensures competitive pricing and efficient execution by leveraging a marketplace of solvers. The user benefits from lower costs and faster transfers, while solvers can earn fees by participating in the auction and completing transfers promptly.</p>"},{"location":"learn/messaging/fast-transfers/#risk-management","title":"Risk Management","text":"<p>The auction mechanism incorporates several risk management features to ensure reliability and protect both users and solvers:</p> <ul> <li>Security deposit - the security deposit is a small amount of USDC that solvers must provide when initiating an auction. This deposit serves as a commitment to fulfill the transfer and is returned upon successful completion</li> <li>Slashing conditions - if the winning solver fails to complete the transfer within the grace period, their security deposit may be slashed. This slashed amount is awarded to the user as compensation for any delay, serving as an incentive for solvers to act quickly and reliably</li> <li>Ensuring prompt execution and reliability - the competitive nature of the auction, combined with the risk of losing the security deposit, ensures that solvers are motivated to fulfill transfers promptly. This system helps maintain the overall efficiency and reliability of the Fast Transfers protocol</li> </ul> <p>This auction mechanism is crucial to the Fast Transfers protocol. It provides a robust, competitive environment that drives efficiency and cost-effectiveness in cross-chain transfers.</p>"},{"location":"learn/messaging/fast-transfers/#solvers","title":"Solvers","text":"<p>Solvers are key participants in the Fast Transfers protocol, ensuring liquidity's smooth and efficient movement across different blockchain networks. These entities facilitate cross-chain transfers by providing the necessary liquidity and participating in the auction mechanism that drives the process. Solvers perform several critical functions that are essential to the protocol\u2019s operation:</p> <ul> <li>Liquidity provision - Solvers manage and supply the liquidity needed to execute cross-chain transfers. Concentrating liquidity on the hub chain (Solana) ensures that assets can be quickly and efficiently transferred to the destination chain. This centralization of liquidity helps streamline the transfer process and reduces the complexity of managing assets across multiple chains</li> <li>Auction participation and management - Solvers actively engage in the auction mechanism. When a user initiates a fast transfer, solvers monitor the network for these requests and start the auction by placing a bid. This bid includes the transfer amount plus a security deposit, which acts as a commitment to complete the transfer. During the auction, solvers compete in a reverse Dutch auction, offering progressively lower fees to secure the transaction. Their participation ensures that users receive the most competitive rates while maintaining the efficiency and speed of the process</li> <li>Transaction execution and settlement - once a solver wins an auction, they are responsible for executing the transfer within a specified grace period. This involves swapping the necessary assets and ensuring the user\u2019s destination wallet receives the correct tokens. After the initial transfer reaches finality on the source chain, the solver settles the auction by retrieving their funds and receiving any applicable fees</li> </ul> <p>Solvers are the backbone of the Fast Transfers protocol. Their roles in providing liquidity, participating in auctions, and managing transactions are crucial to enabling fast, reliable, and cost-effective cross-chain transfers. By ensuring liquidity is always available where it\u2019s needed, solvers help maintain the overall efficiency and reliability of the Fast Transfers process.</p>"},{"location":"learn/messaging/fast-transfers/#benefits-for-solvers","title":"Benefits for Solvers","text":"<p>Participating in the Fast Transfers protocol offers several advantages for solvers:</p> <ul> <li>Capital efficiency - the hub-and-spoke model used by Fast Transfers allows solvers to concentrate their liquidity on a single hub chain (Solana) rather than spreading it across multiple chains and assets. This consolidation simplifies liquidity management, reduces the need for complex rebalancing, and increases the fees earned per dollar of liquidity</li> <li>Simplified risk and reward structure - since USDC is the exclusive settlement asset for the Fast Transfers protocol, solvers are insulated from the risks associated with volatile assets. The primary risk solvers need to consider is the finality risk of the source chain transaction. This straightforward risk assessment simplifies the bidding process and makes participation more attractive</li> <li>New revenue streams - by facilitating fast transfers, solvers can earn fees on each transfer they process. This creates a new source of income and allows solvers to capitalize on the growing volume of cross-chain transfers. Given Wormhole's track record of enabling billions of dollars in cross-chain asset transfers, solvers can expect significant opportunities to generate revenue</li> </ul>"},{"location":"learn/messaging/gateway/","title":"Wormhole Gateway in Cosmos","text":""},{"location":"learn/messaging/gateway/#introduction","title":"Introduction","text":"<p>The Wormhole Gateway, a Cosmos-SDK chain, plays a critical role in the Cosmos ecosystem by bridging non-native assets from several blockchain networks. This integration enhances the interoperability and liquidity of the Cosmos chains, thereby improving the functionality and accessibility of decentralized applications (dApps). By leveraging the Inter-Blockchain Communication (IBC) protocol, the Gateway facilitates secure and efficient cross-chain communication and asset transfers. </p> <p>The Gateway's primary function is to unify liquidity within the Cosmos network, which is essential for the seamless operation of dApps. Additionally, its integration with the Global Accountant ensures accurate asset tracking and balances, reinforcing the integrity of cross-chain transactions.</p> <p>This guide details the core components of the Gateway, outlines the message flow within the Gateway, and explains how the IBC protocol is integrated throughout these processes.</p>"},{"location":"learn/messaging/gateway/#cross-chain-transaction-flow","title":"Cross-Chain Transaction Flow","text":"<p>The following flow outlines the key steps involved in a cross-chain transaction within the Wormhole network, emphasizing the critical role of the Wormhole Gateway in facilitating secure and seamless communication between non-Cosmos chains and the Cosmos ecosystem.</p> <ol> <li>Message emission on source chain - a transaction triggers a message on the source chain, captured by the Wormhole Core Contract</li> <li>Guardian Network validation - the Guardian Network validates the message and creates a Verifiable Action Approval (VAA)</li> <li>VAA relayed to IBC relayer - if the target is a Cosmos chain, the VAA is relayed to an IBC relayer, which is responsible for securely transmitting the VAA to the Wormhole Gateway</li> <li>Gateway processes the VAA - the Gateway receives the VAA from the IBC relayer and processes it using the IBC Shim Contract, ensuring the VAA is correctly formatted to an IBC-compatible message and securely transmitted to the target Cosmos chain, ensuring interoperability and consistent asset handling within the Cosmos network</li> <li>Finalization on target Cosmos chain - the VAA is verified on the target Cosmos chain, enabling the execution of the corresponding transaction or operation</li> <li>Global Accountant integration - throughout the process, the Gateway works with the Global Accountant to maintain accurate asset tracking, ensuring the integrity of cross-chain transactions</li> </ol>"},{"location":"learn/messaging/gateway/#inter-blockchain-communication-ibc","title":"Inter-Blockchain Communication (IBC)","text":"<p>The Wormhole Gateway employs the Inter-Blockchain Communication (IBC) protocol to ensure secure and uninterrupted asset transfers across different blockchains. IBC is essential for maintaining consistent liquidity and removing the typical barriers associated with cross-chain transfers.</p> <p>IBC is central to the Wormhole Gateway's functionality, enabling seamless data and message transfers across blockchain networks. It reduces operational complexity and costs, ensuring the Gateway operates efficiently within the Cosmos ecosystem. By allowing the Gateway to interact smoothly with various blockchain protocols, IBC provides a robust framework for:</p> <ul> <li>Asset bridging - facilitating the conversion and transfer of assets between disparate blockchain systems, thereby broadening their usability and application</li> <li>Security and integrity - conducting thorough consistency checks to validate transactions and ensure that asset transfers are executed without discrepancies</li> </ul> <p>Several key components support the Wormhole Gateway's operations:</p> <ul> <li>Wormhole Core Contracts - deployed on each participating Cosmos chain, these contracts are crucial for managing the cross-chain communication, including the emission of messages and the verification of signatures from the network\u2019s Guardians</li> <li>IBC Shim Contract - a specialized CosmWasm contract that handles the bridging of assets by translating between the native Wormhole message formats and those used by IBC, effectively linking the Wormhole platform with the broader Cosmos ecosystem</li> <li>Token Factory Module - this module, operational on the Wormhole Gateway, is instrumental in creating tokens that represent bridged assets, facilitating their circulation within the Cosmos network</li> <li>Token Bridge - if an IBC-enabled chain already has a Wormhole Core Contract, the existing contract can be migrated to the new <code>wormhole-ibc</code> bytecode, eliminating the need to redeploy and re-instantiate Token Bridge contracts. This streamlines the integration process and ensures compatibility with the IBC framework</li> <li>IBC Composability Middleware - built on top of the Packet Forwarding Module (PFM) and IBC Hooks middleware, it integrates their functionalities seamlessly. This middleware enables integrators on Cosmos chains to support both inter-Cosmos and Cosmos-to-external flows using a unified payload structure</li> </ul>"},{"location":"learn/messaging/gateway/#scaling-with-ibc","title":"Scaling with IBC","text":""},{"location":"learn/messaging/gateway/#operational-challenges","title":"Operational Challenges","text":"<p>Traditionally, Wormhole Guardians have had to operate full nodes for each blockchain connected to Wormhole. This requirement ensures the highest levels of security and decentralization by allowing each Guardian to verify messages independently. However, this approach introduces significant operational costs and complexities, presenting a challenge to Wormhole's scalability as more chains are added to the network.</p> <p>To address these challenges, Wormhole has adopted IBC to facilitate message verification through Tendermint light clients. This method significantly reduces the burden on Guardians, as IBC enables the trustless verification of messages across chains.</p>"},{"location":"learn/messaging/gateway/#optimizing-guardian-operations","title":"Optimizing Guardian Operations","text":"<p>With the implementation of IBC, Guardians now primarily need to run a full node only for the Gateway. This adaptation allows Wormhole messages from any IBC-enabled chain to be passed to the Gateway via IBC. Once received, the Gateway then emits these messages to the Guardians. This streamlined approach reduces the necessity for Guardians to run multiple full nodes, instead relying on the light client functionality of IBC to verify the authenticity of cross-chain messages efficiently.</p>"},{"location":"learn/messaging/gateway/#benefits-and-impact","title":"Benefits and Impact","text":"<p>This strategic use of IBC lowers the operational cost and complexity of adding new chains and enhances the Wormhole network's scalability. Guardians can now support an expanded number of IBC-enabled chains without the proportional increase in resource allocation typically required. This adjustment allows Wormhole to maintain its commitment to security and decentralization while embracing the growth and dynamic nature of the blockchain ecosystem.</p> <p>By leveraging IBC, Wormhole significantly optimizes its infrastructure, facilitating easier scaling and reducing the operational demands on its Guardians. This adaptation ensures that Wormhole remains a robust and versatile bridge within the Cosmos ecosystem, capable of supporting a wide range of blockchains with enhanced efficiency and reduced overhead.</p>"},{"location":"learn/messaging/gateway/#fee-model","title":"Fee Model","text":"<p>Fees to use the Wormhole Gateway are minimal and are designed to be as low as possible to facilitate easy and efficient cross-chain transactions.</p> <p>Required fees: </p> <ul> <li>Source chain gas - users must cover gas fees on the source chain, such as Ethereum, to initiate transfers</li> <li>Relayer fee (source chain to Gateway) - there is currently no cost for processing Wormhole messages from the source chain to the Gateway, although this may change in the future</li> <li>Destination chain gas (non-Cosmos) - for non-Cosmos destination chains, gas fees must be paid by the relayer or the user in cases of manual redemption</li> </ul> <p>Optional fees: </p> <ul> <li>Gateway operations - the Gateway itself doesn't require gas fees to be paid by users, nor does it have token-priced metering</li> <li>Relayer fee (Gateway to Cosmos) - there are no relayer fees charged for transferring messages from the Gateway to Cosmos chains</li> <li>Destination chain (Cosmos) - IBC relayers cover costs on the destination chain within the Cosmos network</li> </ul>"},{"location":"learn/messaging/token-nft-bridge/","title":"Token and NFT Bridge","text":""},{"location":"learn/messaging/token-nft-bridge/#token-bridge","title":"Token Bridge","text":"<p>Note</p> <p>Before a token transfer can be made, the token being transferred must exist as a wrapped asset on the target chain. This is done by Attesting the token details on the target chain.</p> <p>The Token Bridge contract allows token transfers between blockchains through a lock and mint mechanism, using the Core Contract with a specific payload to pass information about the transfer. </p> <p>The Token Bridge also supports sending tokens with some additional data in the form of arbitrary byte payload attached to the token transfer. This type of transfer is referred to as a Contract Controlled Transfer.</p> <p>While the Core Contract has no specific receiver by default, transfers sent through the Token Bridge do have a specific receiver chain and address to ensure the tokens are minted to the expected recipient.</p>"},{"location":"learn/messaging/token-nft-bridge/#nft-bridge","title":"NFT Bridge","text":"<p>The NFT Bridge functions similarly to the Token Bridge but with special rules for what may be transferred and how the wrapped version is created on the destination chain.</p>"},{"location":"learn/messaging/native-token-transfers/","title":"Native Token Transfers","text":""},{"location":"learn/messaging/native-token-transfers/#get-started","title":"Get Started","text":"<p>This section covers Wormhole's Native Token Transfers (NTT), an open source, flexible, and composable framework for transferring tokens across blockchains.</p> <ul> <li> <p> Overview</p> <p>Dive into an introduction to NTT and discover what NTT is, what its key features are, and the available integration paths.</p> <p> Learn more about NTT</p> </li> <li> <p> Architecture</p> <p>Explore NTT's architecture to understand its core components and how they work together to manage cross-chain communication.</p> <p> Discover how NTT works</p> </li> <li> <p> Deployment models</p> <p>The NTT framework offers two deployment models for different token management needs: the hub-and-spoke and burn-and-mint models.</p> <p> Check out the deployment models</p> </li> <li> <p> Security</p> <p>Explore NTT's security measures, including the Global Accountant and governance strategies for seamless token safety.</p> <p> Review the security measures</p> </li> </ul>"},{"location":"learn/messaging/native-token-transfers/architecture/","title":"Native Token Transfers Architecture","text":""},{"location":"learn/messaging/native-token-transfers/architecture/#introduction","title":"Introduction","text":"<p>The Native Token Transfers (NTT) architecture within the Wormhole ecosystem offers a robust framework for secure and efficient token transfers across multiple blockchains. This architecture relies on the manager and transceiver core components that work together to manage cross-chain communication and token operations complexities.</p>"},{"location":"learn/messaging/native-token-transfers/architecture/#system-components","title":"System Components","text":"<p>The NTT framework is composed of Managers, which oversee the transfer process, and transceivers, which handle cross-chain messaging, ensuring smooth and reliable token transfers.</p>"},{"location":"learn/messaging/native-token-transfers/architecture/#managers","title":"Managers","text":"<p>Managers oversee the token transfer process and handle rate-limiting and message attestation. They manage interactions with multiple transceivers and ensure that tokens are locked or burned on the source chain before being minted or unlocked on the destination chain. Each NTT manager corresponds to a single token but can control multiple transceivers. Key functions include:</p> <ul> <li><code>transfer</code> - initiates a token transfer process involving token locking or burning on the source chain</li> <li><code>quoteDeliveryPrice</code> - quotes the fee for delivering a message to a specific target chain by querying and aggregating quotes from the transceiver contracts</li> <li><code>setPeer</code> - establishes trust between different instances of NTT manager contracts across chains by cross-registering them as peers, ensuring secure communication</li> </ul>"},{"location":"learn/messaging/native-token-transfers/architecture/#transceivers","title":"Transceivers","text":"<p>Transceivers are responsible for routing NTT transfers through the manager on the source chain and ensuring they are delivered to the corresponding manager on the recipient chain. They work with Managers to ensure that messages are accurately processed and tokens are correctly transferred, providing a reliable system for cross-chain token transfers. Transceivers can be defined independently of the Wormhole core and modified to support any verification backend. Key functions:</p> <ul> <li><code>sendMessage</code> - this external function sends messages to a specified recipient chain. It encodes the token transfer details into a message format recognized by the system</li> <li><code>quoteDeliveryPrice</code> - provides an estimation of the cost associated with delivering a message to a target chain and gauges transaction fees</li> </ul> <p></p> <p>Note</p> <p>Learn more about the architecture of Native Token Transfers message lifecycles.</p>"},{"location":"learn/messaging/native-token-transfers/architecture/#custom-transceivers","title":"Custom Transceivers","text":"<p>The NTT framework supports advanced features such as custom transceivers for specialized message verification, enhancing security and adaptability. The architecture includes detailed processes for initiating transfers, managing rate limits, and finalizing token operations, with specific instructions and events outlined for EVM-compatible chains and Solana.</p> <p>NTT has the flexibility to support custom message verification in addition to Wormhole Guardian message verification. Custom verifiers are implemented as transceiver contracts and can be protocol-specific or provided by other third-party attesters. Protocols can also configure the threshold of attestations required to mark a token transfer as valid \u2014 for example, 2/2, 2/3, 3/5.</p> <p></p> <p>The verifier performs checks based on predefined criteria and issues approval for transactions that meet these requirements. This approval is incorporated into the Wormhole message, ensuring that only transactions verified by both the Wormhole Guardian Network and the additional verifier are processed. The model includes an extra verifier in the bridging process, enhancing security and providing an added assurance of transaction integrity.</p> <p>For more details, to collaborate, or to see examples of custom transceivers, contact Wormhole contributors.</p>"},{"location":"learn/messaging/native-token-transfers/architecture/#lifecycle-of-a-message","title":"Lifecycle of a Message","text":""},{"location":"learn/messaging/native-token-transfers/architecture/#evm","title":"EVM","text":""},{"location":"learn/messaging/native-token-transfers/architecture/#transfer","title":"Transfer","text":"<p>A client calls on <code>transfer</code> to initiate an NTT transfer. The client must specify, at minimum, the transfer amount, the recipient chain, and the recipient address on the recipient chain. <code>transfer</code> also supports a flag to specify whether the <code>NttManager</code> should queue rate-limited transfers or revert. Clients can also include additional instructions to forward along to the transceiver on the source chain. Depending on the mode set in the initial configuration of the <code>NttManager</code> contract, transfers are either \"locked\" or \"burned.\" Once the transfer has been forwarded to the transceiver, the <code>NttManager</code> emits the <code>TransferSent</code> event.</p> <p>Events</p> <pre><code>/// @notice Emitted when a message is sent from the nttManager.\n/// @dev Topic0\n/// 0x9716fe52fe4e02cf924ae28f19f5748ef59877c6496041b986fbad3dae6a8ecf\n/// @param recipient The recipient of the message.\n/// @param amount The amount transferred.\n/// @param fee The amount of ether sent along with the tx to cover the delivery fee.\n/// @param recipientChain The chain ID of the recipient.\n/// @param msgSequence The unique sequence ID of the message.\nevent TransferSent(\n    bytes32 recipient, uint256 amount, uint256 fee, uint16 recipientChain, uint64 msgSequence\n);\n</code></pre>"},{"location":"learn/messaging/native-token-transfers/architecture/#rate-limit","title":"Rate Limit","text":"<p>A transfer can be rate-limited on both the source and destination chains. If a transfer is rate-limited on the source chain and the <code>shouldQueue</code> flag is enabled, it is added to an outbound queue. The transfer can be released after the configured <code>_rateLimitDuration</code> has expired via the <code>completeOutboundQueuedTransfer</code> method. The <code>OutboundTransferQueued</code> and <code>OutboundTransferRateLimited</code> events are emitted.</p> <p>If the client attempts to release the transfer from the queue before the expiry of the <code>rateLimitDuration</code>, the contract reverts with an <code>OutboundQueuedTransferStillQueued</code> error.</p> <p>Similarly, rate-limited transfers on the destination chain are added to an inbound queue. These transfers can be released from the queue via the <code>completeInboundQueuedTransfer</code> method, and the <code>InboundTransferQueued</code> event is emitted.</p> <p>If the client attempts to release the transfer from the queue before the <code>rateLimitDuration</code> expires, the contract reverts with an <code>InboundQueuedTransferStillQueued</code> error.</p> <p>To deactivate the rate limiter, set <code>_rateLimitDuration</code> to 0 and enable the <code>_skipRateLimiting</code> field in the <code>NttManager</code> constructor. Configuring this incorrectly will throw an error. If the rate limiter is deactivated, the inbound and outbound rate limits can be set to 0.</p> <p>Events</p> <pre><code>/// @notice Emitted whenn an outbound transfer is queued.\n/// @dev Topic0\n/// 0x69add1952a6a6b9cb86f04d05f0cb605cbb469a50ae916139d34495a9991481f.\n/// @param queueSequence The location of the transfer in the queue.\nevent OutboundTransferQueued(uint64 queueSequence);\n</code></pre> <pre><code>/// @notice Emitted when an outbound transfer is rate limited.\n/// @dev Topic0\n/// 0x754d657d1363ee47d967b415652b739bfe96d5729ccf2f26625dcdbc147db68b.\n/// @param sender The initial sender of the transfer.\n/// @param amount The amount to be transferred.\n/// @param currentCapacity The capacity left for transfers within the 24-hour window.\nevent OutboundTransferRateLimited(\n    address indexed sender, uint64 sequence, uint256 amount, uint256 currentCapacity\n);\n</code></pre> <pre><code>/// @notice Emitted when an inbound transfer is queued\n/// @dev Topic0\n/// 0x7f63c9251d82a933210c2b6d0b0f116252c3c116788120e64e8e8215df6f3162.\n/// @param digest The digest of the message.\nevent InboundTransferQueued(bytes32 digest);\n</code></pre>"},{"location":"learn/messaging/native-token-transfers/architecture/#send","title":"Send","text":"<p>Once the <code>NttManager</code> forwards the message to the transceiver, the message is transmitted via the <code>sendMessage method</code>. The method signature is enforced by the transceiver but transceivers are free to determine their own implementation for transmitting messages. (e.g. a message routed through the Wormhole transceiver can be sent via Wormhole relaying, a custom relayer, or manually published via the core bridge).</p> <p>Once the message has been transmitted, the contract emits the <code>SendTransceiverMessage</code> event.</p> <p>Events</p> <pre><code>/// @notice Emitted when a message is sent from the transceiver.\n/// @dev Topic0\n/// 0x53b3e029c5ead7bffc739118953883859d30b1aaa086e0dca4d0a1c99cd9c3f5.\n/// @param recipientChain The chain ID of the recipient.\n/// @param message The message.\nevent SendTransceiverMessage(\n    uint16 recipientChain, TransceiverStructs.TransceiverMessage message\n);\n</code></pre>"},{"location":"learn/messaging/native-token-transfers/architecture/#receive","title":"Receive","text":"<p>Once a message has been emitted by a transceiver on the source chain, an off-chain process (for example, a relayer) will forward the message to the corresponding transceiver on the recipient chain. The relayer interacts with the transceiver via an entry point to receive messages. For example, the relayer will call the <code>receiveWormholeMessage</code> method on the <code>WormholeTransceiver</code> contract to execute the message. The <code>ReceiveRelayedMessage</code> event is emitted during this process.</p> <p>This method should also forward the message to the <code>NttManager</code> on the destination chain. Note that the transceiver interface doesn't declare a signature for this method because receiving messages is specific to each transceiver, and a one-size-fits-all solution would be overly restrictive.</p> <p>The <code>NttManager</code> contract allows an M of N threshold for transceiver attestations to determine whether a message can be safely executed. For example, if the threshold requirement is 1, the message will be executed after a single transceiver delivers a valid attestation. If the threshold requirement is 2, the message will only be executed after two transceivers deliver valid attestations. When a transceiver attests to a message, the contract emits the <code>MessageAttestedTo</code> event.</p> <p>NTT implements replay protection, so if a given transceiver attempts to deliver a message attestation twice, the contract reverts with <code>TransceiverAlreadyAttestedToMessage</code> error. NTT also implements replay protection against re-executing messages. This check also acts as reentrancy protection as well.</p> <p>If a message has already been executed, the contract ends execution early and emits the <code>MessageAlreadyExecuted</code> event instead of reverting via an error. This mitigates the possibility of race conditions from transceivers attempting to deliver the same message when the threshold is less than the total number of available of transceivers (i.e. threshold &lt; totalTransceivers) and notifies the client (off-chain process) so they don't attempt redundant message delivery.</p> <p>Events</p> <pre><code>/// @notice Emitted when a relayed message is received.\n/// @dev Topic0\n/// 0xf557dbbb087662f52c815f6c7ee350628a37a51eae9608ff840d996b65f87475\n/// @param digest The digest of the message.\n/// @param emitterChainId The chain ID of the emitter.\n/// @param emitterAddress The address of the emitter.\nevent ReceivedRelayedMessage(bytes32 digest, uint16 emitterChainId, bytes32 emitterAddress);\n</code></pre> <pre><code>/// @notice Emitted when a message is received.\n/// @dev Topic0\n/// 0xf6fc529540981400dc64edf649eb5e2e0eb5812a27f8c81bac2c1d317e71a5f0.\n/// @param digest The digest of the message.\n/// @param emitterChainId The chain ID of the emitter.\n/// @param emitterAddress The address of the emitter.\n/// @param sequence The sequence of the message.\nevent ReceivedMessage(\n    bytes32 digest, uint16 emitterChainId, bytes32 emitterAddress, uint64 sequence\n);\n</code></pre> <pre><code>/// @notice Emitted when a message has already been executed to notify client of against retries.\n/// @dev Topic0\n/// 0x4069dff8c9df7e38d2867c0910bd96fd61787695e5380281148c04932d02bef2.\n/// @param sourceNttManager The address of the source nttManager.\n/// @param msgHash The keccak-256 hash of the message.\nevent MessageAlreadyExecuted(bytes32 indexed sourceNttManager, bytes32 indexed msgHash);\n</code></pre>"},{"location":"learn/messaging/native-token-transfers/architecture/#mint-or-unlock","title":"Mint or Unlock","text":"<p>Once a transfer has been successfully verified, the tokens can be minted (if the mode is \"burning\") or unlocked (if the mode is \"locking\") to the recipient on the destination chain. Note that the source token decimals are bounded between <code>0</code> and <code>TRIMMED_DECIMALS</code> as enforced in the wire format. The transfer amount is untrimmed (scaled-up) if the destination chain token decimals exceed <code>TRIMMED_DECIMALS</code>. Once the appropriate number of tokens have been minted or unlocked to the recipient, the <code>TransferRedeemed</code> event is emitted.</p> <p>Events</p> <pre><code>/// @notice Emitted when a transfer has been redeemed\n/// (either minted or unlocked on the recipient chain).\n/// @dev Topic0\n/// 0x504e6efe18ab9eed10dc6501a417f5b12a2f7f2b1593aed9b89f9bce3cf29a91.\n/// @param digest The digest of the message.\nevent TransferRedeemed(bytes32 indexed digest);\n</code></pre>"},{"location":"learn/messaging/native-token-transfers/architecture/#solana","title":"Solana","text":""},{"location":"learn/messaging/native-token-transfers/architecture/#transfer_1","title":"Transfer","text":"<p>A client calls the <code>transfer_lock</code> or <code>transfer_burn</code> instruction based on whether the program is in <code>LOCKING</code> or <code>BURNING</code> mode. The program mode is set during initialization. When transferring, the client must specify the amount of the transfer, the recipient chain, the recipient address on the recipient chain, and the boolean flag <code>should_queue</code> to specify whether the transfer should be queued if it hits the outbound rate limit. If <code>should_queue</code> is set to false, the transfer reverts instead of queuing if the rate limit were to be hit.</p> <p>Note</p> <p>Using the wrong transfer instruction, i.e. <code>transfer_lock</code> for a program that is in <code>BURNING</code> mode, will result in an <code>InvalidMode</code> error.</p> <p>Depending on the mode and instruction, the following will be produced in the program logs:</p> <pre><code>Program log: Instruction: TransferLock\nProgram log: Instruction: TransferBurn\n</code></pre> <p>Outbound transfers are always added to an Outbox via the <code>insert_into_outbox</code> method. This method checks the transfer against the configured outbound rate limit amount to determine whether the transfer should be rate-limited. An <code>OutboxItem</code> is a Solana Account that holds details of the outbound transfer. The transfer can be released from the Outbox immediately if no rate limit is hit. The transfer can be released from the Outbox immediately unless a rate limit is hit, in which case it will only be released after the delay duration associated with the rate limit has expired.</p>"},{"location":"learn/messaging/native-token-transfers/architecture/#rate-limit_1","title":"Rate Limit","text":"<p>During the transfer process, the program checks rate limits via the <code>consume_or_delay</code> function. The Solana rate-limiting logic is equivalent to the EVM rate-limiting logic.</p> <p>If the transfer amount fits within the current capacity:</p> <ul> <li>Reduce the current capacity</li> <li>Refill the inbound capacity for the destination chain</li> <li>Add the transfer to the Outbox with <code>release_timestamp</code> set to the current timestamp, so it can be released immediately.</li> </ul> <p>If the transfer amount doesn't fit within the current capacity:</p> <ul> <li>If <code>shouldQueue = true</code>, add the transfer to the Outbox with <code>release_timestamp</code> set to the current timestamp plus the configured <code>RATE_LIMIT_DURATION</code>.</li> <li>If <code>shouldQueue = false</code>, revert with a <code>TransferExceedsRateLimit</code> error</li> </ul>"},{"location":"learn/messaging/native-token-transfers/architecture/#send_1","title":"Send","text":"<p>The caller then needs to request each transceiver to send messages via the <code>release_outbound</code> instruction. To execute this instruction, the caller needs to pass the account of the Outbox item to be released. The instruction will then verify that the transceiver is one of the specified senders for the message. Transceivers then send the messages based on the verification backend they are using.</p> <p>For example, the Wormhole transceiver will send by calling <code>post_message</code> on the Wormhole program, so that the Wormhole Guardians can observe and verify the message.</p> <p>Note</p> <p>When <code>revert_on_delay</code> is true, the transaction will revert if the release timestamp hasn't been reached. When <code>revert_on_delay</code> is false, the transaction succeeds, but the outbound release isn't performed.</p> <p>The following will be produced in the program logs:</p> <pre><code>Program log: Instruction: ReleaseOutbound\n</code></pre>"},{"location":"learn/messaging/native-token-transfers/architecture/#receive_1","title":"Receive","text":"<p>Similar to EVM, transceivers vary in how they receive messages since message relaying and verification methods may differ between implementations.</p> <p>The Wormhole transceiver receives a verified Wormhole message on Solana via the <code>receive_message</code> entrypoint instruction. Callers can use the <code>receive_wormhole_message</code> Anchor library function to execute this instruction. The instruction verifies the Wormhole Verified Action Approvals (VAAs) and stores it in a <code>VerifiedTransceiverMessage</code> account.</p> <p>The following will be produced in the program logs:</p> <pre><code>Program log: Instruction: ReceiveMessage\n</code></pre> <p><code>redeem</code> checks the inbound rate limit and places the message in an Inbox. Logic works the same as the outbound rate limit mentioned previously.</p> <p>The following will be produced in the program logs:</p> <pre><code>Program log: Instruction: Redeem\n</code></pre>"},{"location":"learn/messaging/native-token-transfers/architecture/#mint-or-unlock_1","title":"Mint or Unlock","text":"<p>The inbound transfer is released and the tokens are unlocked or minted to the recipient through either <code>release_inbound_mint</code> if the mode is <code>BURNING</code>, or <code>release_inbound_unlock</code> if the mode is <code>LOCKING</code>. Similar to transfer, using the wrong transfer instruction (such as <code>release_inbound_mint</code> for a program that is in locking mode) will result in <code>InvalidMode</code> error.</p> <p>Note</p> <p>When <code>revert_on_delay</code> is true, the transaction will revert if the release timestamp hasn't been reached. When <code>revert_on_delay</code> is false, the transaction succeeds, but the minting/unlocking isn't performed.</p> <p>Depending on the mode and instruction, the following will be produced in the program logs:</p> <pre><code>Program log: Instruction: ReleaseInboundMint\nProgram log: Instruction: ReleaseInboundUnlock\n</code></pre>"},{"location":"learn/messaging/native-token-transfers/deployment/","title":"Deployment Models","text":"<p>The Wormhole framework offers two deployment models, each catering to different token management needs: the hub-and-spoke model and the burn-and-mint model. These models provide flexible solutions for both existing token deployments and new projects looking to enable secure and seamless multichain token transfers.</p>"},{"location":"learn/messaging/native-token-transfers/deployment/#hub-and-spoke","title":"Hub-and-Spoke","text":"<p>The hub-and-spoke model involves locking tokens on a central hub chain and minting them on destination spoke chains. This model maintains the total supply on the hub chain and is backward-compatible with any existing token deployment.</p> <p>This model is ideal for existing token deployments that don't want to alter existing token contracts. It maintains the canonical balance on a hub chain while allowing for secure native deployment to new blockchains.</p> <ul> <li>Hub chain - tokens are locked when initiating a transfer</li> <li>Spoke chains - Equivalent tokens are minted on the destination chain</li> </ul> <p>When transferring back to the original hub chain, tokens are burned on the source spoke chain and unlocked on the hub chain. When transferring between spoke chains, tokens are burned on the source spoke chain and minted on the destination spoke chain.</p>"},{"location":"learn/messaging/native-token-transfers/deployment/#burn-and-mint","title":"Burn-and-Mint","text":"<p>The burn-and-mint model involves burning tokens on the source chain and minting them on the destination chain. This results in a simplified multichain transfer process that distributes the total supply across multiple chains and produces a native multichain token.</p> <p>This model best suits new token deployments or projects willing to upgrade existing contracts.</p> <ul> <li>Source chain - tokens are burned when initiating a transfer</li> <li>Destination chain - equivalent tokens are minted on the destination chain</li> </ul>"},{"location":"learn/messaging/native-token-transfers/overview/","title":"Native Token Transfers","text":""},{"location":"learn/messaging/native-token-transfers/overview/#introduction","title":"Introduction","text":"<p>Wormhole's Native Token Transfers (NTT) is an open source, flexible, and composable framework for transferring tokens across blockchains. Integrators have complete control over how their tokens that use NTT behave on each chain, including the token standard, metadata, ownership, upgradeability, and custom features.</p> <p>The framework offers two modes of operation for existing token deployments. In locking mode, the original token supply is preserved on a single chain. In contrast, the burning mode enables the deployment of multichain tokens, distributing the supply across various chains.</p>"},{"location":"learn/messaging/native-token-transfers/overview/#key-features","title":"Key Features","text":"<p>Wormhole's Native Token Transfers (NTT) framework offers a comprehensive and flexible solution for seamless token transfers across blockchains. Below are some of the key features that make this framework stand out:</p> <ul> <li>Unified user experience - tokens retain their properties on each chain, remaining completely fungible and ensuring a consistent user experience</li> <li>No liquidity pools - transfer tokens without the need for liquidity pools, avoiding fees, slippage, and MEV risk</li> <li>Integrator flexibility - retained ownership, upgrade authority, and complete customizability over token contracts</li> <li>Advanced rate limiting - inbound and outbound rate limits are configurable per chain and over arbitrary periods, preventing abuse while managing network congestion and allowing for controlled deployments to new chains</li> <li>Global Accountant - ensures accounting integrity across chains by checking that the number of tokens burned and transferred out of a chain never exceeds the number of tokens minted</li> <li>Access control - to prevent unauthorized calls to administrative functions, protocols can choose to assign specific functions, such as the Pauser role, to a separate address from the owner</li> <li>Maximum composability - open source and extensible for widespread adoption and integration with other protocols</li> <li>Custom attestation - optionally add external verifiers and configure custom message attestation thresholds</li> </ul>"},{"location":"learn/messaging/native-token-transfers/overview/#integration-paths","title":"Integration Paths","text":"<p>Integrators looking to deploy their token to connected chains can use the NTT framework or the Token Bridge. Both options carry a distinct integration path and feature set depending on your requirements, as outlined in the following sections.</p>"},{"location":"learn/messaging/native-token-transfers/overview/#native-token-transfers-framework","title":"Native Token Transfers Framework","text":"<p>The Native Token Transfers Framework is highly customizable and ideal for applications such as a DeFi governance token deployed across multiple chains, which seeks to achieve fungible multichain liquidity and direct integration into governance processes.</p> <ul> <li>Mechanism - can entirely utilize a burn-and-mint mechanism or can be paired for a hub-and-spoke model</li> <li>Security - fully configurable rate limiting, pausing, access control, and threshold attestations. Integrated with the Global Accountant</li> <li>Contract ownership - retain ownership and upgrade authority of token contracts on each chain</li> <li>Token contracts - native contracts owned by your protocol governance</li> <li>Integration - streamlined, customizable framework allows for more sophisticated and bespoke deployments</li> </ul> <p>The following example projects demonstrate the use of the Wormhole NTT framework through Wormhole Connect and the TypeScript SDK:</p> <ul> <li>NTT Connect </li> <li>NTT TS SDK </li> </ul>"},{"location":"learn/messaging/native-token-transfers/overview/#token-bridge","title":"Token Bridge","text":"<p>The Token Bridge offers a secure, low-effort integration suitable for applications like a Web3 game that wants to make its token tradable across multiple chains.</p> <ul> <li>Mechanism - solely utilizes a lock and mint model</li> <li>Security - preconfigured rate limiting and integrated Global Accountant</li> <li>Contract ownership - Token Bridge contracts are upgradeable via Wormhole Governance</li> <li>Token contracts - wrapped asset contract owned by the Wormhole Token Bridge contract, upgradeable via a 13/19 Guardian governance process</li> <li>Integration - straightforward and permissionless method to deploy on multiple chains</li> </ul> <p>Note</p> <p>Learn more about the core messaging primitives in the Wormhole network. </p>"},{"location":"learn/messaging/native-token-transfers/security/","title":"Security","text":""},{"location":"learn/messaging/native-token-transfers/security/#global-accountant","title":"Global Accountant","text":"<p>The Global Accountant is a defense-in-depth security feature that performs integrity checks on every token transfer. This feature isolates chain balances, ensuring more tokens cannot be burned and transferred out of a chain than were ever minted.</p> <p>This CosmWasm-based module acts as a smart contract on Wormhole Gateway and ensures that native asset fungibility remains in 1:1 parity. At no time will assets coming from a spoke chain exceed the number of native assets sent to that spoke chain. Accounting is enforced transparently by Wormhole Guardians, who won't attest to a Native Token Transfer (NTT) if it violates checks.</p> <p>Contact Wormhole contributors if you are interested in having Global Accountant configured for your multichain deployment.</p>"},{"location":"learn/messaging/native-token-transfers/security/#governance-and-upgradeability","title":"Governance and Upgradeability","text":"<p>Integrators should implement governance mechanisms to manage the addition and removal of transceivers and to upgrade contracts using proxy patterns, as demonstrated in the upgrade functions in the <code>NttManager</code> contracts. These processes can also set thresholds and rules for attestation and message approval.</p> <p>The registry component of the NTT system is crucial for maintaining a trusted list of transceivers and managing their status. Governance processes for the following actions can be submitted directly to the corresponding contract on-chain, whether it is one or multiple of the bridging contracts or one of the token contracts:</p> <ul> <li>Adding or removing a transceiver address from the registry</li> <li>Setting the token contract address on a bridging contract</li> <li>Setting the Wormhole Core Contract address on a bridging contract</li> <li>Setting the registered bridging contract address on the token contract</li> </ul> <p>This governance model ensures that the system remains secure while being adaptable to new requirements in any environment where it is deployed.</p>"},{"location":"tutorials/","title":"Tutorials","text":""},{"location":"tutorials/#get-started","title":"Get Started","text":"<p>This section contains step-by-step guides to help you build with Wormhole.</p> <ul> <li> <p> Messaging</p> <p>Follow this guide to use Wormhole's cross-chain messaging infrastructure to simplify data transmission, event triggering, and transaction initiation, allowing smart contracts to interact seamlessly across multiple blockchains.</p> <p> Start building</p> </li> </ul>"},{"location":"tutorials/messaging/","title":"Messaging Tutorials","text":""},{"location":"tutorials/messaging/#get-started","title":"Get Started","text":"<p>Wormhole's cross-chain messaging infrastructure simplifies data transmission, event triggering, and transaction initiation, allowing smart contracts to interact seamlessly across multiple blockchains. The following sections include guides for building your own projects using Wormhole's cross-chain messaging capabilities.</p> <ul> <li> <p> Create Cross-Chain Contracts</p> <p>This tutorial guides you through building a fully functioning cross-chain message sender and receiver using Solidity, understanding how to interact with the Wormhole relayer, managing cross-chain costs, and configuring your smart contracts correctly on both source and target chains.</p> <p> Start building</p> </li> </ul>"},{"location":"tutorials/messaging/cross-chain-contracts/","title":"Create Cross-Chain Contracts","text":""},{"location":"tutorials/messaging/cross-chain-contracts/#introduction","title":"Introduction","text":"<p>Wormhole's cross-chain messaging allows smart contracts to interact seamlessly across multiple blockchains. This enables developers to build decentralized applications that leverage the strengths of different networks, whether it's Avalanche, Celo, Ethereum, or beyond. In this tutorial, we'll explore using Wormhole's Solidity SDK to create cross-chain contracts to send and receive messages across chains.</p> <p>Wormhole's messaging infrastructure simplifies data transmission, event triggering, and transaction initiation across blockchains. In this tutorial, we'll guide you through a simple yet powerful hands-on demonstration that showcases this practical capability. We'll deploy contracts on two TestNets\u2014Avalanche Fuji and Celo Alfajores\u2014and send messages from one chain to another. This tutorial is perfect for those new to cross-chain development and seeking hands-on experience with Wormhole's powerful toolkit.</p> <p>By the end of this tutorial, you will have not only built a fully functioning cross-chain message sender and receiver using Solidity but also developed a comprehensive understanding of how to interact with the Wormhole relayer, manage cross-chain costs, and ensure your smart contracts are configured correctly on both source and target chains.</p> <p>This tutorial assumes a basic understanding of Solidity and smart contract development. Before diving in, it may be helpful to review the basics of Wormhole to familiarize yourself with the protocol.</p>"},{"location":"tutorials/messaging/cross-chain-contracts/#wormhole-overview","title":"Wormhole Overview","text":"<p>We'll interact with two key Wormhole components: the Wormhole relayer and the Wormhole Core Contracts. The relayer handles cross-chain message delivery and ensures the message is accurately received on the target chain. This allows smart contracts to communicate across blockchains without developers worrying about the underlying complexity.</p> <p>Additionally, we'll rely on the Wormhole relayer to automatically determine cross-chain transaction costs and facilitate payments. This feature simplifies cross-chain development by allowing you to specify only the target chain and the message. The relayer handles the rest, ensuring that the message is transmitted with the appropriate fee.</p> <p></p>"},{"location":"tutorials/messaging/cross-chain-contracts/#prerequisites","title":"Prerequisites","text":"<p>Before starting this tutorial, ensure you have the following:</p> <ul> <li>Node.js and npm installed on your machine</li> <li>Foundry for deploying contracts</li> <li>TestNet tokens for Avalanche-Fuji and Celo-Alfajores to cover gas fees</li> <li>Wallet private key</li> </ul>"},{"location":"tutorials/messaging/cross-chain-contracts/#build-cross-chain-messaging-contracts","title":"Build Cross-Chain Messaging Contracts","text":"<p>In this section, we'll deploy two smart contracts: one to send a message from Avalanche Fuji and another to receive it on Celo Alfajores. The contracts interact with the Wormhole relayer to transmit messages across chains.</p> <p>At a high level, our contracts will:</p> <ol> <li>Send a message from Avalanche to Celo using the Wormhole relayer</li> <li>Receive and process the message on Celo, logging the content of the message</li> </ol> <p>Before diving into the deployment steps, let's first break down key parts of the contracts.</p>"},{"location":"tutorials/messaging/cross-chain-contracts/#sender-contract-messagesender","title":"Sender Contract: MessageSender","text":"<p>The <code>MessageSender</code> contract is responsible for quoting the cost of sending a message cross-chain and then sending that message. </p> <p>Key functions include:</p> <ul> <li><code>quoteCrossChainCost</code> - calculates the cost of delivering a message to the target chain using the Wormhole relayer</li> <li><code>sendMessage</code> - encodes the message and sends it to the target chain and contract address using the Wormhole relayer</li> </ul> <p>Here's the core of the contract:</p> <pre><code>    function sendMessage(\n        uint16 targetChain,\n        address targetAddress,\n        string memory message\n    ) external payable {\n        uint256 cost = quoteCrossChainCost(targetChain);\n\n        require(\n            msg.value &gt;= cost,\n            \"Insufficient funds for cross-chain delivery\"\n        );\n\n        wormholeRelayer.sendPayloadToEvm{value: cost}(\n            targetChain,\n            targetAddress,\n            abi.encode(message, msg.sender),\n            0,\n            GAS_LIMIT\n        );\n    }\n</code></pre> <p>You can find the full code for the <code>MessageSender.sol</code> below.</p> MessageSender.sol <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"lib/wormhole-solidity-sdk/src/interfaces/IWormholeRelayer.sol\";\n\ncontract MessageSender {\n    IWormholeRelayer public wormholeRelayer;\n    uint256 constant GAS_LIMIT = 50000;\n\n    constructor(address _wormholeRelayer) {\n        wormholeRelayer = IWormholeRelayer(_wormholeRelayer);\n    }\n\n    function quoteCrossChainCost(\n        uint16 targetChain\n    ) public view returns (uint256 cost) {\n        (cost, ) = wormholeRelayer.quoteEVMDeliveryPrice(\n            targetChain,\n            0,\n            GAS_LIMIT\n        );\n    }\n\n    function sendMessage(\n        uint16 targetChain,\n        address targetAddress,\n        string memory message\n    ) external payable {\n        uint256 cost = quoteCrossChainCost(targetChain);\n\n        require(\n            msg.value &gt;= cost,\n            \"Insufficient funds for cross-chain delivery\"\n        );\n\n        wormholeRelayer.sendPayloadToEvm{value: cost}(\n            targetChain,\n            targetAddress,\n            abi.encode(message, msg.sender),\n            0,\n            GAS_LIMIT\n        );\n    }\n}\n</code></pre>"},{"location":"tutorials/messaging/cross-chain-contracts/#receiver-contract-messagereceiver","title":"Receiver Contract: MessageReceiver","text":"<p>The <code>MessageReceiver</code> contract handles incoming cross-chain messages. When a message arrives, it decodes the payload and logs the message content. It ensures that only authorized contracts can send and process messages, adding an extra layer of security in cross-chain communication.</p>"},{"location":"tutorials/messaging/cross-chain-contracts/#emitter-validation-and-registration","title":"Emitter Validation and Registration","text":"<p>In cross-chain messaging, validating the sender is essential to prevent unauthorized contracts from sending messages. The <code>isRegisteredSender</code> modifier ensures that messages can only be processed if they come from the registered contract on the source chain. This guards against malicious messages and enhances security.</p> <p>Key implementation details include:</p> <ul> <li><code>registeredSender</code> - stores the address of the registered sender contract</li> <li><code>setRegisteredSender</code> - registers the sender's contract address on the source chain. It ensures that only registered contracts can send messages, preventing unauthorized senders</li> <li><code>isRegisteredSender</code> - restricts the processing of messages to only those from registered senders, preventing unauthorized cross-chain communication</li> </ul> <pre><code>    mapping(uint16 =&gt; bytes32) public registeredSenders;\n\n    modifier isRegisteredSender(uint16 sourceChain, bytes32 sourceAddress) {\n        require(\n            registeredSenders[sourceChain] == sourceAddress,\n            \"Not registered sender\"\n        );\n        _;\n    }\n\n    function setRegisteredSender(\n        uint16 sourceChain,\n        bytes32 sourceAddress\n    ) public {\n        require(\n            msg.sender == registrationOwner,\n            \"Not allowed to set registered sender\"\n        );\n        registeredSenders[sourceChain] = sourceAddress;\n    }\n</code></pre>"},{"location":"tutorials/messaging/cross-chain-contracts/#message-processing","title":"Message Processing","text":"<p>The <code>receiveWormholeMessages</code> is the core function that processes the received message. It checks that the Wormhole relayer sent the message, decodes the payload, and emits an event with the message content. It is essential to verify the message sender to prevent unauthorized messages.</p> <pre><code>    function receiveWormholeMessages(\n        bytes memory payload,\n        bytes[] memory,\n        bytes32 sourceAddress,\n        uint16 sourceChain,\n        bytes32\n    ) public payable override isRegisteredSender(sourceChain, sourceAddress) {\n        require(\n            msg.sender == address(wormholeRelayer),\n            \"Only the Wormhole relayer can call this function\"\n        );\n\n        // Decode the payload to extract the message\n        string memory message = abi.decode(payload, (string));\n\n        // Example use of sourceChain for logging\n        if (sourceChain != 0) {\n            emit SourceChainLogged(sourceChain);\n        }\n\n        // Emit an event with the received message\n        emit MessageReceived(message);\n    }\n</code></pre> <p>You can find the full code for the <code>MessageReceiver.sol</code> below.</p> MessageReceiver.sol <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"lib/wormhole-solidity-sdk/src/interfaces/IWormholeRelayer.sol\";\nimport \"lib/wormhole-solidity-sdk/src/interfaces/IWormholeReceiver.sol\";\n\ncontract MessageReceiver is IWormholeReceiver {\n    IWormholeRelayer public wormholeRelayer;\n    address public registrationOwner;\n\n    // Mapping to store registered senders for each chain\n    mapping(uint16 =&gt; bytes32) public registeredSenders;\n\n    event MessageReceived(string message);\n    event SourceChainLogged(uint16 sourceChain);\n\n    constructor(address _wormholeRelayer) {\n        wormholeRelayer = IWormholeRelayer(_wormholeRelayer);\n        registrationOwner = msg.sender; // Set contract deployer as the owner\n    }\n\n    modifier isRegisteredSender(uint16 sourceChain, bytes32 sourceAddress) {\n        require(\n            registeredSenders[sourceChain] == sourceAddress,\n            \"Not registered sender\"\n        );\n        _;\n    }\n\n    function setRegisteredSender(\n        uint16 sourceChain,\n        bytes32 sourceAddress\n    ) public {\n        require(\n            msg.sender == registrationOwner,\n            \"Not allowed to set registered sender\"\n        );\n        registeredSenders[sourceChain] = sourceAddress;\n    }\n\n    // Update receiveWormholeMessages to include the source address check\n    function receiveWormholeMessages(\n        bytes memory payload,\n        bytes[] memory,\n        bytes32 sourceAddress,\n        uint16 sourceChain,\n        bytes32\n    ) public payable override isRegisteredSender(sourceChain, sourceAddress) {\n        require(\n            msg.sender == address(wormholeRelayer),\n            \"Only the Wormhole relayer can call this function\"\n        );\n\n        // Decode the payload to extract the message\n        string memory message = abi.decode(payload, (string));\n\n        // Example use of sourceChain for logging\n        if (sourceChain != 0) {\n            emit SourceChainLogged(sourceChain);\n        }\n\n        // Emit an event with the received message\n        emit MessageReceived(message);\n    }\n}\n</code></pre>"},{"location":"tutorials/messaging/cross-chain-contracts/#deploy-contracts","title":"Deploy Contracts","text":"<p>This section will guide you through deploying the cross-chain messaging contracts on the Avalanche Fuji and Celo Alfajores TestNets. Follow these steps to get your contracts up and running.</p>"},{"location":"tutorials/messaging/cross-chain-contracts/#deployment-tools","title":"Deployment Tools","text":"<p>We use Foundry to deploy our smart contracts. However, you can use any tool you're comfortable with, such as:</p> <ul> <li>Remix for a browser-based IDE</li> <li>Hardhat for a more extensive JavaScript/TypeScript workflow</li> <li>Foundry for a CLI-focused experience with built-in scripting and testing features</li> </ul> <p>The contracts and deployment steps remain the same regardless of your preferred tool. The key is to ensure you have the necessary TestNet funds and are deploying to the right networks.</p>"},{"location":"tutorials/messaging/cross-chain-contracts/#repository-setup","title":"Repository Setup","text":"<p>To get started with cross-chain messaging using Wormhole, first clone the GitHub repository. This repository includes everything you need to deploy, interact, and test the message flow between chains.</p> <p>This demo focuses on using the scripts, so it's best to take a look at them, starting with <code>deploySender.js</code>, <code>deployReceiver.js</code>, and <code>sendMessage.js</code>.</p> <p>To configure the dependencies properly, run the following command:</p> <pre><code>npm install\n</code></pre> <p>The repository includes:</p> <ul> <li> <p>Two Solidity contracts:</p> <ul> <li><code>MessageSender.sol</code> - contract that sends the cross-chain message from Avalanche</li> <li><code>MessageReceiver.sol</code> - contract that receives the cross-chain message on Celo</li> </ul> </li> <li> <p>Deployment scripts located in the <code>script</code> directory:</p> <ul> <li><code>deploySender.js</code> - deploys the MessageSender contract to Avalanche</li> <li><code>deployReceiver.js</code> - deploys the MessageReceiver contract to Celo</li> <li><code>sendMessage.js</code> - sends a message from Avalanche to Celo</li> </ul> </li> <li> <p>Configuration files and ABI JSON files for easy deployment and interaction:</p> <ul> <li><code>chains.json</code> - configuration file that stores key information for the supported TestNets, including the Wormhole relayer addresses, RPC URLs, and chain IDs. You likely won't need to modify this file unless you're working with different networks</li> </ul> </li> </ul>"},{"location":"tutorials/messaging/cross-chain-contracts/#important-setup-steps","title":"Important Setup Steps","text":"<ol> <li> <p>Add your private key - create a <code>.env</code> file in the root of the project and add your private key:</p> <pre><code>touch .env\n</code></pre> <p>Inside <code>.env</code>, add your private key in the following format:</p> <pre><code>PRIVATE_KEY=INSERT_PRIVATE_KEY\n</code></pre> </li> <li> <p>Compile the contracts - ensure everything is set up correctly by compiling the contracts:</p> <pre><code>forge build\n</code></pre> </li> </ol> <p>The expected output should be similar to this:</p> forge build  &gt; [\u2812] Compiling...  &gt; [\u2830] Compiling 30 files with 0.8.23  [\u2814] Solc 0.8.23 finished in 2.29s Compiler run successful!"},{"location":"tutorials/messaging/cross-chain-contracts/#deployment-process","title":"Deployment Process","text":"<p>Both deployment scripts, <code>deploySender.js</code> and <code>deployReceiver.js</code>, perform the following key tasks:</p> <ol> <li> <p>Load configuration and contract details - each script begins by loading the necessary configuration details, such as the network's RPC URL and the contract's ABI and bytecode. This information is essential for deploying the contract to the correct blockchain network</p> <code>chains.json</code><code>deploySender.js</code><code>deployReceiver.js</code> <pre><code>{\n    \"chains\": [\n        {\n            \"description\": \"Avalanche testnet fuji\",\n            \"chainId\": 6,\n            \"rpc\": \"https://api.avax-test.network/ext/bc/C/rpc\",\n            \"tokenBridge\": \"0x61E44E506Ca5659E6c0bba9b678586fA2d729756\",\n            \"wormholeRelayer\": \"0xA3cF45939bD6260bcFe3D66bc73d60f19e49a8BB\",\n            \"wormhole\": \"0x7bbcE28e64B3F8b84d876Ab298393c38ad7aac4C\"\n        },\n        {\n            \"description\": \"Celo Testnet\",\n            \"chainId\": 14,\n            \"rpc\": \"https://alfajores-forno.celo-testnet.org\",\n            \"tokenBridge\": \"0x05ca6037eC51F8b712eD2E6Fa72219FEaE74E153\",\n            \"wormholeRelayer\": \"0x306B68267Deb7c5DfCDa3619E22E9Ca39C374f84\",\n            \"wormhole\": \"0x88505117CA88e7dd2eC6EA1E13f0948db2D50D56\"\n        }\n    ]\n}\n</code></pre> <pre><code>  // Load the chain configuration from JSON\n  const chains = JSON.parse(\n    fs.readFileSync(path.resolve(__dirname, '../deploy-config/chains.json'))\n  );\n\n  // Get the Avalanche Fuji configuration\n  const avalancheChain = chains.chains.find((chain) =&gt;\n    chain.description.includes('Avalanche testnet')\n  );\n</code></pre> <pre><code>  // Load the chain configuration from the JSON file\n  const chains = JSON.parse(\n    fs.readFileSync(path.resolve(__dirname, '../deploy-config/chains.json'))\n  );\n\n  // Get the Celo Testnet configuration\n  const celoChain = chains.chains.find((chain) =&gt;\n    chain.description.includes('Celo Testnet')\n  );\n</code></pre> <p>Note</p> <p>The <code>chains.json</code> file contains the configuration details for the Avalanche Fuji and Celo Alfajores TestNets. You can modify this file to add more networks if needed.</p> </li> <li> <p>Set up provider and wallet - the scripts establish a connection to the blockchain using a provider and create a wallet instance using a private key. This wallet is responsible for signing the deployment transaction</p> <code>deploySender.js</code><code>deployReceiver.js</code> <pre><code>  const provider = new ethers.JsonRpcProvider(avalancheChain.rpc);\n  const wallet = new ethers.Wallet(process.env.PRIVATE_KEY, provider);\n</code></pre> <pre><code>  const provider = new ethers.JsonRpcProvider(celoChain.rpc);\n  const wallet = new ethers.Wallet(process.env.PRIVATE_KEY, provider);\n</code></pre> </li> <li> <p>Deploy the contract - the contract is deployed to the network specified in the configuration. Upon successful deployment, the contract address is returned, which is crucial for interacting with the contract later on</p> <code>deploySender.js</code><code>deployReceiver.js</code> <pre><code>  const senderContract = await MessageSender.deploy(\n    avalancheChain.wormholeRelayer\n  );\n  await senderContract.waitForDeployment();\n</code></pre> <pre><code>  const receiverContract = await MessageReceiver.deploy(\n    celoChain.wormholeRelayer\n  );\n  await receiverContract.waitForDeployment();\n</code></pre> </li> <li> <p>Register the <code>MessageSender</code> on the target chain - after you deploy the <code>MessageReceiver</code> contract on the Celo Alfajores network, the sender contract address from Avalanche Fuji needs to be registered. This ensures that only messages from the registered <code>MessageSender</code> contract are processed</p> <p>This additional step is essential to enforce emitter validation, preventing unauthorized senders from delivering messages to the <code>MessageReceiver</code> contract</p> <pre><code>  // Retrieve the address of the MessageSender from the deployedContracts.json file\n  const avalancheSenderAddress = deployedContracts.avalanche.MessageSender;\n\n  // Define the source chain ID for Avalanche Fuji\n  const sourceChainId = 6;\n\n  // Call setRegisteredSender on the MessageReceiver contract\n  const tx = await receiverContract.setRegisteredSender(\n    sourceChainId,\n    ethers.zeroPadValue(avalancheSenderAddress, 32)\n  );\n  await tx.wait();\n</code></pre> </li> </ol> <p>You can find the full code for the <code>deploySender.js</code> and <code>deployReceiver.js</code> below.</p> deploySender.js <pre><code>const { ethers } = require('ethers');\nconst fs = require('fs');\nconst path = require('path');\nrequire('dotenv').config();\n\nasync function main() {\n  // Load the chain configuration from JSON\n  const chains = JSON.parse(\n    fs.readFileSync(path.resolve(__dirname, '../deploy-config/chains.json'))\n  );\n\n  // Get the Avalanche Fuji configuration\n  const avalancheChain = chains.chains.find((chain) =&gt;\n    chain.description.includes('Avalanche testnet')\n  );\n\n  // Set up the provider and wallet\n  const provider = new ethers.JsonRpcProvider(avalancheChain.rpc);\n  const wallet = new ethers.Wallet(process.env.PRIVATE_KEY, provider);\n\n  // Load the ABI and bytecode of the MessageSender contract\n  const messageSenderJson = JSON.parse(\n    fs.readFileSync(\n      path.resolve(__dirname, '../out/MessageSender.sol/MessageSender.json'),\n      'utf8'\n    )\n  );\n\n  const abi = messageSenderJson.abi;\n  const bytecode = messageSenderJson.bytecode;\n\n  // Create a ContractFactory for MessageSender\n  const MessageSender = new ethers.ContractFactory(abi, bytecode, wallet);\n\n  // Deploy the contract using the Wormhole Relayer address for Avalanche Fuji\n  const senderContract = await MessageSender.deploy(\n    avalancheChain.wormholeRelayer\n  );\n  await senderContract.waitForDeployment();\n\n  console.log('MessageSender deployed to:', senderContract.target);\n\n  // Update the deployedContracts.json file\n  const deployedContractsPath = path.resolve(\n    __dirname,\n    '../deploy-config/deployedContracts.json'\n  );\n  const deployedContracts = JSON.parse(\n    fs.readFileSync(deployedContractsPath, 'utf8')\n  );\n\n  deployedContracts.avalanche = {\n    MessageSender: senderContract.target,\n    deployedAt: new Date().toISOString(),\n  };\n\n  fs.writeFileSync(\n    deployedContractsPath,\n    JSON.stringify(deployedContracts, null, 2)\n  );\n}\n\nmain().catch((error) =&gt; {\n  console.error(error);\n  process.exit(1);\n});\n</code></pre> deployReceiver.js <pre><code>const { ethers } = require('ethers');\nconst fs = require('fs');\nconst path = require('path');\nrequire('dotenv').config();\n\nasync function main() {\n  // Load the chain configuration from the JSON file\n  const chains = JSON.parse(\n    fs.readFileSync(path.resolve(__dirname, '../deploy-config/chains.json'))\n  );\n\n  // Get the Celo Testnet configuration\n  const celoChain = chains.chains.find((chain) =&gt;\n    chain.description.includes('Celo Testnet')\n  );\n\n  // Set up the provider and wallet\n  const provider = new ethers.JsonRpcProvider(celoChain.rpc);\n  const wallet = new ethers.Wallet(process.env.PRIVATE_KEY, provider);\n\n  // Load the ABI and bytecode of the MessageReceiver contract\n  const messageReceiverJson = JSON.parse(\n    fs.readFileSync(\n      path.resolve(\n        __dirname,\n        '../out/MessageReceiver.sol/MessageReceiver.json'\n      ),\n      'utf8'\n    )\n  );\n\n  const abi = messageReceiverJson.abi;\n  const bytecode = messageReceiverJson.bytecode;\n\n  // Create a ContractFactory for MessageReceiver\n  const MessageReceiver = new ethers.ContractFactory(abi, bytecode, wallet);\n\n  // Deploy the contract using the Wormhole Relayer address for Celo Testnet\n  const receiverContract = await MessageReceiver.deploy(\n    celoChain.wormholeRelayer\n  );\n  await receiverContract.waitForDeployment();\n\n  console.log('MessageReceiver deployed to:', receiverContract.target); // `target` is the contract address in ethers.js v6\n\n  // Update the deployedContracts.json file\n  const deployedContractsPath = path.resolve(\n    __dirname,\n    '../deploy-config/deployedContracts.json'\n  );\n  const deployedContracts = JSON.parse(\n    fs.readFileSync(deployedContractsPath, 'utf8')\n  );\n\n  // Retrieve the address of the MessageSender from the deployedContracts.json file\n  const avalancheSenderAddress = deployedContracts.avalanche.MessageSender;\n\n  // Define the source chain ID for Avalanche Fuji\n  const sourceChainId = 6;\n\n  // Call setRegisteredSender on the MessageReceiver contract\n  const tx = await receiverContract.setRegisteredSender(\n    sourceChainId,\n    ethers.zeroPadValue(avalancheSenderAddress, 32)\n  );\n  await tx.wait();\n\n  console.log(\n    `Registered MessageSender (${avalancheSenderAddress}) for Avalanche chain (${sourceChainId})`\n  );\n\n  deployedContracts.celo = {\n    MessageReceiver: receiverContract.target,\n    deployedAt: new Date().toISOString(),\n  };\n\n  fs.writeFileSync(\n    deployedContractsPath,\n    JSON.stringify(deployedContracts, null, 2)\n  );\n}\n\nmain().catch((error) =&gt; {\n  console.error(error);\n  process.exit(1);\n});\n</code></pre>"},{"location":"tutorials/messaging/cross-chain-contracts/#deploy-the-sender-contract","title":"Deploy the Sender Contract","text":"<p>The sender contract will handle quoting and sending messages cross-chain.</p> <ol> <li> <p>Run the following command to deploy the sender contract:</p> <pre><code>npm run deploy:sender\n</code></pre> </li> <li> <p>Once deployed, the contract address will be displayed. You may check the contract on the Avalanche Fuji Explorer</p> </li> </ol> npm run deploy:sender  &gt; wormhole-cross-chain@1.0.0 deploy:sender  &gt; node script/deploySender.js          MessageSender deployed to: 0xf5c474f335fFf617fA6FD04DCBb17E20ee0cEfb1"},{"location":"tutorials/messaging/cross-chain-contracts/#deploy-the-receiver-contract","title":"Deploy the Receiver Contract","text":"<p>The receiver contract listens for cross-chain messages and logs them when received.</p> <ol> <li> <p>Deploy the receiver contract with this command:</p> <pre><code>npm run deploy:receiver\n</code></pre> </li> <li> <p>After deployment, note down the contract address. You may check the contract on the Celo Alfajores Explorer.</p> </li> </ol>"},{"location":"tutorials/messaging/cross-chain-contracts/#send-a-cross-chain-message","title":"Send a Cross-Chain Message","text":"<p>Now that both the sender and receiver contracts are deployed, let's move on to the next exciting step: sending a cross-chain message from Avalanche Fuji to Celo Alfajores.</p> <p>In this example, we will use the <code>sendMessage.js</code> script to transmit a message from the sender contract on Avalanche to the receiver contract on Celo. The script uses Ethers.js to interact with the deployed contracts, calculate the cross-chain cost dynamically, and handle the transaction.</p> <p>Let's break down the script step by step.</p> <ol> <li> <p>Load configuration files</p> <ol> <li><code>chains.json</code> - contains details about the supported TestNet chains, such as RPC URLs and relayer addresses</li> <li><code>deployedContracts.json</code> - stores the addresses of the deployed sender and receiver contracts. This file is dynamically updated when contracts are deployed, but users can also manually add their own deployed contract addresses if needed</li> </ol> <pre><code>  const chains = JSON.parse(\n    fs.readFileSync(path.resolve(__dirname, '../deploy-config/chains.json'))\n  );\n\n  const deployedContracts = JSON.parse(\n    fs.readFileSync(\n      path.resolve(__dirname, '../deploy-config/deployedContracts.json')\n    )\n  );\n</code></pre> </li> <li> <p>Configure the provider and signer - the script first reads the chain configurations and extracts the contract addresses. One essential step in interacting with a blockchain is setting up a provider. A provider is your connection to the blockchain network. It allows your script to interact with the blockchain, retrieve data, and send transactions. In this case, we're using a JSON-RPC provider</p> <p>Next, we configure the wallet, which will be used to sign transactions. The wallet is created using the private key and the provider. This ensures that all transactions sent from this wallet are broadcast to the Avalanche Fuji network:</p> <pre><code>  const provider = new ethers.JsonRpcProvider(avalancheChain.rpc);\n  const wallet = new ethers.Wallet(process.env.PRIVATE_KEY, provider);\n</code></pre> <p>After setting up the wallet, the script loads the ABI for the <code>MessageSender.sol</code> contract and creates an instance of it:</p> <pre><code>  const messageSenderJson = JSON.parse(\n    fs.readFileSync(\n      path.resolve(__dirname, '../out/MessageSender.sol/MessageSender.json'),\n      'utf8'\n    )\n  );\n</code></pre> </li> <li> <p>Set up the message details - the next part of the script defines the target chain (Celo) and the target address (the receiver contract on Celo):</p> <pre><code>  const targetChain = 14; // Wormhole chain ID for Celo Alfajores\n  const targetAddress = deployedContracts.celo.MessageReceiver;\n</code></pre> <p>You can customize the message that will be sent across chains:</p> <pre><code>  const message = 'Hello from Avalanche to Celo!';\n</code></pre> </li> <li> <p>Estimate cross-chain cost - before sending the message, we dynamically calculate the cross-chain cost using the <code>quoteCrossChainCost</code> function:</p> <pre><code>  const txCost = await MessageSender.quoteCrossChainCost(targetChain);\n</code></pre> <p>This ensures that the transaction includes enough funds to cover the gas fees for the cross-chain message.</p> </li> <li> <p>Send a message - with everything set up, the message is sent using the <code>sendMessage</code> function:</p> <pre><code>  const tx = await MessageSender.sendMessage(\n    targetChain,\n    targetAddress,\n    message,\n    {\n      value: txCost,\n    }\n  );\n</code></pre> <p>After sending, the script waits for the transaction to be confirmed:</p> <pre><code>  await tx.wait();\n</code></pre> </li> <li> <p>Run the script - to send the message, run the following command:</p> <pre><code>npm run send:message\n</code></pre> </li> </ol> <p>If everything is set up correctly, the message will be sent from the Avalanche Fuji TestNet to the Celo Alfajores TestNet. You can monitor the transaction and verify that the message was received on Celo using the Wormhole Explorer.</p> <p>The console should output something similar to this:</p> npm run send:message  &gt; wormhole-cross-chain@1.0.0 send:message  &gt; node script/sendMessage.js Sender Contract Address: 0xD720BFF42a0960cfF1118454A907a44dB358f2b1 Receiver Contract Address: 0x692550997C252cC5044742D1A2BD91E4f4b46D39 ... Transaction sent, waiting for confirmation... ... Message sent! Transaction hash:         0x9d359a66ba42baced80062229c0b02b4f523fe304aff3473dcf53117aee13fb6 You may see the transaction status on the Wormhole Explorer:         https://wormholescan.io/#/tx/0x9d359a66ba42baced80062229c0b02b4f523fe304aff3473dcf53117aee13fb6?network=TESTNET <p>You can find the full code for the <code>sendMessage.js</code> below.</p> sendMessage.js <pre><code>const { ethers } = require('ethers');\nconst fs = require('fs');\nconst path = require('path');\nrequire('dotenv').config();\n\nasync function main() {\n  // Load the chain configuration and deployed contract addresses\n  const chains = JSON.parse(\n    fs.readFileSync(path.resolve(__dirname, '../deploy-config/chains.json'))\n  );\n\n  const deployedContracts = JSON.parse(\n    fs.readFileSync(\n      path.resolve(__dirname, '../deploy-config/deployedContracts.json')\n    )\n  );\n\n  console.log(\n    'Sender Contract Address: ',\n    deployedContracts.avalanche.MessageSender\n  );\n  console.log(\n    'Receiver Contract Address: ',\n    deployedContracts.celo.MessageReceiver\n  );\n  console.log('...');\n\n  // Get the Avalanche Fuji configuration\n  const avalancheChain = chains.chains.find((chain) =&gt;\n    chain.description.includes('Avalanche testnet')\n  );\n\n  // Set up the provider and wallet\n  const provider = new ethers.JsonRpcProvider(avalancheChain.rpc);\n  const wallet = new ethers.Wallet(process.env.PRIVATE_KEY, provider);\n\n  // Load the ABI of the MessageSender contract\n  const messageSenderJson = JSON.parse(\n    fs.readFileSync(\n      path.resolve(__dirname, '../out/MessageSender.sol/MessageSender.json'),\n      'utf8'\n    )\n  );\n\n  const abi = messageSenderJson.abi;\n\n  // Create a contract instance for MessageSender\n  const MessageSender = new ethers.Contract(\n    deployedContracts.avalanche.MessageSender,\n    abi,\n    wallet\n  );\n\n  // Define the target chain and target address (the Celo receiver contract)\n  const targetChain = 14; // Wormhole chain ID for Celo Alfajores\n  const targetAddress = deployedContracts.celo.MessageReceiver;\n\n  // The message you want to send\n  const message = 'Hello from Avalanche to Celo!';\n\n  // Dynamically quote the cross-chain cost\n  const txCost = await MessageSender.quoteCrossChainCost(targetChain);\n\n  // Send the message (make sure to send enough gas in the transaction)\n  const tx = await MessageSender.sendMessage(\n    targetChain,\n    targetAddress,\n    message,\n    {\n      value: txCost,\n    }\n  );\n\n  console.log('Transaction sent, waiting for confirmation...');\n  await tx.wait();\n  console.log('...');\n\n  console.log('Message sent! Transaction hash:', tx.hash);\n  console.log(\n    `You may see the transaction status on the Wormhole Explorer: https://wormholescan.io/#/tx/${tx.hash}?network=TESTNET`\n  );\n}\n\nmain().catch((error) =&gt; {\n  console.error(error);\n  process.exit(1);\n});\n</code></pre>"},{"location":"tutorials/messaging/cross-chain-contracts/#conclusion","title":"Conclusion","text":"<p>You're now fully equipped to build cross-chain contracts using the Wormhole protocol! With this tutorial, you've learned how to:</p> <ul> <li>Deploy sender and receiver contracts on different TestNets</li> <li>Send a cross-chain message from one blockchain to another</li> <li>Monitor the status of your cross-chain transactions using the Wormhole Explorer and Wormhole-Solidity-SDK</li> </ul>"},{"location":"tutorials/messaging/cross-chain-token-contracts/","title":"Cross-Chain Token Transfers","text":""},{"location":"tutorials/messaging/cross-chain-token-contracts/#introduction","title":"Introduction","text":"<p>In this tutorial, you'll learn how to create a simple cross-chain token transfer system using the Wormhole protocol via the Wormhole Solidity SDK. We'll guide you through building and deploying smart contracts that enable seamless token transfers of IERC-20 tokens between blockchains. Whether you're a developer looking to explore cross-chain applications or just interested in the Wormhole protocol, this guide will help you understand the fundamentals.</p> <p>By the end of this tutorial, you'll have a working cross-chain token transfer system built with the powerful tools provided by the Wormhole Solidity SDK, which you can further customize and integrate into your projects.</p>"},{"location":"tutorials/messaging/cross-chain-token-contracts/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have the following:</p> <ul> <li>Node.js and npm installed on your machine</li> <li>Foundry for deploying contracts</li> <li>TestNet tokens for Avalanche-Fuji and Celo-Alfajores to cover gas fees</li> <li>USDC TestNet tokens on Avalanche-Fuji or/and Celo-Alfajores for cross-chain transfer</li> <li>Wallet private key</li> </ul>"},{"location":"tutorials/messaging/cross-chain-token-contracts/#valid-tokens-for-transfer","title":"Valid Tokens for Transfer","text":"<p>It's important to note that this tutorial leverages Wormhole's TokenBridge to transfer tokens between chains. So, the tokens you'd like to transfer must have an attestation on the <code>TokenBridge</code> contract of the target blockchain.</p> <p>To simplify this process, we've included a tool for verifying if a token has an attestation on the target chain. This tool uses the <code>wrappedAsset</code> function from the <code>TokenBridge</code> contract. If the token has an attestation, the <code>wrappedAsset</code> function returns the address of the wrapped token on the target chain; otherwise, it returns the zero address.</p> Check Token Attestation <ol> <li>Clone the repository and navigate to the project directory:     <pre><code>git clone https://github.com/martin0995/cross-chain-token-transfers.git\ncd cross-chain-token-transfers\n</code></pre></li> <li> <p>Install the dependencies:     <pre><code>npm install\n</code></pre></p> </li> <li> <p>Run the script to check token attestation:     <pre><code>npm run verify\n</code></pre></p> </li> <li> <p>Follow the prompts:</p> <ol> <li>Enter the RPC URL of the target chain</li> <li>Enter the <code>TokenBridge</code> contract address on the target chain</li> <li>Enter the token contract address on the source chain</li> <li>Enter the source chain ID</li> </ol> </li> <li> <p>The expected output when the token has an attestation:</p> <p> npm run verify  &gt; cross-chain-token-transfer@1.0.0 verify  &gt; npx ts-node script/check-attestation.ts  Enter the TARGET chain RPC URL: https://alfajores-forno.celo-testnet.org  Enter the Token Bridge contract address on the TARGET chain: 0x05...E153  Enter the token contract address on the SOURCE chain: 0x54...bc65  Enter the SOURCE chain ID: 6  The token is attested on the target chain. Wrapped token address: 0xDDB349c976cA2C873644F21f594767Eb5390C831 </p> </li> </ol> <p>Using this tool ensures that you only attempt to transfer tokens with verified attestations, avoiding any potential issues during the cross-chain transfer process.</p>"},{"location":"tutorials/messaging/cross-chain-token-contracts/#project-setup","title":"Project Setup","text":"<p>Let's start by initializing a new Foundry project. This will set up a basic structure for our smart contracts.</p> <ol> <li> <p>Open your terminal and run the following command to initialize a new Foundry project:</p> <pre><code>forge init cross-chain-token-transfers\n</code></pre> <p>This will create a new directory named <code>cross-chain-token-transfers</code> with a basic project structure. This also initializes a new <code>git</code> repository.</p> </li> <li> <p>Navigate into the newly created project directory:</p> <pre><code>cd cross-chain-token-transfers\n</code></pre> </li> <li> <p>Install the Wormhole Solidity SDK:</p> <pre><code>forge install wormhole-foundation/wormhole-solidity-sdk\n</code></pre> <p>To ease development, we'll use the Wormhole Solidity SDK, which provides useful helpers for cross-chain development. This SDK includes the <code>TokenSender</code> and <code>TokenReceiver</code> abstract classes, which simplify sending and receiving tokens across chains.</p> </li> </ol>"},{"location":"tutorials/messaging/cross-chain-token-contracts/#build-cross-chain-contracts","title":"Build Cross-Chain Contracts","text":"<p>In this section, we'll build two smart contracts to send tokens from a source chain and receive them on a target chain. These contracts will interact with the Wormhole protocol to facilitate secure and seamless cross-chain token transfers.</p> <p>At a high level, our contracts will:</p> <ol> <li>Send tokens from one blockchain to another using the Wormhole protocol</li> <li>Receive and process the tokens on the target chain, ensuring they are correctly transferred to the intended recipient</li> </ol> <p>Before diving into the contract implementation steps, let\u2019s first break down the key parts of the contracts.</p>"},{"location":"tutorials/messaging/cross-chain-token-contracts/#sender-contract-crosschainsender","title":"Sender Contract: CrossChainSender","text":"<p>The <code>CrossChainSender</code> contract calculates the cost of sending tokens across chains and then facilitates the actual token transfer.</p> <p>Let's start writing the <code>CrossChainSender</code> contract:</p> <ol> <li> <p>Create a new file named <code>CrossChainSender.sol</code> in the <code>/src</code> directory:</p> <pre><code>touch src/CrossChainSender.sol\n</code></pre> </li> <li> <p>Open the file. First, we'll start with the imports and the contract setup:</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"lib/wormhole-solidity-sdk/src/WormholeRelayerSDK.sol\";\nimport \"lib/wormhole-solidity-sdk/src/interfaces/IERC20.sol\";\n\ncontract CrossChainSender is TokenSender {\n    uint256 constant GAS_LIMIT = 250_000;\n\n    constructor(\n        address _wormholeRelayer,\n        address _tokenBridge,\n        address _wormhole\n    ) TokenBase(_wormholeRelayer, _tokenBridge, _wormhole) {}\n</code></pre> <p>This sets up the basic structure of the contract, including the necessary imports and the constructor that initializes the contract with the Wormhole-related addresses.</p> </li> <li> <p>Next, let's add a function that estimates the cost of sending tokens across chains:</p> <pre><code>    function quoteCrossChainDeposit(\n        uint16 targetChain\n    ) public view returns (uint256 cost) {\n        uint256 deliveryCost;\n        (deliveryCost, ) = wormholeRelayer.quoteEVMDeliveryPrice(\n            targetChain,\n            0,\n            GAS_LIMIT\n        );\n\n        cost = deliveryCost + wormhole.messageFee();\n    }\n</code></pre> <p>This function, <code>quoteCrossChainDeposit</code>, helps calculate the cost of transferring tokens to a different chain. It factors in the delivery cost and the cost of publishing a message via the Wormhole protocol.</p> </li> <li> <p>Finally, we'll add the function that sends the tokens across chains:</p> <pre><code>    function sendCrossChainDeposit(\n        uint16 targetChain,\n        address targetReceiver,\n        address recipient,\n        uint256 amount,\n        address token\n    ) public payable {\n        uint256 cost = quoteCrossChainDeposit(targetChain);\n        require(\n            msg.value == cost,\n            \"msg.value must equal quoteCrossChainDeposit(targetChain)\"\n        );\n\n        IERC20(token).transferFrom(msg.sender, address(this), amount);\n\n        bytes memory payload = abi.encode(recipient);\n\n        sendTokenWithPayloadToEvm(\n            targetChain,\n            targetReceiver,\n            payload,\n            0,\n            GAS_LIMIT,\n            token,\n            amount\n        );\n    }\n}\n</code></pre> <p>This <code>sendCrossChainDeposit</code> function is where the actual token transfer happens. It sends the tokens to the recipient on the target chain using the Wormhole protocol.</p> </li> </ol> <p>Here\u2019s a breakdown of what happens in each step of the <code>sendCrossChainDeposit</code> function:</p> <ol> <li> <p>Cost calculation - the function starts by calculating the cost of the cross-chain transfer using <code>quoteCrossChainDeposit</code>(<code>targetChain</code>). This cost includes both the delivery fee and the Wormhole message fee. The <code>sendCrossChainDeposit</code> function then checks that the user has sent the correct amount of Ether to cover this cost (<code>msg.value</code>)</p> </li> <li> <p>Token transfer to contract - the next step is to transfer the specified amount of tokens from the user to the contract itself using <code>IERC-20(token).transferFrom(msg.sender, address(this), amount)</code>. This ensures that the contract has custody of the tokens before initiating the cross-chain transfer</p> </li> <li> <p>Payload encoding - The recipient's address on the target chain is encoded into a payload using <code>abi.encode(recipient)</code>. This payload will be sent along with the token transfer, so the target contract knows who should receive the tokens on the destination chain</p> </li> <li> <p>Cross-chain transfer - the <code>sendTokenWithPayloadToEvm</code> function is called to initiate the cross-chain token transfer. This function:</p> <ul> <li>Specifies the <code>targetChain</code> (the Wormhole chain ID of the destination blockchain).</li> <li>Sends the <code>targetReceiver</code> contract address on the target chain that will receive the tokens.</li> <li>Attaches the payload containing the recipient's address.</li> <li>Sets the <code>GAS_LIMIT</code> for the transaction.</li> <li>Passes the token <code>address</code> and <code>amount</code> to transfer.</li> </ul> <p>This triggers the Wormhole protocol to handle the cross-chain messaging and token transfer, ensuring the tokens and payload reach the correct destination on the target chain.</p> </li> </ol> <p>You can find the complete code for the <code>CrossChainSender.sol</code> below.</p> MessageSender.sol <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"lib/wormhole-solidity-sdk/src/WormholeRelayerSDK.sol\";\nimport \"lib/wormhole-solidity-sdk/src/interfaces/IERC20.sol\";\n\ncontract CrossChainSender is TokenSender {\n    uint256 constant GAS_LIMIT = 250_000;\n\n    constructor(\n        address _wormholeRelayer,\n        address _tokenBridge,\n        address _wormhole\n    ) TokenBase(_wormholeRelayer, _tokenBridge, _wormhole) {}\n\n    // Function to get the estimated cost for cross-chain deposit\n    function quoteCrossChainDeposit(\n        uint16 targetChain\n    ) public view returns (uint256 cost) {\n        uint256 deliveryCost;\n        (deliveryCost, ) = wormholeRelayer.quoteEVMDeliveryPrice(\n            targetChain,\n            0,\n            GAS_LIMIT\n        );\n\n        cost = deliveryCost + wormhole.messageFee();\n    }\n\n    // Function to send tokens and payload across chains\n    function sendCrossChainDeposit(\n        uint16 targetChain,\n        address targetReceiver,\n        address recipient,\n        uint256 amount,\n        address token\n    ) public payable {\n        uint256 cost = quoteCrossChainDeposit(targetChain);\n        require(\n            msg.value == cost,\n            \"msg.value must equal quoteCrossChainDeposit(targetChain)\"\n        );\n\n        IERC20(token).transferFrom(msg.sender, address(this), amount);\n\n        bytes memory payload = abi.encode(recipient);\n\n        sendTokenWithPayloadToEvm(\n            targetChain,\n            targetReceiver,\n            payload,\n            0,\n            GAS_LIMIT,\n            token,\n            amount\n        );\n    }\n}\n</code></pre>"},{"location":"tutorials/messaging/cross-chain-token-contracts/#receiver-contract-crosschainreceiver","title":"Receiver Contract: CrossChainReceiver","text":"<p>The <code>CrossChainReceiver</code> contract is designed to handle the receipt of tokens and payloads from another blockchain. It ensures that the tokens are correctly transferred to the designated recipient on the receiving chain.</p> <p>Let's start writing the <code>CrossChainReceiver</code> contract:</p> <ol> <li> <p>Create a new file named <code>CrossChainReceiver.sol</code> in the <code>/src</code> directory:</p> <pre><code>touch src/CrossChainReceiver.sol\n</code></pre> </li> <li> <p>Open the file. First, we'll start with the imports and the contract setup:</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"lib/wormhole-solidity-sdk/src/WormholeRelayerSDK.sol\";\nimport \"lib/wormhole-solidity-sdk/src/interfaces/IERC20.sol\";\n\ncontract CrossChainReceiver is TokenReceiver {\n    // The Wormhole relayer and registeredSenders are inherited from the Base.sol contract\n\n    constructor(\n        address _wormholeRelayer,\n        address _tokenBridge,\n        address _wormhole\n    ) TokenBase(_wormholeRelayer, _tokenBridge, _wormhole) {}\n</code></pre> <p>Similar to the <code>CrossChainSender</code> contract, this sets up the basic structure of the contract, including the necessary imports and the constructor that initializes the contract with the Wormhole-related addresses.</p> </li> <li> <p>Next, let's add a function to handle receiving the payload and tokens:</p> <pre><code>    function receivePayloadAndTokens(\n        bytes memory payload,\n        TokenReceived[] memory receivedTokens,\n        bytes32 sourceAddress,\n        uint16 sourceChain,\n        bytes32 // deliveryHash\n    )\n        internal\n        override\n        onlyWormholeRelayer\n        isRegisteredSender(sourceChain, sourceAddress)\n    {\n        require(receivedTokens.length == 1, \"Expected 1 token transfer\");\n\n        // Decode the recipient address from the payload\n        address recipient = abi.decode(payload, (address));\n\n        // Transfer the received tokens to the intended recipient\n        IERC20(receivedTokens[0].tokenAddress).transfer(\n            recipient,\n            receivedTokens[0].amount\n        );\n    }\n}\n</code></pre> <p>This <code>receivePayloadAndTokens</code> function processes the tokens and payload sent from another chain, decodes the recipient address, and transfers the tokens to them using the Wormhole protocol. This function also validates the emitter (<code>sourceAddress</code>) to ensure the message comes from a trusted sender.</p> <p>This function ensures that:</p> <ul> <li>It only processes one token transfer at a time</li> <li>The <code>sourceAddress</code> is checked against a list of registered senders using the <code>isRegisteredSender</code> modifier, which verifies if the emitter is allowed to send tokens to this contract</li> <li>The recipient address is decoded from the payload, and the received tokens are transferred to them using the ERC-20 interface</li> </ul> </li> </ol> <p>After we call <code>sendTokenWithPayloadToEvm</code> on the source chain, the message goes through the standard Wormhole message lifecycle. Once a VAA (Verifiable Action Approval) is available, the delivery provider will call <code>receivePayloadAndTokens</code> on the target chain and target address specified, with the appropriate inputs.</p> Understanding the <code>TokenReceived</code> Struct <p>Let\u2019s delve into the fields provided to us in the <code>TokenReceived</code> struct:</p> <pre><code>struct TokenReceived {\n    bytes32 tokenHomeAddress;\n    uint16 tokenHomeChain;\n    address tokenAddress;\n    uint256 amount;\n    uint256 amountNormalized;\n}\n</code></pre> <ul> <li> <p><code>tokenHomeAddress</code> - the original address of the token on its native chain. This is the same as the token field in the call to <code>sendTokenWithPayloadToEvm</code> unless the original token sent is a Wormhole-wrapped token. In that case, this will be the address of the original version of the token (on its native chain) in Wormhole address format (left-padded with 12 zeros)</p> </li> <li> <p><code>tokenHomeChain</code> - the Wormhole chain ID corresponding to the home address above. This will typically be the source chain unless the original token sent is a Wormhole-wrapped asset, which will be the chain of the unwrapped version of the token</p> </li> <li> <p><code>tokenAddress</code> - the address of the IERC-20 token on the target chain that has been transferred to this contract. If <code>tokenHomeChain</code> equals the target chain, this will be the same as <code>tokenHomeAddress</code>; otherwise, it will be the Wormhole-wrapped version of the token sent</p> </li> <li> <p><code>amount</code> - the token amount sent to you with the same units as the original token. Since <code>TokenBridge</code> only sends with eight decimals of precision, if your token has 18 decimals, this will be the \"amount\" you sent, rounded down to the nearest multiple of 10^10</p> </li> <li> <p><code>amountNormalized</code> - the amount of token divided by (1 if decimals \u2264 8, else 10^(decimals - 8))</p> </li> </ul> <p>You can find the complete code for the <code>CrossChainReceiver.sol</code> contract below:</p> CrossChainReceiver.sol <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"lib/wormhole-solidity-sdk/src/WormholeRelayerSDK.sol\";\nimport \"lib/wormhole-solidity-sdk/src/interfaces/IERC20.sol\";\n\ncontract CrossChainReceiver is TokenReceiver {\n    // The Wormhole relayer and registeredSenders are inherited from the Base.sol contract\n\n    constructor(\n        address _wormholeRelayer,\n        address _tokenBridge,\n        address _wormhole\n    ) TokenBase(_wormholeRelayer, _tokenBridge, _wormhole) {}\n\n    // Function to receive the cross-chain payload and tokens with emitter validation\n    function receivePayloadAndTokens(\n        bytes memory payload,\n        TokenReceived[] memory receivedTokens,\n        bytes32 sourceAddress,\n        uint16 sourceChain,\n        bytes32 // deliveryHash\n    )\n        internal\n        override\n        onlyWormholeRelayer\n        isRegisteredSender(sourceChain, sourceAddress)\n    {\n        require(receivedTokens.length == 1, \"Expected 1 token transfer\");\n\n        // Decode the recipient address from the payload\n        address recipient = abi.decode(payload, (address));\n\n        // Transfer the received tokens to the intended recipient\n        IERC20(receivedTokens[0].tokenAddress).transfer(\n            recipient,\n            receivedTokens[0].amount\n        );\n    }\n}\n</code></pre>"},{"location":"tutorials/messaging/cross-chain-token-contracts/#deploy-the-contracts","title":"Deploy the Contracts","text":"<p>Now that you've written the <code>CrossChainSender</code> and <code>CrossChainReceiver</code> contracts, it's time to deploy them to your chosen networks.</p> <ol> <li> <p>Set up deployment configuration - before deploying, you must configure the networks and the deployment environment. This information is stored in a configuration file</p> <ol> <li> <p>Create a directory named deploy-config in the root of your project:</p> <pre><code>mkdir deploy-config\n</code></pre> </li> <li> <p>Create a <code>config.json</code> file in the <code>deploy-config</code> directory:</p> <pre><code>touch deploy-config/config.json\n</code></pre> </li> <li> <p>Open the <code>config.json</code> file and add the following configuration:</p> <pre><code>{\n    \"chains\": [\n        {\n            \"description\": \"Avalanche testnet fuji\",\n            \"chainId\": 6,\n            \"rpc\": \"https://api.avax-test.network/ext/bc/C/rpc\",\n            \"tokenBridge\": \"0x61E44E506Ca5659E6c0bba9b678586fA2d729756\",\n            \"wormholeRelayer\": \"0xA3cF45939bD6260bcFe3D66bc73d60f19e49a8BB\",\n            \"wormhole\": \"0x7bbcE28e64B3F8b84d876Ab298393c38ad7aac4C\"\n        },\n        {\n            \"description\": \"Celo Testnet\",\n            \"chainId\": 14,\n            \"rpc\": \"https://alfajores-forno.celo-testnet.org\",\n            \"tokenBridge\": \"0x05ca6037eC51F8b712eD2E6Fa72219FEaE74E153\",\n            \"wormholeRelayer\": \"0x306B68267Deb7c5DfCDa3619E22E9Ca39C374f84\",\n            \"wormhole\": \"0x88505117CA88e7dd2eC6EA1E13f0948db2D50D56\"\n        }\n    ]\n}\n</code></pre> <p>This file specifies the details for each chain where you plan to deploy your contracts, including the RPC URL, the <code>TokenBridge</code> address, the Wormhole relayer, and the Wormhole Core Contract.</p> <p>For a complete list of Wormhole contract addresses on various blockchains, refer to the Wormhole Contract Addresses.</p> <p>Note</p> <p>You can add your desired chains to this file by specifying the required fields for each chain. In this example, we use the Avalanche Fuji and Celo Alfajores TestNets.</p> </li> <li> <p>Create a <code>contracts.json</code> file in the <code>deploy-config</code> directory:</p> <pre><code>echo '{}' &gt; deploy-config/contracts.json\n</code></pre> <p>This file can be left blank initially. It will be automatically updated with the deployed contract addresses after a successful deployment</p> </li> </ol> </li> <li> <p>Set up your Node.js environment - you'll need to set up your Node.js environment to run the deployment script</p> <ol> <li> <p>Initialize a Node.js project:</p> <pre><code>npm init -y\n</code></pre> </li> <li> <p>Install the necessary dependencies:</p> <pre><code>npm install ethers dotenv readline-sync @types/readline-sync\n</code></pre> <p>These dependencies are required for the deployment script to work properly.</p> </li> </ol> </li> <li> <p>Compile your smart contracts - compile your smart contracts using Foundry. This ensures that your contracts are up-to-date and ready for deployment</p> <ul> <li> <p>Run the following command to compile your contracts:</p> <pre><code>forge build\n</code></pre> <p>This will generate the necessary ABI and bytecode files in a directory named <code>/out</code>.</p> </li> </ul> <p>The expected output should be similar to this:</p> <p> forge build  &gt; [\u2812] Compiling...  &gt; [\u2830] Compiling 30 files with 0.8.23  [\u2814] Solc 0.8.23 finished in 2.29s Compiler run successful! </p> </li> <li> <p>Write the deployment script - you\u2019ll need a script to automate the deployment of your contracts. Let\u2019s create the deployment script</p> <ol> <li> <p>Create a new file named <code>deploy.ts</code> in the <code>/script</code> directory:</p> <pre><code>touch script/deploy.ts\n</code></pre> </li> <li> <p>Open the file and load imports and configuration:</p> <pre><code>import { BytesLike, ethers } from 'ethers';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport * as dotenv from 'dotenv';\nimport readlineSync from 'readline-sync';\n\ndotenv.config();\n</code></pre> <p>Import the required libraries and modules to interact with Ethereum, handle file paths, load environment variables, and enable user interaction via the terminal.</p> </li> <li> <p>Define interfaces to use for chain configuration and contract deployment:</p> <pre><code>interface ChainConfig {\n  description: string;\n  chainId: number;\n  rpc: string;\n  tokenBridge: string;\n  wormholeRelayer: string;\n  wormhole: string;\n}\n\ninterface DeployedContracts {\n  [chainId: number]: {\n    networkName: string;\n    CrossChainSender?: string;\n    CrossChainReceiver?: string;\n    deployedAt: string;\n  };\n}\n</code></pre> <p>These interfaces define the structure of the chain configuration and the contract deployment details.</p> </li> <li> <p>Load and select the chains for deployment:</p> <pre><code>function loadConfig(): ChainConfig[] {\n  const configPath = path.resolve(__dirname, '../deploy-config/config.json');\n  return JSON.parse(fs.readFileSync(configPath, 'utf8')).chains;\n}\n\nfunction selectChain(\n  chains: ChainConfig[],\n  role: 'source' | 'target'\n): ChainConfig {\n  console.log(`\\nSelect the ${role.toUpperCase()} chain:`);\n  chains.forEach((chain, index) =&gt; {\n    console.log(`${index + 1}: ${chain.description}`);\n  });\n\n  const chainIndex =\n    readlineSync.questionInt(\n      `\\nEnter the number for the ${role.toUpperCase()} chain: `\n    ) - 1;\n  return chains[chainIndex];\n}\n</code></pre> <p>The <code>loadConfig</code> function reads the chain configuration from the <code>config.json</code> file, and the <code>selectChain</code> function allows the user to choose the source and target chains for deployment interactively. The user is prompted in the terminal to select which chains to use, making the process interactive and user-friendly.</p> </li> <li> <p>Define the main function for deployment and load the chain configuration:</p> <pre><code>async function main() {\n  const chains = loadConfig();\n\n  const sourceChain = selectChain(chains, 'source');\n  const targetChain = selectChain(chains, 'target');\n</code></pre> <ul> <li>The <code>main</code> function is the entry point for the deployment script</li> <li>We then call the <code>loadConfig</code> function we previously defined to load the chain configuration from the <code>config.json</code> file</li> </ul> </li> <li> <p>Set up provider and wallet: </p> <pre><code>  const sourceProvider = new ethers.JsonRpcProvider(sourceChain.rpc);\n  const targetProvider = new ethers.JsonRpcProvider(targetChain.rpc);\n  const wallet = new ethers.Wallet(process.env.PRIVATE_KEY!, sourceProvider);\n</code></pre> <p>The scripts establish a connection to the blockchain using a provider and create a wallet instance using a private key. This wallet is responsible for signing the deployment transaction on the source chain.</p> </li> <li> <p>Read the compiled contracts:</p> <pre><code>  const senderJson = JSON.parse(\n    fs.readFileSync(\n      path.resolve(\n        __dirname,\n        '../out/CrossChainSender.sol/CrossChainSender.json'\n      ),\n      'utf8'\n    )\n  );\n</code></pre> <ul> <li>This code reads the <code>CrossChainSender.json</code> file, the compiled output of the <code>CrossChainSender.sol</code> contract</li> <li>The file is in the <code>../out/</code> directory, which contains the ABI (Application Binary Interface) and bytecode generated during contract compilation</li> <li>It uses the <code>fs.readFileSync</code> function to read the file and <code>JSON.parse</code> to convert the file contents (in JSON format) into a JavaScript object</li> </ul> </li> <li> <p>Extract the contract ABI and bytecode:</p> <pre><code>  const abi = senderJson.abi;\n  const bytecode = senderJson.bytecode;\n</code></pre> <ul> <li>ABI (Application Binary Interface) - defines the structure of the contract\u2019s functions, events, and data types, allowing the front end to interact with the contract on the blockchain</li> <li>Bytecode - this is the compiled machine code that will be deployed to the blockchain to create the contract</li> </ul> </li> <li> <p>Create the Contract Factory:</p> <pre><code>  const CrossChainSenderFactory = new ethers.ContractFactory(\n    abi,\n    bytecode,\n    wallet\n  );\n</code></pre> <ul> <li><code>ethers.ContractFactory</code> - creates a new contract factory using the ABI, bytecode, and a wallet (representing the signer). The contract factory is responsible for deploying instances of the contract to the blockchain</li> <li>This is a crucial step for deploying the contract since the factory will create and deploy the <code>CrossChainSender</code> contract</li> </ul> </li> <li> <p>Deploy the <code>CrossChainSender</code> and <code>CrossChainReceiver</code> contracts:</p> <code>CrossChainSender</code><code>CrossChainReceiver</code> <pre><code>  try {\n    const senderContract = await CrossChainSenderFactory.deploy(\n      sourceChain.wormholeRelayer,\n      sourceChain.tokenBridge,\n      sourceChain.wormhole\n    );\n    await senderContract.waitForDeployment();\n</code></pre> <pre><code>    const targetWallet = new ethers.Wallet(\n      process.env.PRIVATE_KEY!,\n      targetProvider\n    );\n    const receiverJson = JSON.parse(\n      fs.readFileSync(\n        path.resolve(\n          __dirname,\n          '../out/CrossChainReceiver.sol/CrossChainReceiver.json'\n        ),\n        'utf8'\n      )\n    );\n    const CrossChainReceiverFactory = new ethers.ContractFactory(\n      receiverJson.abi,\n      receiverJson.bytecode,\n      targetWallet\n    );\n\n    const receiverContract = await CrossChainReceiverFactory.deploy(\n      targetChain.wormholeRelayer,\n      targetChain.tokenBridge,\n      targetChain.wormhole\n    );\n    await receiverContract.waitForDeployment();\n</code></pre> <p>Both functions deploy the respective contracts to the selected chains.</p> <p>For the <code>CrossChainReceiver</code> contract:</p> <ul> <li>It defines the wallet related to the target chain</li> <li>The logic reads the compiled ABI and bytecode from the JSON file generated during compilation</li> <li>It creates a new contract factory using the ABI, bytecode, and wallet</li> <li>It deploys the contract to the selected chain passing in the Wormhole Relayer, <code>TokenBridge</code>, and Wormhole addresses</li> </ul> </li> <li> <p>Save the deployed contract addresses:</p> <code>senderAddress</code><code>receiverAddress</code> <pre><code>    const senderAddress = (senderContract as ethers.Contract).target;\n    console.log(\n      `CrossChainSender on ${sourceChain.description}: ${senderAddress}`\n    );\n</code></pre> <pre><code>    const receiverAddress = (receiverContract as ethers.Contract).target;\n    console.log(\n      `CrossChainReceiver on ${targetChain.description}: ${receiverAddress}`\n    );\n</code></pre> <p>You may display the deployed contract addresses in the terminal or save them to a JSON file for future reference.</p> </li> <li> <p>Register the <code>CrossChainSender</code> address on the target chain:</p> <pre><code>    const CrossChainReceiverContract = new ethers.Contract(\n      receiverAddress,\n      receiverJson.abi,\n      targetWallet\n    );\n\n    const tx = await CrossChainReceiverContract.setRegisteredSender(\n      sourceChain.chainId,\n      ethers.zeroPadValue(senderAddress as BytesLike, 32)\n    );\n\n    await tx.wait();\n</code></pre> <p>After you deploy the <code>CrossChainReceiver</code> contract on the target network, the sender contract address from the source chain needs to be registered. This ensures that only messages from the registered <code>CrossChainSender</code> contract are processed.</p> <p>This additional step is essential to enforce emitter validation, preventing unauthorized senders from delivering messages to the <code>CrossChainReceiver</code> contract.</p> </li> <li> <p>Save the deployment details:</p> Save Deployment Details Example <pre><code>    const deployedContractsPath = path.resolve(\n      __dirname,\n      '../deploy-config/contracts.json'\n    );\n    let deployedContracts: DeployedContracts = {};\n\n    if (fs.existsSync(deployedContractsPath)) {\n      deployedContracts = JSON.parse(\n        fs.readFileSync(deployedContractsPath, 'utf8')\n      );\n    }\n\n    // Update the contracts.json file:\n    // If a contract already exists on a chain, update its address; otherwise, add a new entry.\n    if (!deployedContracts[sourceChain.chainId]) {\n      deployedContracts[sourceChain.chainId] = {\n        networkName: sourceChain.description,\n        deployedAt: new Date().toISOString(),\n      };\n    }\n    deployedContracts[sourceChain.chainId].CrossChainSender =\n      senderAddress.toString();\n    deployedContracts[sourceChain.chainId].deployedAt =\n      new Date().toISOString();\n\n    if (!deployedContracts[targetChain.chainId]) {\n      deployedContracts[targetChain.chainId] = {\n        networkName: targetChain.description,\n        deployedAt: new Date().toISOString(),\n      };\n    }\n    deployedContracts[targetChain.chainId].CrossChainReceiver =\n      receiverAddress.toString();\n    deployedContracts[targetChain.chainId].deployedAt =\n      new Date().toISOString();\n\n    // Save the updated contracts.json file\n    fs.writeFileSync(\n      deployedContractsPath,\n      JSON.stringify(deployedContracts, null, 2)\n    );\n</code></pre> <p>Add your desired logic to save the deployed contract addresses in a JSON file (or another format). This will be important later when transferring tokens, as you'll need these addresses to interact with the deployed contracts.</p> </li> <li> <p>Handle errors and finalize the script:</p> <pre><code>  } catch (error: any) {\n    if (error.code === 'INSUFFICIENT_FUNDS') {\n      console.error(\n        'Error: Insufficient funds for deployment. Please make sure your wallet has enough funds to cover the gas fees.'\n      );\n    } else {\n      console.error('An unexpected error occurred:', error.message);\n    }\n    process.exit(1);\n  }\n}\n\nmain().catch((error) =&gt; {\n  console.error(error);\n  process.exit(1);\n});\n</code></pre> <p>The try-catch block wraps the deployment logic to catch any errors that may occur.</p> <ul> <li>If the error is due to insufficient funds, it logs a clear message about needing more gas fees</li> <li>For any other errors, it logs the specific error message to help with debugging</li> </ul> <p>The <code>process.exit(1)</code> ensures that the script exits with a failure status code if any error occurs.</p> </li> </ol> <p>You can find the full code for the <code>deploy.ts</code> file below:</p> deploy.ts <pre><code>import { BytesLike, ethers } from 'ethers';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport * as dotenv from 'dotenv';\nimport readlineSync from 'readline-sync';\n\ndotenv.config();\n\ninterface ChainConfig {\n  description: string;\n  chainId: number;\n  rpc: string;\n  tokenBridge: string;\n  wormholeRelayer: string;\n  wormhole: string;\n}\n\ninterface DeployedContracts {\n  [chainId: number]: {\n    networkName: string;\n    CrossChainSender?: string;\n    CrossChainReceiver?: string;\n    deployedAt: string;\n  };\n}\n\nfunction loadConfig(): ChainConfig[] {\n  const configPath = path.resolve(__dirname, '../deploy-config/config.json');\n  return JSON.parse(fs.readFileSync(configPath, 'utf8')).chains;\n}\n\nfunction selectChain(\n  chains: ChainConfig[],\n  role: 'source' | 'target'\n): ChainConfig {\n  console.log(`\\nSelect the ${role.toUpperCase()} chain:`);\n  chains.forEach((chain, index) =&gt; {\n    console.log(`${index + 1}: ${chain.description}`);\n  });\n\n  const chainIndex =\n    readlineSync.questionInt(\n      `\\nEnter the number for the ${role.toUpperCase()} chain: `\n    ) - 1;\n  return chains[chainIndex];\n}\n\nasync function main() {\n  const chains = loadConfig();\n\n  const sourceChain = selectChain(chains, 'source');\n  const targetChain = selectChain(chains, 'target');\n\n  const sourceProvider = new ethers.JsonRpcProvider(sourceChain.rpc);\n  const targetProvider = new ethers.JsonRpcProvider(targetChain.rpc);\n  const wallet = new ethers.Wallet(process.env.PRIVATE_KEY!, sourceProvider);\n\n  const senderJson = JSON.parse(\n    fs.readFileSync(\n      path.resolve(\n        __dirname,\n        '../out/CrossChainSender.sol/CrossChainSender.json'\n      ),\n      'utf8'\n    )\n  );\n\n  const abi = senderJson.abi;\n  const bytecode = senderJson.bytecode;\n\n  const CrossChainSenderFactory = new ethers.ContractFactory(\n    abi,\n    bytecode,\n    wallet\n  );\n\n  try {\n    const senderContract = await CrossChainSenderFactory.deploy(\n      sourceChain.wormholeRelayer,\n      sourceChain.tokenBridge,\n      sourceChain.wormhole\n    );\n    await senderContract.waitForDeployment();\n\n    // Safely access the deployed contract's address\n    const senderAddress = (senderContract as ethers.Contract).target;\n    console.log(\n      `CrossChainSender on ${sourceChain.description}: ${senderAddress}`\n    );\n\n    const targetWallet = new ethers.Wallet(\n      process.env.PRIVATE_KEY!,\n      targetProvider\n    );\n    const receiverJson = JSON.parse(\n      fs.readFileSync(\n        path.resolve(\n          __dirname,\n          '../out/CrossChainReceiver.sol/CrossChainReceiver.json'\n        ),\n        'utf8'\n      )\n    );\n    const CrossChainReceiverFactory = new ethers.ContractFactory(\n      receiverJson.abi,\n      receiverJson.bytecode,\n      targetWallet\n    );\n\n    const receiverContract = await CrossChainReceiverFactory.deploy(\n      targetChain.wormholeRelayer,\n      targetChain.tokenBridge,\n      targetChain.wormhole\n    );\n    await receiverContract.waitForDeployment();\n\n    // Safely access the deployed contract's address\n    const receiverAddress = (receiverContract as ethers.Contract).target;\n    console.log(\n      `CrossChainReceiver on ${targetChain.description}: ${receiverAddress}`\n    );\n\n    // Register the sender contract in the receiver contract\n    console.log(\n      `Registering CrossChainSender (${senderAddress}) as a valid sender in CrossChainReceiver (${receiverAddress})...`\n    );\n\n    const CrossChainReceiverContract = new ethers.Contract(\n      receiverAddress,\n      receiverJson.abi,\n      targetWallet\n    );\n\n    const tx = await CrossChainReceiverContract.setRegisteredSender(\n      sourceChain.chainId,\n      ethers.zeroPadValue(senderAddress as BytesLike, 32)\n    );\n\n    await tx.wait();\n    console.log(\n      `CrossChainSender registered as a valid sender on ${targetChain.description}`\n    );\n\n    // Load existing deployed contract addresses from contracts.json\n    const deployedContractsPath = path.resolve(\n      __dirname,\n      '../deploy-config/contracts.json'\n    );\n    let deployedContracts: DeployedContracts = {};\n\n    if (fs.existsSync(deployedContractsPath)) {\n      deployedContracts = JSON.parse(\n        fs.readFileSync(deployedContractsPath, 'utf8')\n      );\n    }\n\n    // Update the contracts.json file:\n    // If a contract already exists on a chain, update its address; otherwise, add a new entry.\n    if (!deployedContracts[sourceChain.chainId]) {\n      deployedContracts[sourceChain.chainId] = {\n        networkName: sourceChain.description,\n        deployedAt: new Date().toISOString(),\n      };\n    }\n    deployedContracts[sourceChain.chainId].CrossChainSender =\n      senderAddress.toString();\n    deployedContracts[sourceChain.chainId].deployedAt =\n      new Date().toISOString();\n\n    if (!deployedContracts[targetChain.chainId]) {\n      deployedContracts[targetChain.chainId] = {\n        networkName: targetChain.description,\n        deployedAt: new Date().toISOString(),\n      };\n    }\n    deployedContracts[targetChain.chainId].CrossChainReceiver =\n      receiverAddress.toString();\n    deployedContracts[targetChain.chainId].deployedAt =\n      new Date().toISOString();\n\n    // Save the updated contracts.json file\n    fs.writeFileSync(\n      deployedContractsPath,\n      JSON.stringify(deployedContracts, null, 2)\n    );\n  } catch (error: any) {\n    if (error.code === 'INSUFFICIENT_FUNDS') {\n      console.error(\n        'Error: Insufficient funds for deployment. Please make sure your wallet has enough funds to cover the gas fees.'\n      );\n    } else {\n      console.error('An unexpected error occurred:', error.message);\n    }\n    process.exit(1);\n  }\n}\n\nmain().catch((error) =&gt; {\n  console.error(error);\n  process.exit(1);\n});\n</code></pre> </li> <li> <p>Add your private key - you'll need to provide your private key. It allows your deployment script to sign the transactions that deploy the smart contracts to the blockchain. Without it, the script won't be able to interact with the blockchain on your behalf</p> <p>Create a <code>.env</code> file in the root of the project and add your private key:</p> <pre><code>touch .env\n</code></pre> <p>Inside <code>.env</code>, add your private key in the following format:</p> <pre><code>PRIVATE_KEY=INSERT_PRIVATE_KEY\n</code></pre> </li> <li> <p>Run the deployment script</p> <ol> <li> <p>Open a terminal and run the following command:</p> <pre><code>npx ts-node script/deploy.ts\n</code></pre> <p>This will execute the deployment script, deploying both contracts to the selected chains.</p> </li> <li> <p>Check the deployment output:</p> <ul> <li>You will see the deployed contract addresses printed in the terminal if successful. The <code>contracts.json</code> file will be updated with these addresses</li> <li>If you encounter an error, the script will provide feedback, such as insufficient funds for gas</li> </ul> </li> </ol> </li> </ol> <p>If you followed the logic provided in the full code above, your terminal output should look something like this:</p> npx ts-node deploy.ts  &gt; cross-chain-token-transfer@1.0.0 deploy  &gt; npx ts-node script/deploy.ts  Select the SOURCE chain:  1: Avalanche testnet fuji  2: Celo Testnet  Enter the number for the SOURCE chain: 1  Select the TARGET chain:  1: Avalanche testnet fuji  2: Celo Testnet  Enter the number for the TARGET chain: 2  CrossChainSender Avalanche testnet fuji: 0x1Cac52a183D02F9002fdb37b13eC2fAB950d44E3  CrossChainReceiver Celo Testnet: 0xD720BFF42a0960cfF1118454A907a44dB358f2b1  Registering CrossChainSender (0x1Cac52a183D02F9002fdb37b13eC2fAB950d44E3) as a valid sender in CrossChainReceiver (0xD720BFF42a0960cfF1118454A907a44dB358f2b1)...  CrossChainSender registered as a valid sender on Celo Testnet"},{"location":"tutorials/messaging/cross-chain-token-contracts/#transfer-tokens-across-chains","title":"Transfer Tokens Across Chains","text":""},{"location":"tutorials/messaging/cross-chain-token-contracts/#quick-recap","title":"Quick Recap","text":"<p>Up to this point, you've set up a new Solidity project using Foundry, developed two key contracts (<code>CrossChainSender</code> and <code>CrossChainReceiver</code>), and created a deployment script to deploy these contracts to different blockchain networks. The deployment script also saves the new contract addresses for easy reference. With everything in place, it's time to transfer tokens using the deployed contracts.</p> <p>In this step, you'll write a script to transfer tokens across chains using the <code>CrossChainSender</code> and <code>CrossChainReceiver</code> contracts you deployed earlier. This script will interact with the contracts and facilitate the cross-chain token transfer.</p>"},{"location":"tutorials/messaging/cross-chain-token-contracts/#transfer-script","title":"Transfer Script","text":"<ol> <li> <p>Set up the transfer script</p> <ol> <li> <p>Create a new file named <code>transfer.ts</code> in the <code>/script</code> directory:</p> <pre><code>touch script/transfer.ts\n</code></pre> </li> <li> <p>Open the file. Start with the necessary imports, interfaces and configurations:</p> <pre><code>import { ethers } from 'ethers';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport * as dotenv from 'dotenv';\nimport readlineSync from 'readline-sync';\n\ndotenv.config();\n\ninterface ChainConfig {\n  description: string;\n  chainId: number;\n  rpc: string;\n  tokenBridge: string;\n  wormholeRelayer: string;\n  wormhole: string;\n}\n\ninterface DeployedContracts {\n  [chainId: number]: {\n    networkName: string;\n    CrossChainSender?: string;\n    CrossChainReceiver?: string;\n    deployedAt: string;\n  };\n}\n</code></pre> <p>These imports include the essential libraries for interacting with Ethereum, handling file paths, loading environment variables, and managing user input.</p> </li> <li> <p>Load configuration and contracts:</p> <pre><code>function loadConfig(): ChainConfig[] {\n  const configPath = path.resolve(__dirname, '../deploy-config/config.json');\n  return JSON.parse(fs.readFileSync(configPath, 'utf8')).chains;\n}\n\nfunction loadDeployedContracts(): DeployedContracts {\n  const contractsPath = path.resolve(\n    __dirname,\n    '../deploy-config/contracts.json'\n  );\n  if (\n    !fs.existsSync(contractsPath) ||\n    fs.readFileSync(contractsPath, 'utf8').trim() === ''\n  ) {\n    console.error(\n      'No contracts found. Please deploy contracts first before transferring tokens.'\n    );\n    process.exit(1);\n  }\n  return JSON.parse(fs.readFileSync(contractsPath, 'utf8'));\n}\n</code></pre> <p>These functions load the network and contract details that were saved during deployment.</p> </li> <li> <p>Allow users to select source and target chains:</p> <p>Refer to the deployed contracts and create logic as desired. In our example, we made this process interactive, allowing users to select the source and target chains from all the historically deployed contracts. This interactive approach helps ensure the correct chains are selected for the token transfer.</p> <pre><code>function selectSourceChain(deployedContracts: DeployedContracts): {\n  chainId: number;\n  networkName: string;\n} {\n  const sourceOptions = Object.entries(deployedContracts).filter(\n    ([, contracts]) =&gt; contracts.CrossChainSender\n  );\n\n  if (sourceOptions.length === 0) {\n    console.error('No source chains available with CrossChainSender deployed.');\n    process.exit(1);\n  }\n\n  console.log('\\nSelect the source chain:');\n  sourceOptions.forEach(([chainId, contracts], index) =&gt; {\n    console.log(`${index + 1}: ${contracts.networkName}`);\n  });\n\n  const selectedIndex =\n    readlineSync.questionInt(`\\nEnter the number for the source chain: `) - 1;\n  return {\n    chainId: Number(sourceOptions[selectedIndex][0]),\n    networkName: sourceOptions[selectedIndex][1].networkName,\n  };\n}\n\nfunction selectTargetChain(deployedContracts: DeployedContracts): {\n  chainId: number;\n  networkName: string;\n} {\n  const targetOptions = Object.entries(deployedContracts).filter(\n    ([, contracts]) =&gt; contracts.CrossChainReceiver\n  );\n\n  if (targetOptions.length === 0) {\n    console.error(\n      'No target chains available with CrossChainReceiver deployed.'\n    );\n    process.exit(1);\n  }\n\n  console.log('\\nSelect the target chain:');\n  targetOptions.forEach(([chainId, contracts], index) =&gt; {\n    console.log(`${index + 1}: ${contracts.networkName}`);\n  });\n\n  const selectedIndex =\n    readlineSync.questionInt(`\\nEnter the number for the target chain: `) - 1;\n  return {\n    chainId: Number(targetOptions[selectedIndex][0]),\n    networkName: targetOptions[selectedIndex][1].networkName,\n  };\n}\n</code></pre> </li> </ol> </li> <li> <p>Implement the token transfer logic</p> <ol> <li> <p>Start the <code>main</code> function:</p> <pre><code>async function main() {\n  const chains = loadConfig();\n  const deployedContracts = loadDeployedContracts();\n\n  // Select the source chain (only show chains with CrossChainSender deployed)\n  const { chainId: sourceChainId, networkName: sourceNetworkName } =\n    selectSourceChain(deployedContracts);\n  const sourceChain = chains.find((chain) =&gt; chain.chainId === sourceChainId)!;\n\n  // Select the target chain (only show chains with CrossChainReceiver deployed)\n  const { chainId: targetChainId, networkName: targetNetworkName } =\n    selectTargetChain(deployedContracts);\n  const targetChain = chains.find((chain) =&gt; chain.chainId === targetChainId)!;\n\n  // Set up providers and wallets\n  const sourceProvider = new ethers.JsonRpcProvider(sourceChain.rpc);\n  const wallet = new ethers.Wallet(process.env.PRIVATE_KEY!, sourceProvider);\n\n  // Load the ABI from the JSON file (use the compiled ABI from Forge or Hardhat)\n  const CrossChainSenderArtifact = JSON.parse(\n    fs.readFileSync(\n      path.resolve(\n        __dirname,\n        '../out/CrossChainSender.sol/CrossChainSender.json'\n      ),\n      'utf8'\n    )\n  );\n\n  const abi = CrossChainSenderArtifact.abi;\n\n  // Create the contract instance using the full ABI\n  const CrossChainSender = new ethers.Contract(\n    deployedContracts[sourceChainId].CrossChainSender!,\n    abi,\n    wallet\n  );\n</code></pre> <p>The <code>main</code> function is where the token transfer logic will reside. It loads the chain and contract details, sets up the wallet and provider, and loads the <code>CrossChainSender</code> contract.</p> </li> <li> <p>Ask the user for token transfer details:</p> <p>You'll now ask the user for the token contract address, the recipient address on the target chain, and the amount of tokens to transfer.</p> <pre><code>  const tokenAddress = readlineSync.question(\n    'Enter the token contract address: '\n  );\n  const recipientAddress = readlineSync.question(\n    'Enter the recipient address on the target chain: '\n  );\n\n  // Get the token contract\n  const tokenContractDecimals = new ethers.Contract(\n    tokenAddress,\n    [\n      'function decimals() view returns (uint8)',\n      'function approve(address spender, uint256 amount) public returns (bool)',\n    ],\n    wallet\n  );\n\n  // Fetch the token decimals\n  const decimals = await tokenContractDecimals.decimals();\n\n  // Get the amount from the user, then parse it according to the token's decimals\n  const amount = ethers.parseUnits(\n    readlineSync.question('Enter the amount of tokens to transfer: '),\n    decimals\n  );\n</code></pre> <p>This section of the script prompts the user for the token contract address and the recipient's address, fetches the token's decimal value, and parses the amount accordingly.</p> </li> <li> <p>Initiate the transfer:</p> <p>Finally, initiate the cross-chain transfer and log the details.</p> <pre><code>  const cost = await CrossChainSender.quoteCrossChainDeposit(targetChainId);\n\n  // Approve the CrossChainSender contract to transfer tokens on behalf of the user\n  const tokenContract = new ethers.Contract(\n    tokenAddress,\n    ['function approve(address spender, uint256 amount) public returns (bool)'],\n    wallet\n  );\n\n  const approveTx = await tokenContract.approve(\n    deployedContracts[sourceChainId].CrossChainSender!,\n    amount\n  );\n  await approveTx.wait();\n  console.log(`Approved tokens for cross-chain transfer.`);\n\n  // Initiate the cross-chain transfer\n  const transferTx = await CrossChainSender.sendCrossChainDeposit(\n    targetChainId,\n    deployedContracts[targetChainId].CrossChainReceiver!,\n    recipientAddress,\n    amount,\n    tokenAddress,\n    { value: cost } // Attach the necessary fee for cross-chain transfer\n  );\n  await transferTx.wait();\n  console.log(\n    `Transfer initiated from ${sourceNetworkName} to ${targetNetworkName}. Transaction Hash: ${transferTx.hash}`\n  );\n}\n</code></pre> <p>This part of the script first approves the token transfer, then initiates the cross-chain transfer using the <code>CrossChainSender</code> contract, and finally logs the transaction hash for the user to track.</p> </li> <li> <p>Finalize the script:</p> <pre><code>main().catch((error) =&gt; {\n  console.error(error);\n  process.exit(1);\n});\n</code></pre> <p>This section finalizes the script by calling the <code>main</code> function and handling any errors that may occur during the token transfer process.</p> </li> </ol> </li> </ol> <p>You can find the full code for the <code>transfer.ts</code> file below:</p> transfer.ts <pre><code>import { ethers } from 'ethers';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport * as dotenv from 'dotenv';\nimport readlineSync from 'readline-sync';\n\ndotenv.config();\n\ninterface ChainConfig {\n  description: string;\n  chainId: number;\n  rpc: string;\n  tokenBridge: string;\n  wormholeRelayer: string;\n  wormhole: string;\n}\n\ninterface DeployedContracts {\n  [chainId: number]: {\n    networkName: string;\n    CrossChainSender?: string;\n    CrossChainReceiver?: string;\n    deployedAt: string;\n  };\n}\n\nfunction loadConfig(): ChainConfig[] {\n  const configPath = path.resolve(__dirname, '../deploy-config/config.json');\n  return JSON.parse(fs.readFileSync(configPath, 'utf8')).chains;\n}\n\nfunction loadDeployedContracts(): DeployedContracts {\n  const contractsPath = path.resolve(\n    __dirname,\n    '../deploy-config/contracts.json'\n  );\n  if (\n    !fs.existsSync(contractsPath) ||\n    fs.readFileSync(contractsPath, 'utf8').trim() === ''\n  ) {\n    console.error(\n      'No contracts found. Please deploy contracts first before transferring tokens.'\n    );\n    process.exit(1);\n  }\n  return JSON.parse(fs.readFileSync(contractsPath, 'utf8'));\n}\n\nfunction selectSourceChain(deployedContracts: DeployedContracts): {\n  chainId: number;\n  networkName: string;\n} {\n  const sourceOptions = Object.entries(deployedContracts).filter(\n    ([, contracts]) =&gt; contracts.CrossChainSender\n  );\n\n  if (sourceOptions.length === 0) {\n    console.error('No source chains available with CrossChainSender deployed.');\n    process.exit(1);\n  }\n\n  console.log('\\nSelect the source chain:');\n  sourceOptions.forEach(([chainId, contracts], index) =&gt; {\n    console.log(`${index + 1}: ${contracts.networkName}`);\n  });\n\n  const selectedIndex =\n    readlineSync.questionInt(`\\nEnter the number for the source chain: `) - 1;\n  return {\n    chainId: Number(sourceOptions[selectedIndex][0]),\n    networkName: sourceOptions[selectedIndex][1].networkName,\n  };\n}\n\nfunction selectTargetChain(deployedContracts: DeployedContracts): {\n  chainId: number;\n  networkName: string;\n} {\n  const targetOptions = Object.entries(deployedContracts).filter(\n    ([, contracts]) =&gt; contracts.CrossChainReceiver\n  );\n\n  if (targetOptions.length === 0) {\n    console.error(\n      'No target chains available with CrossChainReceiver deployed.'\n    );\n    process.exit(1);\n  }\n\n  console.log('\\nSelect the target chain:');\n  targetOptions.forEach(([chainId, contracts], index) =&gt; {\n    console.log(`${index + 1}: ${contracts.networkName}`);\n  });\n\n  const selectedIndex =\n    readlineSync.questionInt(`\\nEnter the number for the target chain: `) - 1;\n  return {\n    chainId: Number(targetOptions[selectedIndex][0]),\n    networkName: targetOptions[selectedIndex][1].networkName,\n  };\n}\n\nasync function main() {\n  const chains = loadConfig();\n  const deployedContracts = loadDeployedContracts();\n\n  // Select the source chain (only show chains with CrossChainSender deployed)\n  const { chainId: sourceChainId, networkName: sourceNetworkName } =\n    selectSourceChain(deployedContracts);\n  const sourceChain = chains.find((chain) =&gt; chain.chainId === sourceChainId)!;\n\n  // Select the target chain (only show chains with CrossChainReceiver deployed)\n  const { chainId: targetChainId, networkName: targetNetworkName } =\n    selectTargetChain(deployedContracts);\n  const targetChain = chains.find((chain) =&gt; chain.chainId === targetChainId)!;\n\n  // Set up providers and wallets\n  const sourceProvider = new ethers.JsonRpcProvider(sourceChain.rpc);\n  const wallet = new ethers.Wallet(process.env.PRIVATE_KEY!, sourceProvider);\n\n  // Load the ABI from the JSON file (use the compiled ABI from Forge or Hardhat)\n  const CrossChainSenderArtifact = JSON.parse(\n    fs.readFileSync(\n      path.resolve(\n        __dirname,\n        '../out/CrossChainSender.sol/CrossChainSender.json'\n      ),\n      'utf8'\n    )\n  );\n\n  const abi = CrossChainSenderArtifact.abi;\n\n  // Create the contract instance using the full ABI\n  const CrossChainSender = new ethers.Contract(\n    deployedContracts[sourceChainId].CrossChainSender!,\n    abi,\n    wallet\n  );\n\n  // Display the selected chains\n  console.log(\n    `\\nInitiating transfer from ${sourceNetworkName} to ${targetNetworkName}.`\n  );\n\n  // Ask the user for token transfer details\n  const tokenAddress = readlineSync.question(\n    'Enter the token contract address: '\n  );\n  const recipientAddress = readlineSync.question(\n    'Enter the recipient address on the target chain: '\n  );\n\n  // Get the token contract\n  const tokenContractDecimals = new ethers.Contract(\n    tokenAddress,\n    [\n      'function decimals() view returns (uint8)',\n      'function approve(address spender, uint256 amount) public returns (bool)',\n    ],\n    wallet\n  );\n\n  // Fetch the token decimals\n  const decimals = await tokenContractDecimals.decimals();\n\n  // Get the amount from the user, then parse it according to the token's decimals\n  const amount = ethers.parseUnits(\n    readlineSync.question('Enter the amount of tokens to transfer: '),\n    decimals\n  );\n\n  // Calculate the cross-chain transfer cost\n  const cost = await CrossChainSender.quoteCrossChainDeposit(targetChainId);\n\n  // Approve the CrossChainSender contract to transfer tokens on behalf of the user\n  const tokenContract = new ethers.Contract(\n    tokenAddress,\n    ['function approve(address spender, uint256 amount) public returns (bool)'],\n    wallet\n  );\n\n  const approveTx = await tokenContract.approve(\n    deployedContracts[sourceChainId].CrossChainSender!,\n    amount\n  );\n  await approveTx.wait();\n  console.log(`Approved tokens for cross-chain transfer.`);\n\n  // Initiate the cross-chain transfer\n  const transferTx = await CrossChainSender.sendCrossChainDeposit(\n    targetChainId,\n    deployedContracts[targetChainId].CrossChainReceiver!,\n    recipientAddress,\n    amount,\n    tokenAddress,\n    { value: cost } // Attach the necessary fee for cross-chain transfer\n  );\n  await transferTx.wait();\n  console.log(\n    `Transfer initiated from ${sourceNetworkName} to ${targetNetworkName}. Transaction Hash: ${transferTx.hash}`\n  );\n}\n\nmain().catch((error) =&gt; {\n  console.error(error);\n  process.exit(1);\n});\n</code></pre>"},{"location":"tutorials/messaging/cross-chain-token-contracts/#transfer-tokens","title":"Transfer Tokens","text":"<p>Now that your transfer script is ready, it\u2019s time to execute it and perform a cross-chain token transfer.</p> <ol> <li> <p>Run the transfer script</p> <p>Open your terminal and run the transfer script:</p> <pre><code>npx ts-node script/transfer.ts\n</code></pre> <p>This command will start the script, prompting you to select the source and target chains, input the token address, recipient address, and the amount of tokens to transfer.</p> </li> <li> <p>Follow the prompts - the script will guide you through selecting the source and target chains and entering the necessary details for the token transfer. Once you provide all the required information, the script will initiate the token transfer</p> </li> <li> <p>Verify the transaction - after running the script, you should see a confirmation message with the transaction hash. You can use this transaction hash to check the transfer status on the respective blockchain explorers</p> </li> </ol> <p>You can verify the transaction on the Wormhole Explorer using the link provided in the terminal output. This explorer also offers the option to add the transferred token to your MetaMask wallet automatically.</p> <p>If you followed the logic provided in the <code>transfer.ts</code> file above, your terminal output should look something like this:</p> npx ts-node transfer.ts  &gt; cross-chain-token-transfer@1.0.0 transfer  &gt; npx ts-node script/transfer.ts  Select the source chain:  1: Avalanche testnet fuji  2: Celo Testnet  Enter the number for the SOURCE chain: 1  Select the target chain:  1: Avalanche testnet fuji  2: Celo Testnet  Enter the number for the TARGET chain: 2  Initiating transfer from Avalanche testnet fuji to Celo Testnet  Enter the token contract address: 0x5425890298aed601595a70ab815c96711a31bc65  Enter the recipient address on the target chain: INSERT_YOUR_WALLET_ADDRESS  Enter the amount of tokens to transfer: 2  Approved tokens for cross-chain transfer.  Transfer initiated from Avalanche testnet fuji to Celo Testnet. Transaction Hash: 0x4a923975d955c1f226a1c2f61a1a0fa1ab1a9e229dc29ceaeadf8ef40acd071f <p>Note</p> <p>In this example, we demonstrated a token transfer from the Avalanche Fuji TestNet to the Celo Alfajores TestNet. We sent two units of USDC TestNet tokens using the token contract address <code>0x5425890298aed601595a70ab815c96711a31bc65</code>. You can replace these details with those relevant to your project or use the same for testing purposes.</p>"},{"location":"tutorials/messaging/cross-chain-token-contracts/#resources","title":"Resources","text":"<p>If you'd like to explore the complete project or need a reference while following this tutorial, you can find the complete codebase in the Cross-Chain Token Transfers GitHub repository. The repository includes all the scripts, contracts, and configurations needed to deploy and transfer tokens across chains using the Wormhole protocol.</p>"},{"location":"tutorials/messaging/cross-chain-token-contracts/#conclusion","title":"Conclusion","text":"<p>Congratulations! You've successfully built and deployed a cross-chain token transfer system using Solidity and the Wormhole protocol. You've learned how to:</p> <ul> <li>Set up a new Solidity project using Foundry</li> <li>Develop smart contracts to send and receive tokens across chains</li> <li>Write deployment scripts to manage and deploy contracts on different networks</li> </ul>"}]}